<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android逆向学习</title>
    <url>/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是TG:HACK2020的一道比赛题目<br>题目给的hint很误导人…反正我没看出来  </p>
<blockquote>
<blockquote>
<blockquote>
<p>Hint<br>Random title?  </p>
</blockquote>
</blockquote>
</blockquote>
<p>这是题目描述：Someone found this very old game lying around. Apparently there is an extremely funny joke in there somewhere.</p>
<p>之前没怎么做过安卓题目，所以这次真是学到了很多<br>题目的名字叫Bad intentions<br>上Google搜索之后发现是一堆歌曲，好吧这肯定跟题目没啥关系<br>当搜索apk intentions的时候就出现了有用的信息：<br><img src="1.jpg" alt="google搜索结果">  </p>
<p>所谓的apk intentions就是指这个程序能不能被外部访问，或者进行数据交换  </p>
<blockquote>
<blockquote>
<blockquote>
<p>Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动 作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的 交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>然后就是如何查看这个apk包中有没有调用intent这个类了<br><code>aapt dump xmltree gaiainvaders.apk AndroidManifest.xml</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>关于AndroidManifest.xml这个文件的介绍<a href="https://www.jianshu.com/p/3b5b89d4e154" target="_blank" rel="noopener">点这</a></p>
<p>就会输出如下信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E: activity (line&#x3D;19)  </span><br><span class="line">    A:android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;20)</span><br><span class="line">          E: action (line&#x3D;21)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;23)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br><span class="line">    E: activity (line&#x3D;26)</span><br><span class="line">        A: android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.JokeActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.JokeActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;27)</span><br><span class="line">          E: action (line&#x3D;28)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;30)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看出了是调用了intent类的，而且发现一个JokeActivity的类。联想到题目描述觉得应该是这个文件了，用jeb打开看一下(我当时做这道题的时候没想到这，被其他地方误导了)  </p>
<p><img src="2.jpg" alt=""></p>
<p>这是JokeActivity方法，我当时被这个给迷惑了…  </p>
<p><img src="3.jpg" alt=""></p>
<p>到这可以看出来是个AES加密，写出脚本就可以跑出来了(大概，我没试)<br>还有一种更简单的方法<br>学习一下<br>上述提到了intent这个包，它是对于Android程序安全性相关性很大的包，有了它之后我们就可以对这个APK进行调试<br><code>adb install gaiainvaders.apk</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>adb全称Android Debug Bridge，是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。说直白一点就是通过adb可以实现<strong>用命令行控制设备。</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>使用adb有两种方法  </p>
<ol>
<li>需要安装安卓手机模拟器，这里我选择了网易的mumu模拟器，安装之后在<strong>platform-tools</strong>下运行adb程序<br><code>adb connect 127.0.0.1:7555</code><br>每个模拟器默认的端口不一样，具体的<a href="https://www.cnblogs.com/HakunaMatata-/p/10609307.html" target="_blank" rel="noopener">看这</a><br>等它显示success之后就表示连接上了，之后执行安装命令就好了  </li>
<li>用安卓手机之间连接，手机进入开发者模式，cmd中输入<br><code>adb devices</code><br>之后就安装就可以了  </li>
</ol>
<p>然后我们只需要运行JokeActivity这个类就能得到flag了，这里用<br><code>adb shell am start -n &quot;no.tghack.gaiainvaders/.JokeActivity&quot;</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.</p>
</blockquote>
</blockquote>
</blockquote>
<p>启动的方法为</p>
<p><code>adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}</code>  </p>
<p>然后就得到了flag<br><img src="4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python2的encode(&#39;hex&#39;)在python3上的解决</title>
    <url>/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  </p>
<a id="more"></a>  

<p>python2对于字符串转换成hex编码的时候使用的是str本身具有的方法，即str.encode(‘hex’)<br>但是这个方法在python3中取消了，解决方案如下：<br>首先  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; bytes(str,encoding &#x3D; &#39;utf-8&#39;)  </span><br><span class="line">str1.hex()</span><br></pre></td></tr></table></figure>
<p>即可  </p>
<p>顺便扩充一下知识：  </p>
<h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><h3 id="1-使用bytes函数创建bytes"><a href="#1-使用bytes函数创建bytes" class="headerlink" title="1.使用bytes函数创建bytes"></a>1.使用bytes函数创建bytes</h3><ul>
<li>bytes() 创建一个空的bytes  </li>
<li>bytes(int) 创建一个int位的全位0的bytes  </li>
<li>bytes(iterabl_of_ints) 可迭代数字组成的bytes(比如range)</li>
<li>bytes(string,encoding[,errors]) 等价于string.encode()</li>
<li>bytes(bytes of buffer) 创建一个bytes的copy  </li>
</ul>
<h3 id="2-直接定义"><a href="#2-直接定义" class="headerlink" title="2.直接定义"></a>2.直接定义</h3><p>比如：</p>
<p>​ b = b’abc’</p>
<p>​ b = b’\x61’</p>
<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><ul>
<li>string.encode()</li>
<li>int.tobytes()</li>
<li>bytes.from</li>
<li>bytes函数定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes()</span><br><span class="line">b&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(3)</span><br><span class="line">b&#39;\x00\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(range(3))</span><br><span class="line">b&#39;\x00\x01\x02&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;中国&#39;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(b)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br></pre></td></tr></table></figure>


<p>直接创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; b&#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<p>类型转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; 97</span><br><span class="line">&gt;&gt;&gt; n.to_bytes(1,byteorder&#x3D;&#39;big&#39;)</span><br><span class="line">b&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;中国&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.encode(encoding &#x3D; &#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;61&#39;)</span><br><span class="line">b&#39;a&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytes的显示方式"><a href="#bytes的显示方式" class="headerlink" title="bytes的显示方式"></a>bytes的显示方式</h2><blockquote>
<blockquote>
<blockquote>
<p>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</p>
</blockquote>
</blockquote>
</blockquote>
<p>只有ASCII中的字符串是可以直接在bytes类型中显示出来的，所有大于127的数值用转义字符表达。</p>
<p>比如，内存中的字节对象用十六进制表示为61，在python中显示的方式不是b’\x61’ 而是b’a’；而b’\xe4’显示方式就是b’\xe4’；注意：仅仅是显示方式而已</p>
<p>另外，并不是所有的小于127的都可以被友好的显示出来，有些对象本身不可显示，就显示其十六进制表示。比如</p>
<p>b’\x00’</p>
<p>bytes的一般方法<br>bytes类似于string；在方法上，除了自己特有的方法外，跟str也类似。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.find(b&#39;\x63&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.replace(b&#39;\61&#39;,b&#39;A&#39;)</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><p>bytearray是可变的bytes数据类型，可以通过bytearray创建和定义</p>
<h3 id="一：bytearray-定义"><a href="#一：bytearray-定义" class="headerlink" title="一：bytearray()定义"></a>一：bytearray()定义</h3><ul>
<li><p>bytearray() 创建一个空的bytearray</p>
</li>
<li><p>bytearray(int) 创建一个int位的全位0的bytearray</p>
</li>
<li><p>bytearray(iterabl_of_ints) 可迭代数字组成的bytearray(比如range)</p>
</li>
<li><p>bytearray(string,encoding[,errors]) 将一个字符串编码为bytearray</p>
</li>
<li><p>bytearray(bytes of buffer) 创建一个bytearray</p>
<h3 id="二-bytearray的方法定义"><a href="#二-bytearray的方法定义" class="headerlink" title="二: bytearray的方法定义"></a>二: bytearray的方法定义</h3></li>
<li><p>bytearray.fromhex()  </p>
<h3 id="bytearray的一般方法"><a href="#bytearray的一般方法" class="headerlink" title="bytearray的一般方法"></a>bytearray的一般方法</h3></li>
</ul>
<p>bytearray具备bytes的操作方法，像字符串一样操作；</p>
<p>另外bytearray还具备像list一样的操作方法，比如pop，append等</p>
<h3 id="bytes-和-bytearray的方法"><a href="#bytes-和-bytearray的方法" class="headerlink" title="bytes 和 bytearray的方法"></a>bytes 和 bytearray的方法</h3><p>十六进制和字节类型的相互转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bytes.fromhex()</span><br><span class="line">bytearray.fromhex()</span><br><span class="line">bytes.hex()</span><br><span class="line">bytesarray.hex()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; ba &#x3D; bytearray(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;hell&#39;</span><br><span class="line">&gt;&gt;&gt; ba</span><br><span class="line">bytearray(b&#39;hell&#39;)</span><br><span class="line">&gt;&gt;&gt; b.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&gt;&gt;&gt; ba.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">但是decode的好像没有特别好的办法除了使用binascii模块...  </span><br><span class="line"></span><br><span class="line">## binascii模块的使用  </span><br><span class="line">### 简介  </span><br><span class="line">binascii模块包含很多用来方法来转换二进制和各种ASCII编码的二进制表示法。通常不直接使用这些功能，而是使用封装模块，如uu, base64或binhex。binascii模块包含用C语言编写更快的低级功能，通常为高级模块所使用。</span><br><span class="line"></span><br><span class="line">- 相关模块  </span><br><span class="line">1. base64 模块</span><br><span class="line">2. binhex 模块</span><br><span class="line">3. uu 模块</span><br><span class="line">4. quopri 模块</span><br><span class="line">  </span><br><span class="line">### UU编码  </span><br><span class="line">相关函数binascii.a2b_uu(string)和binascii.b2a_uu(data)，更多资料点[这](http:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;uu.html)  </span><br><span class="line"></span><br><span class="line">### Binhex编码  </span><br><span class="line">相关函数有：binascii.rledecode_hqx(data) ，binascii.rlecode_hqx(data)，binascii.b2a_hqx(data) ，binascii.crc_hqx(data, crc)，更多资料点[这](http:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;uu.html)  </span><br><span class="line"></span><br><span class="line">### Base64编码  </span><br><span class="line">binascii.a2b_base64(string)：转换的base64数据块为二进制，并返回二进制数据。一次可以传递多行。和base64. b64decode对应。 binascii.b2a_base64(data)：转换二进制数据为一行base64编码的ASCII字符。返回字符串包含换行符。根据base64的标准data的长度最大为57。和base64. b64encode对应。，更多资料点[这](http:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;base64.html)</span><br><span class="line"></span><br><span class="line">### QP编码  </span><br><span class="line">Quoted-printable，或QP encoding，没有规范的中文译名，可译为“可打印字符引用编码”、“使用可打印字符的编码”。Quoted-printable是使用可打印的 ASCII字符 (如字母、数字与&quot;&#x3D;&quot;)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。</span><br><span class="line"></span><br><span class="line">QP使用&quot;&#x3D;&quot;开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.</span><br><span class="line"></span><br><span class="line">binascii.a2b_qp(string[, header])：转换引述打印数据块为二进制，并返回二进制数据。多行可以在同一时间被传递。如果可选参数头存在和真实，下划线将被解码为空格。</span><br><span class="line"></span><br><span class="line">实际上，QP码是是把’\x00’转换成’&#x3D;00’，也就是替换’\x’为’&#x3D;’。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>s =’\x00=’<br>s = ‘=\x00hello’<br>import binascii<br>encoded = binascii.b2a_qp(s)<br>encoded<br>‘=3D=00hello’<br>decoded = binascii.a2b_qp(encoded)<br>print decoded<br>=hello<br>print repr(decoded)<br>‘=\x00hello’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### CRC校验和</span><br><span class="line">binascii.crc32(data[, crc])：计算的data 的32位校验和CRC- 32时，crc为初始CRC 。crc32与ZIP文件的校验和一致。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>print binascii.crc32(“hello world”)<br>222957957<br>crc = binascii.crc32(“hello”)<br>crc = binascii.crc32(“ world”, crc) &amp; 0xffffffff<br>print ‘crc32 = 0x%08x’ % crc<br>crc32 = 0x0d4a1185<br>crc<br>222957957</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 二进制转换  </span><br><span class="line">binascii.b2a_hex(data)和binascii.hexlify(data)：返回二进制数据的十六进制表示。每个字节被转换成相应的 2位十六进制表示形式。因此，得到的字符串是是原数据长度的两倍。 binascii.a2b_hex(hexstr) 和 binascii.unhexlify(hexstr)：从十六进制字符串hexstr返回二进制数据。是b2a_hex的逆向操作。 hexstr必须包含偶数个十六进制数字（可以是大写或小写），否则报TypeError。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>s = ‘hello’<br>b = b2a_hex(s)<br>print b<br>68656c6c6f<br>a2b_hex(b)<br>‘hello’<br>b = hexlify(s)<br>print b<br>68656c6c6f<br>unhexlify(b)<br>‘hello’</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>
参考博客：https://www.jianshu.com/p/701960098b7a
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译</title>
    <url>/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>今天由一道入群题入手之后了解到了静态编译这个知识：  </p>
<ul>
<li><a id="more"></a>  

</li>
</ul>
<h3 id="1-静态编译："><a href="#1-静态编译：" class="headerlink" title="1.静态编译："></a>1.静态编译：</h3><p>编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，<br>使可执行文件在运行时不需要依赖于动态链接库.</p>
<h3 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2.动态编译:"></a>2.动态编译:</h3><p>动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一<br>方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>
<p>然后静态库的连接与使用看<a href="https://www.cnblogs.com/xiaotianxiedaima/p/9824643.html" target="_blank" rel="noopener">这</a></p>
<p>IDA使用sig文件的说明看<a href="https://www.jianshu.com/p/7a1441e4f355" target="_blank" rel="noopener">这</a><br>但是我的libc.a是在/usr/lib/x86_64-linux-gnu下的并不是这篇博客的libx32下的<br>然后这道题好像因为glibc版本的关系，还是有一些库函数没被解出来，所以我被迫爆破出了flag…  </p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Diary</title>
    <url>/2020/03/21/kittener&#39;s%20blog/</url>
    <content><![CDATA[<h1 id="这是一个记录学习生活的日记本"><a href="#这是一个记录学习生活的日记本" class="headerlink" title="这是一个记录学习生活的日记本"></a>这是一个记录学习生活的日记本</h1><h2 id="督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信"><a href="#督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信" class="headerlink" title="督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值(确信)"></a><del>督促自己学习</del>为了让以后的自己看看摸鱼的自己增加悔恨值(确信)</h2><ul>
<li><a id="more"></a>

</li>
</ul>
<h2 id="2020-3-21"><a href="#2020-3-21" class="headerlink" title="2020-3-21"></a>2020-3-21</h2><p>今天上午做了BJD的re题，tcl硬编码竟然没想到，卡了半小时，问了问师傅才发现，不过好想吐槽出题人出的什么题啊。。。好吧据说没有出题人，那就没事了<br>下午出门理发(摁，又是发际线高高扬起的我)，看到了漂亮的小改改<br>晚上继续学mysql，今晚就能学完了吧，明天开始动手写pki了,Mark一个学习MySQL非常好的<a href="http://c.biancheng.net/view/2361.html" target="_blank" rel="noopener">网站</a><br>又是菜的一天(茶)</p>
<h2 id="2020-3-22"><a href="#2020-3-22" class="headerlink" title="2020-3-22"></a>2020-3-22</h2><p>昨晚到底还是没有看完MySQL，今天还没看完，ddl快要到了我死了，还剩8天…<br>今天竟然写了一天的作业，概率论作业真的绝了<br>BJD最后更了一道 <del>re</del> pwn题，干死出题人，学pwn的事情也要提到日程上了…<br>又是fw的一天(茶)</p>
<h2 id="2020-3-23"><a href="#2020-3-23" class="headerlink" title="2020-3-23"></a>2020-3-23</h2><p>今天把MySQL收个尾(我到底拖了几天啊…)<br>上了一天课，Java老师的死亡提问真的无解2333，今天开始看程序员的自我修养这本书，计划两周看完吧(又开始立flag了-。-)<br>ddl往后推了15天，又能愉快<del>摸鱼</del>了呢<br>推特还把我的号封着，淦啊！！注意到苹果开始用rust语言替代c和c++了，唔是不是考虑学一手呢  </p>
<h2 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="2020-3-24"></a>2020-3-24</h2><p>自修这本书开了个头，概率论上课让我重回大一下的二重积分QAQ<br>从一道入群题学到了一个知识点，对底层的东西掌握还是不够啊<br>明天开始学rust 冲</p>
<h2 id="2020-3-25"><a href="#2020-3-25" class="headerlink" title="2020-3-25"></a>2020-3-25</h2><p>果然今天还是没学rust呢(不愧是我.jpg)<br>忙了一晚上协会的事情，和学长聊了聊天，明确了些自己的道路吧~加油</p>
<h2 id="2020-3-26"><a href="#2020-3-26" class="headerlink" title="2020-3-26"></a>2020-3-26</h2><p>今天晚上实现了数论里的模平方和同余式的求解<br>在看雪看了一篇<a href="https://bbs.pediy.com/thread-258265.htm" target="_blank" rel="noopener">ASPack的脱壳教程</a>，希望能有时间实现一下<br>程序员的自我修养没咋看，明天的比赛好好努力~  </p>
<h2 id="2020-3-27"><a href="#2020-3-27" class="headerlink" title="2020-3-27"></a>2020-3-27</h2><p>今天打了一天比赛，晚上修了修IDA，发现不能动调是因为中文路径的关系，我淦！好歹ylb拿了个一血最后躺了个第一，也算对最近做题的自己有个交代，希望继续努力<br>rust还没开始学…我哭，明天就开始！  </p>
<h2 id="2020-3-28"><a href="#2020-3-28" class="headerlink" title="2020-3-28"></a>2020-3-28</h2><p>被MRctf的题恶心坏了…我第一次见把逻辑藏在数组里然后用一大堆垃圾代码恶心人的题。是我太年轻<br>今天听nepnep的师傅讲区块链在ctf中的应用，挺有意思，mark一下<a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">练习平台</a>和<a href="https://imagin.vip" target="_blank" rel="noopener">师傅的blog</a></p>
<h2 id="2020-3-29"><a href="#2020-3-29" class="headerlink" title="2020-3-29"></a>2020-3-29</h2><p>写作业…概率论作业每次都是这么多…<br>调了一道MRctf的题，大体知道了花指令怎么patch和堆栈怎么平衡了  </p>
<h2 id="2020-3-30"><a href="#2020-3-30" class="headerlink" title="2020-3-30"></a>2020-3-30</h2><p>今天上午收到域名审批下来的短信，心血来潮再次修了修blog，终于可以实现挂载到服务器上了，下一步就是熟悉熟悉next主题的使用了<br>跟sakura师傅请教了一下，人生哲理增加了！(确信)<br>看符号执行的帖子也就图一乐，真要学明白还是得<a href="https://github.com/saswatanand/symexbib" target="_blank" rel="noopener">看论文</a>  </p>
<h2 id="2020-3-31"><a href="#2020-3-31" class="headerlink" title="2020-3-31"></a>2020-3-31</h2><p>终于赶上了操作系统的进度，我哭<br>今天好水…明天不能这样了(茶)</p>
<h2 id="2020-4-1-2020-4-2"><a href="#2020-4-1-2020-4-2" class="headerlink" title="2020-4-1~2020-4-2"></a>2020-4-1~2020-4-2</h2><p>看到了一篇关于<a href="https://www.52pojie.cn/thread-1117330-1-1.html" target="_blank" rel="noopener">IDApython的帖子</a>非常不错,讲的很全面了<br>一件快乐的事，我同学的腾讯云服务器被黑了哈哈哈哈哈哈。竟然被勒索0.05比特币，黑客就是赚钱啊(bushi)<br>这两天在整巅峰训练营的东西，感觉现在的程序员真的是被GitHub搞得太懒了，只要有项目在git上搜不到就会选择放弃而不是自己写代码<br>之前的我就是，因为git上的项目没有能和论文匹配的就开始心情烦躁…<br>Sakura师傅说过挖洞一定要有过硬的代码本领，希望引以为戒  </p>
<h2 id="2020-4-3"><a href="#2020-4-3" class="headerlink" title="2020-4-3"></a>2020-4-3</h2><p><a href="https://blog.csdn.net/u014044812/article/details/80866759" target="_blank" rel="noopener">rsa算法证明全过程</a>，看了一晚上的数论，越发觉得密码学研究不适合我2333<br>又是摸鱼的一天(茶)</p>
<h2 id="2020-4-4"><a href="#2020-4-4" class="headerlink" title="2020-4-4"></a>2020-4-4</h2><p>今天打了midnightctf，re题真的好难，知道了和顶尖人才的差距，这次的weight才30多，defcon是80…<br>皇家理工恐怖如斯…<br>要多找一些实际的项目做一做试一试，增加一些实战经验，加油  </p>
<h2 id="2020-4-5-2020-4-6"><a href="#2020-4-5-2020-4-6" class="headerlink" title="2020-4-5~2020-4-6"></a>2020-4-5~2020-4-6</h2><p>这两天都在摸鱼，在写项目，感觉这周能完工了，完工之后要抓紧学习了  </p>
<h2 id="2020-4-7-2020-4-8"><a href="#2020-4-7-2020-4-8" class="headerlink" title="2020-4-7~2020-4-8"></a>2020-4-7~2020-4-8</h2><p>项目完成70%了，这周完成了  </p>
<h2 id="2020-4-9"><a href="#2020-4-9" class="headerlink" title="2020-4-9"></a>2020-4-9</h2><p>今天打了个ctf，真的憋屈，明明写出来脚本就能拿到flag的题目，我却因为kotlin和java不大会做不出来…<br>逆向选手要学的东西好多啊QAQ  </p>
<h2 id="2020-4-10-2020-4-12"><a href="#2020-4-10-2020-4-12" class="headerlink" title="2020-4-10~2020-4-12"></a>2020-4-10~2020-4-12</h2><p>解决了最后一个bug，项目的第一阶段完成了  </p>
<h2 id="2020-4-13"><a href="#2020-4-13" class="headerlink" title="2020-4-13"></a>2020-4-13</h2><p>炉石传说终于上了一次传说了，我青结  </p>
<h2 id="2020-4-14-2020-4-15"><a href="#2020-4-14-2020-4-15" class="headerlink" title="2020-4-14~2020-4-15"></a>2020-4-14~2020-4-15</h2><p>果然程序就是不经调试，随随便便就出了很多问题，这两天在疯狂的修bug  </p>
<h2 id="2020-4-16"><a href="#2020-4-16" class="headerlink" title="2020-4-16"></a>2020-4-16</h2><p>从昨天开始与小伙伴夜跑，最近坐的时间太久了导致身体这痛那痛的，身体还是革命的本钱啊<br>拜读了sakura的博客，觉得自己效率太低了，要提高效率  </p>
]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/19/hello-world/</url>
    <content><![CDATA[<p>这里是我的blog，记录自己的学习足迹，日常吐槽的地方，欢迎大家一起交流学习！</p>
]]></content>
  </entry>
</search>
