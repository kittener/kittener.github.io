<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android逆向学习</title>
    <url>/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是TG:HACK2020的一道比赛题目<br>题目给的hint很误导人…反正我没看出来  </p>
<a id="more"></a>
<blockquote>
<blockquote>
<blockquote>
<p>Hint<br>Random title?  </p>
</blockquote>
</blockquote>
</blockquote>
<p>这是题目描述：Someone found this very old game lying around. Apparently there is an extremely funny joke in there somewhere.</p>
<p>之前没怎么做过安卓题目，所以这次真是学到了很多<br>题目的名字叫Bad intentions<br>上Google搜索之后发现是一堆歌曲，好吧这肯定跟题目没啥关系<br>当搜索apk intentions的时候就出现了有用的信息：<br><img src="1.jpg" alt="google搜索结果">  </p>
<p>所谓的apk intentions就是指这个程序能不能被外部访问，或者进行数据交换  </p>
<blockquote>
<blockquote>
<blockquote>
<p>Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动 作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的 交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>然后就是如何查看这个apk包中有没有调用intent这个类了<br><code>aapt dump xmltree gaiainvaders.apk AndroidManifest.xml</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>关于AndroidManifest.xml这个文件的介绍<a href="https://www.jianshu.com/p/3b5b89d4e154" target="_blank" rel="noopener">点这</a></p>
<p>就会输出如下信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E: activity (line&#x3D;19)  </span><br><span class="line">    A:android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;20)</span><br><span class="line">          E: action (line&#x3D;21)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;23)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br><span class="line">    E: activity (line&#x3D;26)</span><br><span class="line">        A: android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.JokeActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.JokeActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;27)</span><br><span class="line">          E: action (line&#x3D;28)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;30)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看出了是调用了intent类的，而且发现一个JokeActivity的类。联想到题目描述觉得应该是这个文件了，用jeb打开看一下(我当时做这道题的时候没想到这，被其他地方误导了)  </p>
<p><img src="2.jpg" alt=""></p>
<p>这是JokeActivity方法，我当时被这个给迷惑了…  </p>
<p><img src="3.jpg" alt=""></p>
<p>到这可以看出来是个AES加密，写出脚本就可以跑出来了(大概，我没试)<br>还有一种更简单的方法<br>学习一下<br>上述提到了intent这个包，它是对于Android程序安全性相关性很大的包，有了它之后我们就可以对这个APK进行调试<br><code>adb install gaiainvaders.apk</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>adb全称Android Debug Bridge，是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。说直白一点就是通过adb可以实现<strong>用命令行控制设备。</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>使用adb有两种方法  </p>
<ol>
<li>需要安装安卓手机模拟器，这里我选择了网易的mumu模拟器，安装之后在<strong>platform-tools</strong>下运行adb程序<br><code>adb connect 127.0.0.1:7555</code><br>每个模拟器默认的端口不一样，具体的<a href="https://www.cnblogs.com/HakunaMatata-/p/10609307.html" target="_blank" rel="noopener">看这</a><br>等它显示success之后就表示连接上了，之后执行安装命令就好了  </li>
<li>用安卓手机之间连接，手机进入开发者模式，cmd中输入<br><code>adb devices</code><br>之后就安装就可以了  </li>
</ol>
<p>然后我们只需要运行JokeActivity这个类就能得到flag了，这里用<br><code>adb shell am start -n &quot;no.tghack.gaiainvaders/.JokeActivity&quot;</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.</p>
</blockquote>
</blockquote>
</blockquote>
<p>启动的方法为</p>
<p><code>adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}</code>  </p>
<p>然后就得到了flag<br><img src="4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python2的encode(&#39;hex&#39;)在python3上的解决</title>
    <url>/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  </p>
<a id="more"></a>  

<p>python2对于字符串转换成hex编码的时候使用的是str本身具有的方法，即str.encode(‘hex’)<br>但是这个方法在python3中取消了，解决方案如下：<br>首先  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; bytes(str,encoding &#x3D; &#39;utf-8&#39;)  </span><br><span class="line">str1.hex()</span><br></pre></td></tr></table></figure>
<p>即可  </p>
<p>顺便扩充一下知识：  </p>
<h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><h3 id="1-使用bytes函数创建bytes"><a href="#1-使用bytes函数创建bytes" class="headerlink" title="1.使用bytes函数创建bytes"></a>1.使用bytes函数创建bytes</h3><ul>
<li>bytes() 创建一个空的bytes  </li>
<li>bytes(int) 创建一个int位的全位0的bytes  </li>
<li>bytes(iterabl_of_ints) 可迭代数字组成的bytes(比如range)</li>
<li>bytes(string,encoding[,errors]) 等价于string.encode()</li>
<li>bytes(bytes of buffer) 创建一个bytes的copy  </li>
</ul>
<h3 id="2-直接定义"><a href="#2-直接定义" class="headerlink" title="2.直接定义"></a>2.直接定义</h3><p>比如：</p>
<p>​ b = b’abc’</p>
<p>​ b = b’\x61’</p>
<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><ul>
<li>string.encode()</li>
<li>int.tobytes()</li>
<li>bytes.from</li>
<li>bytes函数定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes()</span><br><span class="line">b&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(3)</span><br><span class="line">b&#39;\x00\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(range(3))</span><br><span class="line">b&#39;\x00\x01\x02&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;中国&#39;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(b)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br></pre></td></tr></table></figure>


<p>直接创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; b&#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<p>类型转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; 97</span><br><span class="line">&gt;&gt;&gt; n.to_bytes(1,byteorder&#x3D;&#39;big&#39;)</span><br><span class="line">b&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;中国&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.encode(encoding &#x3D; &#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;61&#39;)</span><br><span class="line">b&#39;a&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytes的显示方式"><a href="#bytes的显示方式" class="headerlink" title="bytes的显示方式"></a>bytes的显示方式</h2><blockquote>
<blockquote>
<blockquote>
<p>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</p>
</blockquote>
</blockquote>
</blockquote>
<p>只有ASCII中的字符串是可以直接在bytes类型中显示出来的，所有大于127的数值用转义字符表达。</p>
<p>比如，内存中的字节对象用十六进制表示为61，在python中显示的方式不是b’\x61’ 而是b’a’；而b’\xe4’显示方式就是b’\xe4’；注意：仅仅是显示方式而已</p>
<p>另外，并不是所有的小于127的都可以被友好的显示出来，有些对象本身不可显示，就显示其十六进制表示。比如</p>
<p>b’\x00’</p>
<p>bytes的一般方法<br>bytes类似于string；在方法上，除了自己特有的方法外，跟str也类似。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.find(b&#39;\x63&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.replace(b&#39;\61&#39;,b&#39;A&#39;)</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><p>bytearray是可变的bytes数据类型，可以通过bytearray创建和定义</p>
<h3 id="一：bytearray-定义"><a href="#一：bytearray-定义" class="headerlink" title="一：bytearray()定义"></a>一：bytearray()定义</h3><ul>
<li><p>bytearray() 创建一个空的bytearray</p>
</li>
<li><p>bytearray(int) 创建一个int位的全位0的bytearray</p>
</li>
<li><p>bytearray(iterabl_of_ints) 可迭代数字组成的bytearray(比如range)</p>
</li>
<li><p>bytearray(string,encoding[,errors]) 将一个字符串编码为bytearray</p>
</li>
<li><p>bytearray(bytes of buffer) 创建一个bytearray</p>
<h3 id="二-bytearray的方法定义"><a href="#二-bytearray的方法定义" class="headerlink" title="二: bytearray的方法定义"></a>二: bytearray的方法定义</h3></li>
<li><p>bytearray.fromhex()  </p>
<h3 id="bytearray的一般方法"><a href="#bytearray的一般方法" class="headerlink" title="bytearray的一般方法"></a>bytearray的一般方法</h3></li>
</ul>
<p>bytearray具备bytes的操作方法，像字符串一样操作；</p>
<p>另外bytearray还具备像list一样的操作方法，比如pop，append等</p>
<h3 id="bytes-和-bytearray的方法"><a href="#bytes-和-bytearray的方法" class="headerlink" title="bytes 和 bytearray的方法"></a>bytes 和 bytearray的方法</h3><p>十六进制和字节类型的相互转换  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bytes.fromhex()</span><br><span class="line">bytearray.fromhex()</span><br><span class="line">bytes.hex()</span><br><span class="line">bytesarray.hex()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; ba &#x3D; bytearray(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;hell&#39;</span><br><span class="line">&gt;&gt;&gt; ba</span><br><span class="line">bytearray(b&#39;hell&#39;)</span><br><span class="line">&gt;&gt;&gt; b.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&gt;&gt;&gt; ba.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br></pre></td></tr></table></figure>

<p>但是decode的好像没有特别好的办法除了使用binascii模块…  </p>
<h2 id="binascii模块的使用"><a href="#binascii模块的使用" class="headerlink" title="binascii模块的使用"></a>binascii模块的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>binascii模块包含很多用来方法来转换二进制和各种ASCII编码的二进制表示法。通常不直接使用这些功能，而是使用封装模块，如uu, base64或binhex。binascii模块包含用C语言编写更快的低级功能，通常为高级模块所使用。  </p>
<ul>
<li>相关模块  </li>
</ul>
<ol>
<li>base64 模块</li>
<li>binhex 模块</li>
<li>uu 模块</li>
<li>quopri 模块  </li>
</ol>
<h3 id="UU编码"><a href="#UU编码" class="headerlink" title="UU编码"></a>UU编码</h3><p>相关函数binascii.a2b_uu(string)和binascii.b2a_uu(data)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="Binhex编码"><a href="#Binhex编码" class="headerlink" title="Binhex编码"></a>Binhex编码</h3><p>相关函数有：binascii.rledecode_hqx(data) ，binascii.rlecode_hqx(data)，binascii.b2a_hqx(data) ，binascii.crc_hqx(data, crc)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>binascii.a2b_base64(string)：转换的base64数据块为二进制，并返回二进制数据。一次可以传递多行。和base64. b64decode对应。 binascii.b2a_base64(data)：转换二进制数据为一行base64编码的ASCII字符。返回字符串包含换行符。根据base64的标准data的长度最大为57。和base64. b64encode对应。，更多资料点<a href="http://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="QP编码"><a href="#QP编码" class="headerlink" title="QP编码"></a>QP编码</h3><p>Quoted-printable，或QP encoding，没有规范的中文译名，可译为“可打印字符引用编码”、“使用可打印字符的编码”。Quoted-printable是使用可打印的 ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。  </p>
<p>QP使用”=”开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.  </p>
<p>binascii.a2b_qp(string[, header])：转换引述打印数据块为二进制，并返回二进制数据。多行可以在同一时间被传递。如果可选参数头存在和真实，下划线将被解码为空格。  </p>
<p>实际上，QP码是是把’\x00’转换成’=00’，也就是替换’\x’为’=’。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D;&#39;\x00&#x3D;&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;&#x3D;\x00hello&#39;</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; encoded &#x3D; binascii.b2a_qp(s)</span><br><span class="line">&gt;&gt;&gt; encoded</span><br><span class="line">&#39;&#x3D;3D&#x3D;00hello&#39;</span><br><span class="line">&gt;&gt;&gt; decoded &#x3D; binascii.a2b_qp(encoded)</span><br><span class="line">&gt;&gt;&gt; print decoded</span><br><span class="line">&#x3D;hello</span><br><span class="line">&gt;&gt;&gt; print repr(decoded)</span><br><span class="line">&#39;&#x3D;\x00hello&#39;</span><br></pre></td></tr></table></figure>

<h3 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h3><p>binascii.crc32(data[, crc])：计算的data 的32位校验和CRC- 32时，crc为初始CRC 。crc32与ZIP文件的校验和一致。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print binascii.crc32(&quot;hello world&quot;)</span><br><span class="line">222957957</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot;hello&quot;)</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot; world&quot;, crc) &amp; 0xffffffff</span><br><span class="line">&gt;&gt;&gt; print &#39;crc32 &#x3D; 0x%08x&#39; % crc</span><br><span class="line">crc32 &#x3D; 0x0d4a1185</span><br><span class="line">&gt;&gt;&gt; crc</span><br><span class="line">222957957</span><br></pre></td></tr></table></figure>

<h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><p>binascii.b2a_hex(data)和binascii.hexlify(data)：返回二进制数据的十六进制表示。每个字节被转换成相应的 2位十六进制表示形式。因此，得到的字符串是是原数据长度的两倍。 binascii.a2b_hex(hexstr) 和 binascii.unhexlify(hexstr)：从十六进制字符串hexstr返回二进制数据。是b2a_hex的逆向操作。 hexstr必须包含偶数个十六进制数字（可以是大写或小写），否则报TypeError。  </p>
<pre><code>&gt;&gt;&gt; s = &apos;hello&apos;
&gt;&gt;&gt; b = b2a_hex(s)
&gt;&gt;&gt; print b
68656c6c6f
&gt;&gt;&gt; a2b_hex(b)
&apos;hello&apos;
&gt;&gt;&gt; b = hexlify(s)
&gt;&gt;&gt; print b
68656c6c6f
&gt;&gt;&gt; unhexlify(b)
&apos;hello&apos;</code></pre><p>参考博客：<a href="https://www.jianshu.com/p/701960098b7a" target="_blank" rel="noopener">https://www.jianshu.com/p/701960098b7a</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译</title>
    <url>/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>今天由一道入群题入手之后了解到了静态编译这个知识：  </p>
<ul>
<li><a id="more"></a>  

</li>
</ul>
<h3 id="1-静态编译："><a href="#1-静态编译：" class="headerlink" title="1.静态编译："></a>1.静态编译：</h3><p>编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，<br>使可执行文件在运行时不需要依赖于动态链接库.</p>
<h3 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2.动态编译:"></a>2.动态编译:</h3><p>动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一<br>方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>
<p>然后静态库的连接与使用看<a href="https://www.cnblogs.com/xiaotianxiedaima/p/9824643.html" target="_blank" rel="noopener">这</a></p>
<p>IDA使用sig文件的说明看<a href="https://www.jianshu.com/p/7a1441e4f355" target="_blank" rel="noopener">这</a><br>但是我的libc.a是在/usr/lib/x86_64-linux-gnu下的并不是这篇博客的libx32下的<br>然后这道题好像因为glibc版本的关系，还是有一些库函数没被解出来，所以我被迫爆破出了flag…  </p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Diary</title>
    <url>/2020/03/21/kittener&#39;s%20blog/</url>
    <content><![CDATA[<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="{{message}}" />
    <label for="pass">{{message}}</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">{{decryptionError}}</div>
<div id="noContentError" style="display: none;">{{noContentError}}</div>
<div id="encrypt-blog" style="display:none">
{{content}}
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/19/hello-world/</url>
    <content><![CDATA[<p>这里是我的blog，记录自己的学习足迹，日常吐槽的地方，欢迎大家一起交流学习！</p>
]]></content>
  </entry>
</search>
