<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++反汇编与逆向分析技术(三)</title>
    <url>/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/</url>
    <content><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(三)  </p>
<a id="more"></a>  

<h1 id="流程控制语句的识别"><a href="#流程控制语句的识别" class="headerlink" title="流程控制语句的识别"></a>流程控制语句的识别</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句只能判断两种情况:“0”为假值，“非0”为真值。如果为真值，则进人语句块内执行语句;如果为假值，则跳过if语句块，继续运行程序的其他语句。要注意的是，if语句转换的条件跳转指令与if语句的判断结果是相反的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：if语句结构组成</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">	printf(&quot;%d \r\n&quot;, argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;如果argc &#x3D; 0的情况，为真</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F;使用cmp指令，将ebp+8地址的4字节和0相减</span><br><span class="line">&#x2F;&#x2F;结果argc不改变，淡水会改变CF,ZF,OF,AF和PF</span><br><span class="line">00401028	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;JNE看ZF，如果等于0跳转，表示现在的argc不等于0</span><br><span class="line">&#x2F;&#x2F;跳转到0x40103F</span><br><span class="line">&#x2F;&#x2F;这个地址为if的结束地址，之后跳转出if</span><br><span class="line">0040102C	jne	main+2F(0040103f)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;函数返回</span><br><span class="line">return 0;</span><br><span class="line">0040103F	xor	eax,eax</span><br></pre></td></tr></table></figure>

<p>出现这种情况是因为汇编语言的条件跳转是满足某条件则跳转，绕过某些代码块，这一点是与C语言<strong>相反</strong>的，而C语言编译器不将else语句块提到if语句块前面是因为C语言是根据<strong>代码行的位置来决定编译后的二进制代码的地址高低的</strong>，也就是说，低行数对应低地址，高行数对应高地址</p>
<p>根据这一特性，如果将if语句中的比较条件 “argc==0” 修改为 “if(argc &gt; 0)”，则其对应的汇编语言所使用的条件跳转指令会是“小于等于0”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if语句大于0比较</span><br><span class="line">if( argc &gt; 0 )&#123;</span><br><span class="line">	printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码</span><br><span class="line">&#x2F;&#x2F;C++源码对比，如果参数argc大于0，结果为真，进入执行语句</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">&#x2F;&#x2F;使用cmp，将ebp+8地址的4字节数据和0进行减法</span><br><span class="line">0040103F	cmp dword ptr [ebp+8],0</span><br><span class="line">00401043	jle	MyIf + 42h (00401052)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">00401052	pop edi</span><br></pre></td></tr></table></figure>

<p>在分析过程中，表达式短路(上一篇blog的内容)和if语句这两种分支结构的实现结构都是一样的，蛮难区分的</p>
<p><strong>总结：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">；先执行各类影响标志位的指令</span><br><span class="line">；其后是各种条件跳转指令</span><br><span class="line">jxx		xxxx</span><br></pre></td></tr></table></figure>

<p>如果遇上以上指令序列，大概率是一个if语句组成的单分支结构</p>
<h2 id="if···else···语句"><a href="#if···else···语句" class="headerlink" title="if···else···语句"></a>if···else···语句</h2><p>if和if···else···的流程对比</p>
<p><img src="P1.jpg" alt="结构对比"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if  else</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	printf(&quot;argc &#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	printf(&quot;argc !&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">004010B8	cmp	dword ptr [ebp+8],0 &#x2F;&#x2F;相减</span><br><span class="line">004010BC	jne	IfElse+2Dh	(004010cd)&#123;</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">&#125;</span><br><span class="line">004010CB	jmp	IfElse+3Ah (004010da)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;进入else</span><br><span class="line">004010CD	push offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">004010D2	call printf (00401150)</span><br><span class="line">004010D7	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结束</span><br><span class="line">004010DA	pop edi</span><br></pre></td></tr></table></figure>

<p>将上述代码稍作改动，改为符合条件表达式转换方式1的形式，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，if...else..模拟条件表达式转换方式</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	argc &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	argc &#x3D; 6;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc); &#x2F;&#x2F;防止argc被优化处理</span><br><span class="line">&#x2F;&#x2F;对应汇编，debug版，无优化</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">00401098	cmp	dword ptr [ebp+8],0</span><br><span class="line">0040109c	jne	main+27h(004010a7)</span><br><span class="line">argc &#x3D; 5;</span><br><span class="line">0040109E	mov	dword ptr [ebp+8],5</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">004010A5	jmp	main+2Eh(004010ae)</span><br><span class="line">argc &#x3D; 6;</span><br><span class="line">004010A7	mov dword ptr [ebp+8],6</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#x2F;&#x2F;略</span><br><span class="line">004010AE	...</span><br></pre></td></tr></table></figure>

<p>还是挺简单的，总结一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结结构：</span><br><span class="line">&#x2F;&#x2F;产生修改标志位的指令</span><br><span class="line">jxx else_begin</span><br><span class="line">if begin:</span><br><span class="line">&#x2F;&#x2F;执行if中的内容</span><br><span class="line">if end:</span><br><span class="line">jmp else end</span><br><span class="line">else begin:</span><br><span class="line">&#x2F;&#x2F;执行else的内容</span><br><span class="line">else end</span><br></pre></td></tr></table></figure>

<p>这两个跳转指令就是辨识的关键，不过和条件表达式差不多，所以反推的时候看个人习惯</p>
<p>上面那份代码是debug版，下面给个O2优化的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取到的参数数据放在edx中</span><br><span class="line">mov	edx,[esp+argc_0]</span><br><span class="line">&#x2F;&#x2F;将eax清0</span><br><span class="line">xor	eax,eax</span><br><span class="line">&#x2F;&#x2F;对edx和edx进行想与的操作，结果不影响edx</span><br><span class="line">test edx,edx</span><br><span class="line">&#x2F;&#x2F;检查ZF的标记位，edx不等于0的时候，我们的al &#x3D; 1，等于0 我们的al &#x3D; 0</span><br><span class="line">setnz al</span><br><span class="line">add eax,5 &#x2F;&#x2F;这里可能是5&#x2F;6，看al了，我们不等于0，那么就是6，我们等于0，那么就是5</span><br><span class="line">push eax</span><br><span class="line">push offset Format ; &quot;%d \r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add	esp,8</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>可以看到优化了很多，做了一个流水线优化，还是蛮难还原回去的</p>
<h2 id="用if构成的多分支流程"><a href="#用if构成的多分支流程" class="headerlink" title="用if构成的多分支流程"></a>用if构成的多分支流程</h2><p>多分支结构就是if···else if···else if···else···这种结构，直接看代码吧，这是debug版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，多分支结构</span><br><span class="line">void IfElseIf(int argc)&#123;</span><br><span class="line">if (argc &gt; 0)&#123;</span><br><span class="line">	printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	printf(&quot;argc &lt;&#x3D; 0&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">00401108	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;相减 argc-0 之后使用小于等于跳转的条件,jle</span><br><span class="line">0040110C	jle	IfElseIf+2Dh(0040111d) &#x2F;&#x2F;到else位置，目测那边是一个cmp 一个jne&#123;</span><br><span class="line">printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">0040110E	push offset string &quot;argc &gt; 0&quot;(00420f9c)</span><br><span class="line">00401113	call printf(00401150)</span><br><span class="line">00401118	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">else if ( argc &#x3D;&#x3D; 0 )</span><br><span class="line">0040111B	jmp	IfElseIf+4Fh(0040113f)</span><br><span class="line">&#x2F;&#x2F;if比较转换，和我上面目测的差不多一个cmp，一个jne</span><br><span class="line">0040111D	cmp	dword ptr [ebp+8],0</span><br><span class="line">00401121	jne	IfElseIf+42h(00401132) &#x2F;&#x2F;到下一个else的位置，直接就是执行了</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">00401123	push offset string &quot;argc &#x3D;&#x3D; 0&quot;(0042003c)</span><br><span class="line">00401128	call printf(00401150)</span><br><span class="line">0040112D	add esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳转到多分支结构结束地址</span><br><span class="line">00401130	jmp	IfElseIf+4Fh(0040113f)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &lt; &#x3D; 0&quot;);&#x2F;&#x2F;上面都不满足，无条件执行</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">00401132	push offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">00401137	call printf (00401150)</span><br><span class="line">0040113C	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">0040113F	pop	edi</span><br></pre></td></tr></table></figure>

<p>debug版的代码看着还是舒适，就是一个很简单的cmp+跳转指令，来个总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else if begin</span><br><span class="line">if begin:</span><br><span class="line">...</span><br><span class="line">if end:</span><br><span class="line">jmp end</span><br><span class="line">else if begin:</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else begin</span><br><span class="line">...</span><br><span class="line">else if end:</span><br><span class="line">jmp end</span><br><span class="line">else begin</span><br><span class="line">...</span><br><span class="line">end:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在编译期间，永远不可抵达的分支将被优化掉而不参与编译处理，在写代码的时候，可以在每个else if的代码块里加个return，这样就可以减少分支比较。</p>
<p>看一下开启O2优化的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401000 sub_401000	proc near ; CODE XREF: _main+5p</span><br><span class="line">&#x2F;&#x2F;arg_0为函数参数</span><br><span class="line">.text:00401000 arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取出参数数据，放入eax，进行第一次if比较</span><br><span class="line">.text:00401000	mov eax,[esp+arg_0]</span><br><span class="line">.text:00401004	test eax,eax</span><br><span class="line">&#x2F;&#x2F;比较后进行转移，目测jle</span><br><span class="line">.text:00401006	jle	short loc_401016</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">.text:00401008	push offset Format ; &quot;argc &gt; 0&quot;</span><br><span class="line">.text:0040100D	call _printf</span><br><span class="line">.text:00401012	add esp,4</span><br><span class="line">&#x2F;&#x2F;使用retn指令返回，结束函数调用</span><br><span class="line">.text:00401015	retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代表此处代码被符号sub_401000地址加6的地方引用</span><br><span class="line">.text:00401016 loc_401006:	 ;CODE XREF: sub_401000+6j</span><br><span class="line">&#x2F;&#x2F;这里目测因为有test的问题 直接jne就可以</span><br><span class="line">.text:00401018	push offset aArgc0_0 ; &quot;argc &#x3D;&#x3D; 0&quot;</span><br><span class="line">.text:0040101D	call _printf</span><br><span class="line">.text:00401022	add esp,4</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">.text:00401025	retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前两次失败没返回直接执行此处</span><br><span class="line">.text:00401026	loc_401026: ; CODE XREF: sub_401000:loc_401016j</span><br><span class="line">.text:00401026	push offset aArgc0_1; &quot;argc &lt;&#x3D; 0&quot;</span><br><span class="line">.text:0040102B	call _printf</span><br><span class="line">.text:00401030	pop ecx</span><br><span class="line">.text:00401031	retn</span><br><span class="line">.text:00401031	sub_401000	endp</span><br></pre></td></tr></table></figure>

<p>有内味了，看来现在的出题人都喜欢开O2优化</p>
<h2 id="switch的真相"><a href="#switch的真相" class="headerlink" title="switch的真相"></a>switch的真相</h2><p>看一下3条case语句的switch跳转：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (nIndex&#125; &#123;				&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF00	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">;取出变量nIndex的值并放到ecx中，再将ecx放入临时变量ebp - 8中</span><br><span class="line">0040DF03	mov		dword ptr [ebp-8] , ecx</span><br><span class="line">;将临时变量和1进行比较</span><br><span class="line">0040DF06	cmp		dword ptr [ebp-8] ,1</span><br><span class="line">;条件跳转比较，等于1则跳转到地址0x0040DF1A处</span><br><span class="line">0040DF0A 	je		SwitchIf+4Ah (0040df1a)</span><br><span class="line">;将临时变量和3比较</span><br><span class="line">0040DFOC	cmp		dword ptr [ebp-8] ,3</span><br><span class="line">;条件跳转比较，等于3则跳转到地址0x0040DF29处</span><br><span class="line">0040DF10	je		SwitchIf+59h (0040df29)</span><br><span class="line">;将临时变量和100比较</span><br><span class="line">0040DF12	cmp		dword ptr [ebp-8] , 64h</span><br><span class="line">;条件跳转比较，等于100则跳转到地址0x0040DF38处</span><br><span class="line">0040DF16	je		SwitchIf+68h (0040df38)</span><br><span class="line">0040DF18	jmp		SwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 1:    	&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;  &#x2F;&#x2F;源码对比</span><br><span class="line">0040DF1A	push	offset string &quot;nIndex &#x3D;&#x3D; 1&quot; (00421024)</span><br><span class="line">0040DF1F	call	printf (004014b0)</span><br><span class="line">0040DF24	add		esp,4</span><br><span class="line">break;		&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF27	jmp		SwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 3:		&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;		&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF29	push	offset string &quot;nIndex &#x3D;&#x3D; 3&quot; (004210d8)</span><br><span class="line">0040DF2E	call	printf (004014b0)</span><br><span class="line">0040DF33	add		esp,4</span><br><span class="line"></span><br><span class="line">case 100:		&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 100&quot;); 		&#x2F;&#x2F; 源码对比</span><br><span class="line">0040DF38	push	offset string &quot;nIndex &#x3D;&#x3D; 100&quot; (0042004c)</span><br><span class="line">0040DF3D	call	printf (004014b0)</span><br><span class="line">0040DF42	add		esp,4</span><br><span class="line">break;</span><br><span class="line">&#125;&#125;				&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF45	pop		edi</span><br></pre></td></tr></table></figure>

<p>可以看到与if···else差距还是挺大的，if···else是跳转后跟着语句块，而switch结构则将所有的条件跳转都放在了一起。这样就实现了C语法的要求，在case语句块中没有break语句时，可以顺续执行后续case语句块</p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov		reg, mem		;取出switch中考察的变量</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx			; 跳转到对应case语句块的首地址</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx</span><br><span class="line">jmp		END				; 跳转到switch的结尾地址处</span><br><span class="line">......					; case语句块的首地址</span><br><span class="line">jmp		END				; case语句块结束，有break则产生这个jmp</span><br><span class="line">&#x2F;&#x2F;下同</span><br><span class="line">END:					; switch结尾</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这是switch分支数小于4的情况下，VC++ 6.0采用的策略，当分支数大于3时，并且case的判定值存在明显线性关系组合时，switch的优化特性便可以凸显出来，如代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++示例代码</span><br><span class="line">int nIndex &#x3D; 0;</span><br><span class="line">scanf (&quot;%d&quot;, &amp; nIndex) ;</span><br><span class="line">switch (nIndex) &#123;</span><br><span class="line">	case 1: printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;break;</span><br><span class="line">	case 2: printf (&quot;nIndex &#x3D;&#x3D; 2&quot;) ;break;</span><br><span class="line">	case 3: printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;break;</span><br><span class="line">	case 5: printf (&quot;nIndex &#x3D;&#x3D; 5&quot;) ;break;</span><br><span class="line">	case 6: printf (&quot;nIndex &#x3D;&#x3D; 6&quot;) ;break;</span><br><span class="line">	case 7: printf (&quot;nIndex &#x3D;&#x3D; 7&quot;) ;break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;debug版</span><br><span class="line">switch (nIndex)&#123;		&#x2F;&#x2F;源码对比</span><br><span class="line">;将变量nIndex内容放入ecx中</span><br><span class="line">00401110	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">;取出ecx的值并放入临时变量ebp-8中</span><br><span class="line">00401113	mov		dword ptr [ebp-8] , ecx </span><br><span class="line">;取临时变量的值放入edx中，这几句代码的功能看似没有区别</span><br><span class="line">;只有在Debug版下才会出现</span><br><span class="line">00401116	mov		edx, dword ptr [ebp-8]</span><br><span class="line">;对edx减1,进行下标平衡</span><br><span class="line">00401119	sub		edx, 1</span><br><span class="line">;将减1后的临时变量放回</span><br><span class="line">0040111C 	mov		dword ptr [ebp-8] , edx</span><br><span class="line">;判断临时变量是否大于6</span><br><span class="line">0040111F	cmp		dword ptr [ebp-8] ,6</span><br><span class="line">;大于6跳转到0x00401187处</span><br><span class="line">00401123 	ja		$L556+0Dh (00401187)</span><br><span class="line">;取出临时变量的值放到eax中</span><br><span class="line">00401125	mov		eax, dword ptr [ebp-8] </span><br><span class="line">;以eax为下标，0x00401198为基址进行寻址，跳转到该地址处</span><br><span class="line">;注意:地址0x00401198就是case地址数组</span><br><span class="line">00401128	jmp		dword ptr [eax*4+401198h]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将case语句块的首地址保存在一个数组中，并且数组下标以0为起始，在进入switch后会先进行一次比较，检查输入的值是否大于case的最大值。case地址数组如下：</p>
<p><img src="P2.jpg" alt="有序线性case地址表"></p>
<p>如果每两个case值之间的差值小于等于6，并且case语句数大于等于4,编译器中就会形成这种线性结构。在编写代码的过程中无需有序排列case值，编译器会在编译过程中对case线性地址表进行排序，如case的顺序为3、2、1、 4、5，在case线性地址表中，会将它们的语句块的首地址进行排序，将case 1语句块的首地址放在case线性地址表的第0项上,case 2语句块首地址放在表中第1项，以此类推，将首地址变为一个有序的表格进行存放，如图</p>
<p><img src="P3.jpg" alt="模拟图"></p>
<p>给出release版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;取出switch语句的参数值并放入ecx中</span><br><span class="line">00401018	mov		ecx, dword ptr [esp+8]</span><br><span class="line">0040101C	add		esp, 8		;平衡scanf函数的参数</span><br><span class="line"></span><br><span class="line">;将ecx减1后放入eax中，因为最小的case 1存放在case地址表中下标为0处，需要调整对齐到0下标，便于直接查表</span><br><span class="line">0040101F	lea		eax, [ecx-1]</span><br><span class="line">;与6进行比较，有了这两步操作可以初步假设这里的代码是一个switch结构</span><br><span class="line">;无符号比较，大于6时跳转到地址0x00401086处</span><br><span class="line">00401022	cmp		eax,6</span><br><span class="line">00401025	ja		00401086</span><br><span class="line"></span><br><span class="line">;下面的指令体现了switch的第二个特性;查表(case地址表)</span><br><span class="line">;可以确认这是一个switch结构</span><br><span class="line">;上一步的跳转地址00401086就是switch结尾或者是default语句块的首地址</span><br><span class="line">;下面指令中的地址0x00401088便是case线性地址表的首地址</span><br><span class="line">00401027	jmp		dword ptr [eax* 4+401088h]</span><br><span class="line">;地址0x0040706C为字符串&quot;nIndex &#x3D;&#x3D; 1&quot;的首地址</span><br><span class="line">;此处为第一个case语句块的地址</span><br><span class="line">0040102E	push	40706Ch</span><br><span class="line">&#x2F;&#x2F;调用printf函数</span><br><span class="line">00401033	call	004012F0</span><br><span class="line">;平衡printf函数破坏的栈空间</span><br><span class="line">00401038	add		esp,4</span><br><span class="line">;还原esp</span><br><span class="line">0040103B	pop		ecx</span><br><span class="line">;返回，在Release版中，煸译器发现switch后什么也没做就直接返回，所以</span><br><span class="line">;将每句break优化为了return</span><br><span class="line">;到此处，第一-个case语句块结束，顺序向下为第二个case语句块</span><br><span class="line">0040103C	ret</span><br><span class="line"></span><br><span class="line">;第二个case语句块</span><br><span class="line">;地址0x00407060为字符串&quot;nIndex m&#x3D; 2&quot;的首地址</span><br><span class="line">0040103D	push	407060h</span><br><span class="line">00401042	call	004012F0</span><br><span class="line">00401047	add		esp,4</span><br><span class="line">0040104A	pop		ecx</span><br><span class="line">0040104B	ret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面代码类似，不写了</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov		reg,mem			;取变量</span><br><span class="line">;对变量进行运算，对齐case地址表的0下标，非必要</span><br><span class="line">;上例中的eax也可用其他寄存器替换，这里也可以是其他类型的运算</span><br><span class="line">lea		eax,[reg+xxxx]</span><br><span class="line"></span><br><span class="line">;影响标志位的指令，迸行范围检查</span><br><span class="line">jxx		DEFAULT_ADDR</span><br><span class="line">jmp		dword ptr [eax*4+xxxx]; 地址xxxx为case地址表的首地址</span><br></pre></td></tr></table></figure>

<p>当遇到这样的代码块时，可获取某一变量的信息并对其进行范围检查，如果超过case的最大值，则跳转条件成立，跳转目标指明了switch语句块的末尾或者是default块的首地址。条件跳转后紧跟jmp指令，并且是相对比例因子寻址方式，且基址为地址表的首地址，说明此处是线性关系的switch分支结构</p>
<h2 id="难以构成跳转表的switch"><a href="#难以构成跳转表的switch" class="headerlink" title="难以构成跳转表的switch"></a>难以构成跳转表的switch</h2><p>对于两个case值间隔较大时，编译器用索引表来优化，索引表优化需要两张表：一张为case语句块地址表，另一张为case语句块索引表。</p>
<p>地址表中的每一项保存一个case语句块的首地址，有几个case语句块就有几项。default语句块也在其中，如果没有则保存一个switch结束地址。这个结束地址在地址表中只会保存一份，不会像有序线性地址表那样，重复保存switch的结束地址。</p>
<p>索引表中保存地址表的编号，它的大小等于最大case值和最小case值的差。当差值大于255时，这种优化方案也会浪费空间，可通过树方式优化，这里就只讨论差值小于或等于255的情况。表中的每- -项为- 一个字节大小，保存的数据为case语句块地址表中的索引编号。</p>
<p>首先将所有case语句块的首地址保存在-一个地址表中，<strong>地址表</strong>中的表项个数会根据程序中case分支来决定。有多少个case分支，地址表就会有多少项。<strong>索引表</strong>，中保存了地址表中的下标值。索引表中最多可以存储256项，每- -项的大小为 1字节，这决定了case值不可以超过1字节的最大表示范围(0~255)， 因此索引表也只能存储256项索引编号。</p>
<p><img src="P4.jpg" alt="索引表结构模拟图"></p>
<p>具体的参考这个<a href="https://www.cnblogs.com/ye-ming/articles/7942472.html" target="_blank" rel="noopener">blog</a>吧，写的很好</p>
<h2 id="do-while-for的比较"><a href="#do-while-for的比较" class="headerlink" title="do/while/for的比较"></a>do/while/for的比较</h2><p>do循环是向上跳转例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DO_BEGIN</span><br><span class="line">······			；循环语句块</span><br><span class="line">cmp xxxx&#x2F;test xxxx&#x2F;sub xxxx&#x2F;·····；影响标记位的指令</span><br><span class="line">jxx DO_BEGIN   	; 向上跳转</span><br></pre></td></tr></table></figure>

<p>while循环是先进行判断，向下跳转，到单次循环结束时，向上跳转，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHILE_BEGIN:</span><br><span class="line">; 影响标记位的指令</span><br><span class="line">jxx		WHILE_END			; 条件成立跳转到循环语句块结尾处</span><br><span class="line">······						; 循环语句块</span><br><span class="line">jmp		WHILE_BEGIN			; 跳转到取出条件比较数据处</span><br><span class="line">WHILE_END;</span><br></pre></td></tr></table></figure>

<p>for循环由赋初值、设置循环条件、设置循环步长这三条语句组成</p>
<p>for循环比较复杂，看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int LoopFor (int nCount&#125; &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;初始计数器变量、设置循环条件、设置循环步长</span><br><span class="line">	for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount; nIndex++) &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">	&#125;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇煸代码讲解</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">0040B818	mov		dword ptr [ebp-4] ,0</span><br><span class="line">&#x2F;&#x2F; C++源码对比，for语句</span><br><span class="line">for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount;nIndex++)</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 初始化计数器变量--nIndex									1.赋初值部分</span><br><span class="line">0040B81F	mov		dword ptr [ebp-8] ,0</span><br><span class="line">; 跳转到地址0x0040B831处，跳过步长操作</span><br><span class="line">00408826	jmp		LoopFor+31h (0040b831)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 取出计数器变量，用于循环步长								2.步长计算部分</span><br><span class="line">0040B828	mov		eax, dword ptr [ebp-8]</span><br><span class="line">; 对计数器变量执行加1操作，步长值为1							</span><br><span class="line">0040B82B	add		eax,1</span><br><span class="line">;将加1后的步长值放回计数器变量一nIndex</span><br><span class="line">0040B82E	mov		dword ptr [ebp-8] ，eax</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;取出计数器变量nIndex放入ecx									3.条件比较部分</span><br><span class="line">0040B831	mov		ecx, dword ptr [ebp-8]</span><br><span class="line">; ebp+8地址处存放数据为参数nCount, 见C++源码说明</span><br><span class="line">0040B834	cmp		ecx, dword ptr [ebp+8]</span><br><span class="line">; 比较nIndex与nCount, 大于则跳转到地址0x0040B844处，结柬循环</span><br><span class="line">0040B837	jd		LoopFor+44h (0040b844)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; for循环内执行语句块									4.循环体代码</span><br><span class="line">	nSum +&#x3D; nIndex;</span><br><span class="line">	mov		edx, dword ptr [ebp-4]</span><br><span class="line">	0040B83C	add		edx, dword ptr [ebp-8]</span><br><span class="line">	0040B83F	mov		dword ptr [ebp-4] , edx</span><br><span class="line">&#125;</span><br><span class="line">;跳转到地址0x0040B828处，这是一个向上跳</span><br><span class="line">0040B842	jmp		LoopFor+28h (0040b828)</span><br><span class="line">return nSum;</span><br><span class="line">&#x2F;&#x2F;设置返回值eax为ebp-4， 即nSum</span><br><span class="line">0040B844	mov		eax, dword ptr [ebp-4]</span><br></pre></td></tr></table></figure>

<p>以上，可以看到代码分为四个部分，总结一下就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov		mem&#x2F; reg, xxx						;賦初值</span><br><span class="line">jmp		FOR_CMP								;跳到循环条件判定部分</span><br><span class="line">FOR_STEP:									;步长计算部分</span><br><span class="line">;修改循环变量Step</span><br><span class="line">mov		reg,Step</span><br><span class="line">add		reg,xxxx				 ;修改循环变量的计算过程，在实际分析中，视算法不同而不同</span><br><span class="line">mov		Step,eax</span><br><span class="line">FOR_CMP:									;循环条件判定部分</span><br><span class="line">mov		ecx, dword ptr Step</span><br><span class="line">;判定循环变量和循环终止条件StepEnd 的关系，满足条件则逞出for循环</span><br><span class="line">cmp		ecx,StepEnd</span><br><span class="line">jxx		FOR_END								;条件成立则结柬循环</span><br><span class="line">·····</span><br><span class="line">jmp		FOR_STEP							;向上跳转，修改流程回到步长计算部分</span><br><span class="line">FOR_END;</span><br></pre></td></tr></table></figure>

<p>这种结构是for循环独有的，在计数器变量被赋初值后，利用jmp跳过第一次步长计算。然后，可以通过三个跳转指令还原for循环的各个组成部分:第一个jmp指令之前的代码为初始化部分;从第一个jmp指令到循环条件比较处( 也就是上面代码中FOR_ _CMP 标号的位置)之间的代码为步长计算部分;在条件跳转指令jxx之后寻找一个jmp指令，这jmp指令必须是向上跳转的，且其目标是到步长计算的位置，在jxx和这个jmp(也就是上面代码中省略号所在的位置)之间的代码即为循环语句块。</p>
<h2 id="编译器对循环结构的优化"><a href="#编译器对循环结构的优化" class="headerlink" title="编译器对循环结构的优化"></a>编译器对循环结构的优化</h2><p>while和for循环在O2优化中，都会被优化成do的形式，而结构被优化后，细节上还能被再次优化</p>
<ol>
<li><p>代码外提</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	int nIndex &#x3D; 0;</span><br><span class="line">	do &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">		nIndex++ ;</span><br><span class="line">		&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">		&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">	&#125; while (nIndex &lt; nCount - 1) ;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;经过优化后的反汇编代码</span><br><span class="line">. text : 00401000 sub_ 401000	proc near; CODE XREF:_ main+21↑p</span><br><span class="line">. text :00401000 arg_ 0		&#x3D; dword ptr 4</span><br><span class="line">;荻取参数到edx中</span><br><span class="line">. text : 00401000	mov		edx，[esp+arg_0]</span><br><span class="line">. text : 00401004	xor		eax,eax</span><br><span class="line">. text : 00401006	xor		ecx,ecx</span><br><span class="line">;代码外提，对edx执行自减1操作</span><br><span class="line">. text : 00401008	dec		edx</span><br><span class="line">;进入循环体，在循环体内直接对保存参数的edx进行比较，没有任何减1操作</span><br><span class="line">. text : 00401009 loc 401009:	: CODE XREF: sub_ 401000+E↑j</span><br><span class="line">. text : 00401009	add		eax, ecx </span><br><span class="line">. text : 0040100B	inc		ecx</span><br><span class="line">. text : 0040100C 	cmp		ecx,edx</span><br><span class="line">. text : 0040100E   jl		short loc_401009</span><br><span class="line">. text : 00401010	retn</span><br><span class="line">. text : 00401010 sub_401000	endp</span><br><span class="line"></span><br><span class="line">也就是被优化成了</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	int nIndex &#x3D; 0;</span><br><span class="line">	nCount -&#x3D; 1;</span><br><span class="line">	do &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">		nIndex++ ;</span><br><span class="line">		&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">		&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">	&#125; while (nIndex &lt; nCount) ;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.强度削弱</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:强度削弱</span><br><span class="line">int main(int argc) &#123;</span><br><span class="line">	int t&#x3D;0;</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	while (t &lt; argc) &#123;</span><br><span class="line">		t &#x3D; i * 99; &#x2F;&#x2F;强度削弱后，这里将不会使用乘法运算</span><br><span class="line">		i++;		&#x2F;&#x2F;此处转换后将为  t &#x3D; i; i +&#x3D; 99</span><br><span class="line">	&#125;				&#x2F;&#x2F;利用加法运算替换掉了指令周期长的乘法运算</span><br><span class="line">	printf(&quot;%d&quot;,t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;优化后的反汇编代码</span><br><span class="line">. text : 00401020 arg_0		&#x3D; dword ptr 4</span><br><span class="line">;将参数信息保存到edx中</span><br><span class="line">. text : 00401020	mov		edx, [esp+arg_0]</span><br><span class="line">. text : 00401024	xor		eax,eax				; 清空eax</span><br><span class="line">. text : 00401026	test	edx,edx</span><br><span class="line">. text : 00401028	jle		short loc_401035</span><br><span class="line">. text : 0040102A	xor		ecx,ecx				; 清空ecx</span><br><span class="line">. text : 0040102C	</span><br><span class="line">;循环语句玦首地址</span><br><span class="line">. text : 0040102C loc_ 40102C:		; CODE XREF: sub_ 401020+13↑j</span><br><span class="line">. text : 0040102C	mov		eax,ecx				; 将ecx传入eax中</span><br><span class="line">;ecx自加63h，即十进制99，等价于ecx每次加1乘以99.</span><br><span class="line">. text : 0040102E	add		ecx,63h</span><br><span class="line">. text : 00401031	cmp		eax,edx</span><br><span class="line">. text : 00401033	jl		short loc_40102C	; eax小于edx则执行跳转</span><br><span class="line">. text : 00401035</span><br><span class="line">. text : 00401035 loc_401035:	; CODE XREF: sub_ 401020+8↑j</span><br><span class="line">;printf函数调用处略</span><br><span class="line">. text : 00401043	retn</span><br><span class="line">. text :00401043 sub_401020		endp</span><br></pre></td></tr></table></figure>

<h1 id="函数工作原理"><a href="#函数工作原理" class="headerlink" title="函数工作原理"></a>函数工作原理</h1><h2 id="栈帧的形成和关闭"><a href="#栈帧的形成和关闭" class="headerlink" title="栈帧的形成和关闭"></a>栈帧的形成和关闭</h2><p>当栈顶指针esp小于栈底指针ebp时，就形成了栈帧</p>
<p><strong>栈平衡</strong>：</p>
<p>​    不同的两次函数调用，所形成的栈帧也不相同。当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的栈帧。当这个函数结束调用时，需要清除掉它所使用的栈空间，关闭栈帧，我们把这一过程称为栈平衡。</p>
<p>给一个小demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:一个空函数</span><br><span class="line">int main() &#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应的汇编代码讲解</span><br><span class="line">int main()&#123;</span><br><span class="line">; 以下是进入函数时的代码</span><br><span class="line">00401010	push	ebp			;进入函数后的第一件事，保存栈底指针ebp</span><br><span class="line">00401011	mov		ebp,esp		;调整当前栈底指针位置到栈顶</span><br><span class="line">00401013	sub		esp,40h 	;抬高栈顶esp,此时开辟栈空间0x40，作为局部变量的存储空间	</span><br><span class="line">00401016	push	ebx			;保存寄存器ebx</span><br><span class="line">00401017	push	esi			;保存寄存器esi</span><br><span class="line">00401018	push	edi			;保存寄存器edi</span><br><span class="line">00401019	lea		edi, [ebp-40h] ;取出此函数可用栈空间首地址</span><br><span class="line">0040101C	mov		ecx,10h ;设置ecx为0x10</span><br><span class="line">00401021	mov		eax, 0CCCCCCCCh ;将局部变量初始化为0CCCCCCCCh</span><br><span class="line"></span><br><span class="line">;根据ecx的值，将eax中的内容，以4字节为单位写到edi指向的内存中</span><br><span class="line">00401026	rep stos dword ptr [edi]</span><br><span class="line"></span><br><span class="line">;以下是用户编写的函数实现代码</span><br><span class="line">	return 0;</span><br><span class="line">0040102A	xor		eax,eax		;设置返回值为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;以下是函数退出时的代码</span><br><span class="line">0040102C	pop		edi 		;还原寄存器edi</span><br><span class="line">0040102D	pop		esi			;还原寄存器esi</span><br><span class="line">0040102E	pop		ebx 		;还原寄存器ebx</span><br><span class="line">0040102F	add		esp,40h 	;降低栈顶esp,此时局部变量空间被释放</span><br><span class="line">00401032	cmp		ebp,esp 	;检测栈平衡，如ebp与esp不等，则不平衡</span><br><span class="line">00401034	call	_chkesp (00401050)	;进入栈平衡错误裣测函数</span><br><span class="line">00401039	mov		esp,ebp 	;还原esp</span><br><span class="line">0040103B	pop		ebp	</span><br><span class="line">0040103C	ret</span><br></pre></td></tr></table></figure>

<h2 id="各种调用方式"><a href="#各种调用方式" class="headerlink" title="各种调用方式"></a>各种调用方式</h2><p>由于函数自身无法对不定参数执行平衡操作，所以有了函数的调用约定：</p>
<ul>
<li>_cdecl : CIC++默认的调用方式，调用方平衡栈，不定参数的函数可以使用。</li>
<li>_stdcall : 被调方平衡栈，不定参数的函数无法使用。</li>
<li>_fastcall : 寄存器方式传参，被调方平衡栈，不定参数的函数无法使用。</li>
</ul>
<p>_cdecl  与 _stdcall 的对比，debug版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_cdecl、_stdcall 两种调用方式的区别</span><br><span class="line">void _stdcall Showstd (int nNumber)&#123;	&#x2F;&#x2F; 使用_stdca1l 调用方式，被调方平衡栈</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">void _cdecl ShowCde (int nNumber)&#123;		&#x2F;&#x2F; 使用_ _cdecl 调用方式，调用方平衡栈</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	ShowStd(5);				&#x2F;&#x2F;不会有平衡栈操作</span><br><span class="line">	ShowCde(5);				&#x2F;&#x2F;函数调用结柬后，对esp平衡4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++源码对比，_stdcall调用方式</span><br><span class="line">void _stdcall ShowStd (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">00401059	ret		4 			;结柬后平衡栈顶4，等价esp +&#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，_cdecl 调用方式</span><br><span class="line">void _cdec1 ShowCde (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">004010A9	ret					;没有平衡操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用 _stdcall方式调用函数Showstd</span><br><span class="line">ShowStd(5) ;</span><br><span class="line">0040B7C8	push	5 			;函数传参，使用push指令esp-4</span><br><span class="line">0040B7CA	call	@ILT+10 (show) (0040100f) 	;没有对esp操作的指令</span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用_cdecl方式调用函数ShowCde</span><br><span class="line">ShowCde(5) ;</span><br><span class="line">0040B7CF	push	5 			;函数传参，使用push指令esp-4</span><br><span class="line">0040B7D1	call	@ILT+15 (ShowCde) (00401014) </span><br><span class="line">0040B7D6	add		esp,4		;esp +&#x3D; 4,平衡栈顶</span><br></pre></td></tr></table></figure>

<p>虽然区别明显，但是不能当作区分依据，因为汇编语言可能会在其他地方平衡栈~</p>
<p><strong>在O2优化下，_cdecl会采取复写传播优化，将每次参数平衡的操作进行归并，一次性平衡栈顶指针esp。</strong></p>
<p>_cdecl  调用方式的函数在同一作用域内多次使用， 会在效率上比  _stdcal l 高一点，这是因为  __cdecl 可以使用复写传播，而 _ stdcall 都在函数内平衡参数，无法使用复写传播这种优化方式。在这三种调用方式中， _ fastcall 调用方式的效率最高，其他两种调用方式都是通过栈传递参数，唯独 _ fastcall 可以利用寄存器传递参数。但由于寄存器数目很少，而参数相比可以很多，只能量力而行，故 _fastcall 调用方式只使用了ecx和edx,分别传递第-一个参数和第二个参数，其余参数传递则转换成栈传参方式。</p>
<p>来份_fastcall代码康康~：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_fastcall调用方式</span><br><span class="line">vold _fastcall ShowFast (int nOne，int nTwo，int nThree, int nFour) &#123;</span><br><span class="line">	printf(&quot;%d%d%d%d \r\n&quot;, nOne, nTwo， nThree, nFour) ;	</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	ShowFast(1,2,3,4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++ 源码对比， 函数调用</span><br><span class="line">ShowFast (1，2，3，4) ;</span><br><span class="line">004012A8	push	4					;使用栈方式传递参数</span><br><span class="line">004012AA 	push	3					;使用栈方式传递参数</span><br><span class="line">004012AC	mov		edx,2				;使用edx传递第二个参数2</span><br><span class="line">004012B1	mov		ecx,1				;使用ecx传递第一个参数1</span><br><span class="line">004012B6	call	@ILT+15 (ShowFast) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，函数说明</span><br><span class="line">void fastcall ShowFast(int nOne，int nTwo, int nThree, int nFour) &#123;</span><br><span class="line">004010F0	push	ebp</span><br><span class="line">004010F1	mov		ebp,esp</span><br><span class="line">004010F3	sub		esp,48h</span><br><span class="line">004010F6	push	ebx</span><br><span class="line">004010F7	push	esi</span><br><span class="line">004010F8	push	edi</span><br><span class="line">;由于ecx即将被赋值作为循环计数器使用，在此将ecx原值保存</span><br><span class="line">004010F9	push	ecx</span><br><span class="line">004010FA	lea		edi,[ebp-48h]</span><br><span class="line">004010FD	mov		ecx,12h</span><br><span class="line">00401102	mov		eax, 0CCCCCCCCh</span><br><span class="line">00401107	rep stos dword ptr [edi]</span><br><span class="line">00401109	pop		ecx					;还原ecx</span><br><span class="line">;使用临时变量保存edx (参数2)</span><br><span class="line">0040110A	mov		dword ptr [ebp-8] , edx</span><br><span class="line">;使用临时变量保存ecx (参数1)</span><br><span class="line">0040110D	mov		dword ptr [ebp-4] , ecx</span><br><span class="line">&#x2F;&#x2F; C++源码对比，printf 函数调用</span><br><span class="line">printf(&quot; %d%d%d%d \r\n&quot;, nOne，nTwo, nThree, nFour) ;</span><br><span class="line">;使用ebp相对寻址取得参数4</span><br><span class="line">00401110	mov		eax, dword ptr [ebp+0Ch]</span><br><span class="line">00401113	push	eax					;将eax压栈，作为参数</span><br><span class="line">;使用ebp相对寻址取得参数3</span><br><span class="line">00401114	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">00401117	push	ecx					;将ecx压栈， 作为参数</span><br><span class="line">;在ebp-8中保存edx，即参数2</span><br><span class="line">00401118	mov		edx,dword ptr [ebp-8]</span><br><span class="line">0040111B	push	edx					;将edx压栈， 作为参数</span><br><span class="line">;在ebp-4中保存ecx，即参数1</span><br><span class="line">0040111C	mov		eax, dword ptr [ebp-4]</span><br><span class="line">0040111F	push	eax					;将eax压栈， 作为参数</span><br><span class="line">00401120	push	offset string &quot;%d %d %d %d \r\n&quot; (00422024)</span><br><span class="line">00401125	call	printf(004012e0)</span><br><span class="line">0040112A	add 	esp,14h				;平衡pirntf 使用的5个参数</span><br><span class="line">&#125;</span><br><span class="line">0040113D	ret		8					;此函数有4个参数，ret指令对其平衡</span><br></pre></td></tr></table></figure>

<h2 id="使用ebp或esp寻址"><a href="#使用ebp或esp寻址" class="headerlink" title="使用ebp或esp寻址"></a>使用ebp或esp寻址</h2><p>由于局部变量使用栈空间进行存储，因此进入函数后的第一件事就是开辟函数中局部变量所需的栈空间大小，变量随着进入函数体开始生命，函数执行的时候结束</p>
<p>在大多数情况下，使用ebp寻址局部变量只能在非O2选项中产生，这样做是为了方便调试和检测栈平衡，使目标代码可读性更高。而在O2编译选项中，只要栈顶是稳定的，就可以不再使用ebp, 利用esp直接访问局部变量，可以节省一个寄存器资源。来个小demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:通过esp访问局部变量</span><br><span class="line">void InNumber() &#123;</span><br><span class="line">	int nInt &#x3D; 1;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;nInt);</span><br><span class="line">	char cChar &#x3D; 2;</span><br><span class="line">	scanf(&quot;%c&quot;, &amp;cChar);</span><br><span class="line">	printf(&quot;%d %c\r\n&quot;,nInt,cChar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数在main函数中被调用</span><br><span class="line">void main()&#123;</span><br><span class="line">	InNumber();</span><br><span class="line">&#125;</span><br><span class="line">;在Release版下，反汇蝙代码信息</span><br><span class="line">;函数定义，由于在main函数中只有一句函数调用代码，因此IDA为其取名 _main_0， 而不是使用地址做标号</span><br><span class="line">_main_0 proc near</span><br><span class="line">var_5 &#x3D; byte ptr -5					; IDA定义的局部变量标号，IDA环境下局部变量用var_ 开头</span><br><span class="line">var_4 &#x3D; dword ptr -4				; IDA定义的局部变量标号</span><br><span class="line">;为局部变量开辟8字节栈空间，这里在没有了那些繁琐的操作</span><br><span class="line">sub		esp,8</span><br><span class="line">;这句指令等价于; esp+8-4,标号var_4等于-4， IDA自动识别出访问的变量地址，并调整显示方式，省去了计算偏移量这个过程，类似于高级语言中为变量命名，使代码显示起来更具可读性</span><br><span class="line">lea		eax,[esp+8+var_4]</span><br><span class="line">mov		[esp+8+var_4], 1 			; 初始化var_ 4变量为1</span><br><span class="line">push	eax							; eax中保存[esp+8-4]的值，将eax作为参数入栈</span><br><span class="line">push	offset aD 					; &quot;%d&quot;</span><br><span class="line">call	_scanf</span><br><span class="line"></span><br><span class="line">;在分析指令的时候，IDA会根据代码上下文归纳出影响栈顶的指令，以确定esp相对寻址所访问的目标。</span><br><span class="line">;于是IDA识别出以下相对寻址指令的目标是该函数中的局部变量var_5， 之前执行了两次push指令，</span><br><span class="line">;所以esp指向的栈顶地址存在-8的差值，而且本函数第一条指令sub esp，8也影响栈顶。综合以</span><br><span class="line">;上信息，IDA为了表达出此时访问的局部变量为var_5， 并且将var_5定义为-5， 需要对esp相对寻址进行调整，先求解[esp+X+var_5]中的X，此处求解的X值为10h, 然后就可以表达为; [esp+10h+var_ 5]， 以加强代码的可读性。</span><br><span class="line">lea		ecx，[esp+10h+var_5]</span><br><span class="line">mov		[esp+10h+var_5] ,2			; 为var_5处的局部变量赋值2</span><br><span class="line">push	ecx							; esp -&#x3D; 4</span><br><span class="line">push	offset aC					; &quot;%c&quot;,esp -&#x3D; 4</span><br><span class="line">call	_scanf</span><br><span class="line">;由于又执行了两次push指令，并且没有平衡钱，所以需要再次调整esp的相对偏移值，这里的调整值为18h。注意，在这里的movsx指令处点一下Q键，可以得到movsx edx， byte ptr [esp+13h]， 按K键可还原,名称。这里的movsx指令显示var_5 的类型为有符号类型，byte ptr 说明长度为单字节，对应C语言中的定义应该是char.当然读者也可以考察使用变量作参数的函数，如果函数功能是已知的，那么参数类型也就已知了，进而推导出变量的类型。</span><br><span class="line">movsx	edx, [esp+18h+var_5]</span><br><span class="line">mov		eax, [esp+18h+var_4]</span><br><span class="line">push	edx</span><br><span class="line">push	eax</span><br><span class="line">push	offset Format	</span><br><span class="line">call	_printf</span><br><span class="line"></span><br><span class="line">;经过优化后的代码，一次性平衡了栈顶esp.在此函数中，共执行了7次push操作，而函数scanf和printf函数使用相同的调用方式，即_ cdecl 调用方式，因此函数内没有平衡钱，需要调用者来平衡栈顶指针esp，又因为在退出函数前，还需释放局部变量的日个字节(见函数入口指令)空间，所以esp需要加(7*4+8&#x3D;)36转换成十六进制后为24h</span><br><span class="line">add		esp,24h</span><br><span class="line">retn</span><br><span class="line">_main_0  endp</span><br></pre></td></tr></table></figure>

<p>每次访问变量都需要计算，如果在函数执行过程中esp发生了改变，再次访问变量就需要重新计算偏移。为了省去对偏移量的计算，方便分析，IDA在分析过程中事先将函数中的每个变量的偏移值计算出来，得出了一个固定偏移值，使用标号记录。这里有两个方案，正数标号法和负数标号法</p>
<ul>
<li><p>正数标号法：以调整后的esp作为基址来计算局部变量的偏移值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_0 &#x3D; 4 	;定义第一个变量偏移量，所在地址为0x0012FFEC</span><br><span class="line">var_1 &#x3D; 0  	;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp, 8 	;申请变量栈空间，esp保存地址变为0x0012FFE8</span><br><span class="line">lea eax, [esp+var_0]	;寻址第一个变量地址为0x0012FFE8+4 &#x3D; 0x0012FFEC</span><br><span class="line">push eax	;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">lea eax [esp+4+var_1]	;由于esp被减4，需要对基址esp进行加4,调整后再加上标号</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数标号法：以调整前的esp作为基址来计算局部变量的偏移值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_0 &#x3D; -4		;定义第一个变量偏移量，所在地址为0X0012FFEC</span><br><span class="line">var_1 &#x3D; -8		;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp,8 		;申请变量栈空间，esp 保存地址变为0x0012FFE8</span><br><span class="line">;使用申请变量栈空间前的esp作为基扯，就需要调整esp,将其加8</span><br><span class="line">lea eax, [esp+8+var_0]</span><br><span class="line">push eax		;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">;由于esp被减4，需要对基址esp进行二次调整，加8后再加4，因此得到数值0x0C</span><br><span class="line">lea eax [esp+0Ch+var_1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>显然ida选择了后者，下一节分析</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>参数也是函数中的一个变量，采用正数标号法来表示局部变量偏移标号时，函数的参数标号和局部变量的标号值都是正数，无法区分，不利于分析。如果使用负数标号法表示，则可以将两者区分，正数表示参数，而负数则表示局部变量，0值表示返回地址。</p>
<p>不放代码了，挺简单的</p>
<p>C\C++将不定长参数的函数定义为：</p>
<ul>
<li>至少要有一个参数</li>
<li>所有不定长的参数类型传入时都是dword类型</li>
<li>需在某一个参数中描述参数总个数或将最后一个参数赋值为结尾标记</li>
</ul>
<p>根据参数的传递特性，只要确定第一个参数的地址，对其地址值做加法，就可访问到此参数的下一个参数所在的地址。获取参数的类型是为了解释地址中的数据。.上面提到的第三点是为 了获取参数的个数，其目的是正确访问到最后一个参数的地址，以防止访问参数空间越界。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>call指令被执行后，该指令同时还会做另一件事：<strong>将下一条指令所在的地址压入栈中</strong></p>
<p>ret指令读取栈中地址传送给EIP寄存器，使程序回到call的下一条指令</p>
<p>函数的返回值是由EAX寄存器来保存，但是只能保存<strong>四字节</strong>数据，大于四字节的需要使用其他方法保存，来个demo代码(DEBUG版)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明</span><br><span class="line">&#x2F;&#x2F; 函数功能:获取当前函数的返回地址</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">	&#x2F;&#x2F;获取参数地址，减1后得到返回地址在栈中的地址</span><br><span class="line">	int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">	return nAddr;			&#x2F;&#x2F;将返回地址作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">; Debug保护环境初始化部分略</span><br><span class="line">int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">; ebp加法与esp加法原理相同，都是取参数，但是这里为什么是加8呢?</span><br><span class="line">;在Debug版下进入函数后，首先保存ebp会执行push ebp的操作，这样esp将执行压栈减4操作,随后执行mov ebp， esp的操作，由于栈顶esp之前被修改，所以ebp需要加4调整到最初的栈底位置,因此ebp+4 可以得到返回地址，ebp+8将会寻址第一个参数</span><br><span class="line">;以下代码将第一个参数的地址传入eax中</span><br><span class="line">0040DB78	lea		eax,[ebp+8]</span><br><span class="line">;执行eax自减4操作，执行后eax等价于ebp+4, 得到函数返回地址所在栈中的地址</span><br><span class="line">0040DB7B	sub		eax,4</span><br><span class="line">;取出函数返回地址传入ecx中</span><br><span class="line">0040DB7E	mov		ecx, dword ptr [eax]</span><br><span class="line">;使用ecx赋值局部变量</span><br><span class="line">0040DB80	mov		dword ptr [ebp-4] , ecx</span><br><span class="line">return nAddr;</span><br><span class="line">;取出局部变量数据传入eax中，用做函数返回值</span><br><span class="line">0040DB83	mov		eax, dword ptr [ebp-4]</span><br><span class="line">&#125;</span><br><span class="line">; Debug恢复环境，平衡栈、栈平衡检测部分略</span><br><span class="line">0040DB8C	ret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">int nAddr &#x3D; Getaddr (1) ;</span><br><span class="line">0040DAF8 	push	1			;压栈传参，传入参数1</span><br><span class="line">0040DAFA	call	@ILT+30(ss) (00401023)	;函数调用</span><br><span class="line">0040DAFF	add		esp,4		;_cdec1调用方式，平衡栈</span><br><span class="line">0040DB02	mov		dword ptr [ebp-4] , eax		;取得返回值</span><br></pre></td></tr></table></figure>

<p>再来个结构体的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明:结构体类型作为返回值</span><br><span class="line">struct tagTEST &#123;				&#x2F;&#x2F;结构体定义</span><br><span class="line">	int m_nOne;</span><br><span class="line">	int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回值为结构体类型的函数</span><br><span class="line">tagTEST RetStruct () &#123;</span><br><span class="line">	tagTEST testRet ; </span><br><span class="line">	testRet.m_nOne &#x3D; 1;</span><br><span class="line">	testRet.m_nTwo &#x3D; 2;</span><br><span class="line">	return testRet ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用函数，并将返回值赋值到结构体实例test中</span><br><span class="line">void main()&#123;</span><br><span class="line">	tagTEST test;</span><br><span class="line">	test &#x3D; RetStruct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇蝙代码讲解</span><br><span class="line">tagTEST RetStruct() &#123;</span><br><span class="line">; Debug保存环境、初始化部分略</span><br><span class="line">tagTEST testRet;</span><br><span class="line">testRet.m_nOne &#x3D; 1;</span><br><span class="line">004012A8	mov		dword ptr [ebp-8] ,1		;对结构体成员变量赋值</span><br><span class="line">testRet.m_nTwo &#x3D; 2;</span><br><span class="line">004012AF	mov		dword ptr [ebp-4] ,2		;对结构体成员变量赋值</span><br><span class="line">return testRet ;</span><br><span class="line">004012B6	mov		eax, dword ptr [ebp-8]		;取结构体成员变量数据传入eax中</span><br><span class="line">004012B9	mov		eax, dword ptr [ebp-4]		;取结构体成员变量数据传入eax中</span><br><span class="line">&#125;</span><br><span class="line">;Debug恢复环境略</span><br><span class="line">004012C2	ret		;执行ret指令结束函数调用</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">tagTEST test; </span><br><span class="line">test &#x3D; RetStruct () ;</span><br><span class="line">0040DC38	call	@ILT+35 (RetStruct) (00401028)	;调用函数RetStruct</span><br><span class="line">; eax中保存函数Retstruct中结构体testRet成员m_nOne的数据</span><br><span class="line">0040DC3D	mov		dword ptr [ebp-10h] ,eax 		; ebp-10h 为临时变量</span><br><span class="line">; edx中保存函数Retstruct中结构体testRet成员m_nTwo的数据</span><br><span class="line">0040DC3D	mov		dword ptr [ebp-0ch] ,edx 		; ebp-0ch 为临时变量</span><br><span class="line"></span><br><span class="line">;经过几次数据传递，最终将返回结果存入结构体实例test的两个成员所在地址处</span><br><span class="line">0040DC43	mov		eax, dword ptr [ebp-10h]</span><br><span class="line">0040DC46	mov		dword ptr [ebp-8] ,eax</span><br><span class="line">0040DC49	mov		ecx, dword ptr [ebp-0Ch]</span><br><span class="line">0040DC4C	mov		dword ptr [ebp-4] ，ecx</span><br></pre></td></tr></table></figure>

<p>结构体只有两个成员，所以用了eax和edx来传递返回值</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++反汇编与逆向分析技术(二)</title>
    <url>/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/</url>
    <content><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(二)</p>
<a id="more"></a>  
<h1 id="第四章-各种表达式的求值过程"><a href="#第四章-各种表达式的求值过程" class="headerlink" title="第四章 各种表达式的求值过程"></a>第四章 各种表达式的求值过程</h1><p>单独的算术运算虽然可以编译通过，但是并不会生成代码。因为只进行计算而没有传递结果的运算不会对程序结果有任何影响，此时编译器将其视为无效语句，与空语句等价，不会有任何编译处理  </p>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>VC++ 6.0有两种常用的优化方案  </p>
<ul>
<li>O1方案，生成文件占用空间最小</li>
<li>O2方案，执行效率最快</li>
</ul>
<p>在VC++ 6.0中，Release编译选项组的默认选项为<em>O2选项</em>，在Debug编译选项组中，使用的是<em>Od+ZI选项</em>，此选项使编译器产生的一切代码都以便于调试为最根本的前提，甚至为了便于单步调试，以及源码和目标代码块的对应阅读  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：加法运算</span><br><span class="line">&#x2F;&#x2F;无效语句，不参与编译</span><br><span class="line">15+20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; 0;</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量加常量的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个常量加法的加法运算</span><br><span class="line">nVarOne &#x3D; 1 + 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个变量相加的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwo</span><br><span class="line">printf(&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量赋值</span><br><span class="line">int nVarOne &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将立即数0，传入地址ebp-0x4中，即变量nVarOne所在的地址</span><br><span class="line">00401028 mov dword ptr [ebp-4],0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量赋值</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line">0040102F mov dword ptr [ebp-8],0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 + 常量</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出变量nVarOne数据放入eax中</span><br><span class="line">00401036 mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对eax执行加等于1运算</span><br><span class="line">00401039 add eax,1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果返回变量nVarOne中，完成加法运算</span><br><span class="line">0040103C mov dword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，常量 + 常量</span><br><span class="line">nVarOne &#x3D; 1 + 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里编译器直接计算出了两个常量相加后的结构，放入变量nVarOne中</span><br><span class="line">0040103F mov dword ptr [ebp-4],3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 + 变量</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ecx存放变量nVarOne</span><br><span class="line">00401046 mov ecx,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ecx对变量nVarTwo执行加等于操作</span><br><span class="line">00401049 add ecx,dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果存入地址ebp-4处，即变量nVarOne</span><br><span class="line">0040104C mov dword ptr [ebp-4],ecx</span><br></pre></td></tr></table></figure>



<p>由上方代码可得：  </p>
<ul>
<li>在两常量相加的情况下，编译器在编译期间就计算出两常量相加后的结果，将这个结果值作为立即数参与运算，减少了程序在运行期的计算</li>
<li>当有变量参与加法运算时，会先取出内存中的数据，放入通用寄存器中，再通过加法指令来完成计算过程得到结果，最后存回到变量所占用的内存空间中</li>
</ul>
<p>在开启O2选项后，编译出来的汇编代码会由于效率优先的编译选项而发生很大变化，编译器会将无用代码去除，并将可合并代码进行归并处理。例如，在代码清单4-1中，“nVarOne =<br>nVarOne+1;”这样的代码将被删除，因为在其后又重新对变量nVarOne进行了赋值操作，而在此之前没有对变量nVarOne的任何访问，所以编译器判定此句代码是可被删除的  </p>
<p>O2选项后Release版代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; int _cdecl main(int argc, const char **argu, const char **enup)</span><br><span class="line">__main proc near</span><br><span class="line">push    3</span><br><span class="line">push    offset format   ;&quot;nVarOne &#x3D; %d \r\n&quot;</span><br><span class="line">call    __printf</span><br><span class="line">add     esp,8</span><br><span class="line">xor     eax,eax</span><br><span class="line">retn</span><br><span class="line">__main endp</span><br></pre></td></tr></table></figure>

<ul>
<li>常量传播</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    int nVar &#x3D; 1;</span><br><span class="line">    printf(&quot;nVarOne &#x3D; %d  \r\n&quot;, nVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量nVar是一个在编译期间可以计算出结果的变量。因此，在程序中所有引用到nVar的地方都会直接使用常量1来代替，于是代码等价于:   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    printf &#123;&quot;nVarOne &#x3D; %d \r\n&quot;，1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量折叠  </li>
</ul>
<p>当计算公式中出现多个常量进行计算的情况时，且编译器可以在编译期间计算出结果时，这样源码中所有的常量计算都将被计算结果代替，如下面的代码所示:   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    int nVar &#x3D; 1 + 5 - 3 * 6;</span><br><span class="line">    printf(&quot;nVarOne &#x3D; %d \r\n&quot;,nVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这串算式被编译后会直接转化成常量-12，即”int nVar = -12;”  </p>
<p>在给出的加法代码中，变量nVarOne和nVarTwo的初始化值是-一个常量， VC++编译器在开启02优化方案后，会尝试使用常量替换掉变量。如果在程序的逻辑中，声明的变量没有被修改过，而且上下文中不存在针对此变量的取地址和间接访问操作，那么这个变量也就等价于常量，编译器就认为可以删除掉这个变量，直接用常量代替。使用常量的好处是可以生成立即数寻址的目标代码，常量作为立即数成为指令的一-部分，从而减少了内存的访问次数  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int nVarOne &#x3D; 0;    &#x2F;&#x2F;常量化以后: int nVarOne &#x3D; 0; nVarOne 用0代替了</span><br><span class="line">int nVarTwo &#x3D; 0;    &#x2F;&#x2F; int nVarTwo &#x3D; 0; 同上，这句也没有了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量加常量的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;      &#x2F;&#x2F;nVarOne&#x3D;0+1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相加的加法运算</span><br><span class="line">nVarOne &#x3D; 1 + 2;    &#x2F;&#x2F;nVarOne&#x3D;1+2;</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwO;    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + 0;</span><br><span class="line">printf (&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne);</span><br></pre></td></tr></table></figure>

<p>经过转化后，直接变成”printf(“nVarOne = %d \r\n”);”<br>将代码修改为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    int nVarOne &#x3D; argc;      &#x2F;&#x2F;修改处</span><br><span class="line">    int nVarTwo &#x3D; argc;      &#x2F;&#x2F;修改处</span><br><span class="line"></span><br><span class="line">    nVarOne &#x3D; nVarOne + 1 ;</span><br><span class="line">    nVarOne &#x3D; 1 + 2;</span><br><span class="line">    nVarOne &#x3D; nVarOne + nVarTwo;</span><br><span class="line">    printf &#123;&quot;nVarOne &#x3D; %d \r\n&quot;， nVarOne) ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里初始化nVarOne和nVarTwo的时候用命令行参数argc，故在编译期间无法确定，程序中的变量就不会被常量替换掉，汇编代码为  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; int_ cdec1 main(int argc, const char **argu, const char **envp)</span><br><span class="line">__main proc near  </span><br><span class="line"></span><br><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line"></span><br><span class="line">mov  eax, [esp+arg_0]</span><br><span class="line">add  eax, 3  </span><br><span class="line">push  eax  </span><br><span class="line">push  offset Format     ; &quot;nVarOne &#x3D; 0 \r\n&quot;</span><br><span class="line"></span><br><span class="line">call  printf</span><br><span class="line">add  esp,8</span><br><span class="line">xor  eax, eax</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">__main endp</span><br></pre></td></tr></table></figure>

<p>这里还是被删除了一个变量，优化过程如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    &#x2F;&#x2F; int nVarOne &#x3D; argc;在后面的代码中被常量代替</span><br><span class="line">    &#x2F;&#x2F; int nVarTwo &#x3D; argc;虽然不能用常量代替，但是由于之后没有对nVarTwo进行修改，所以引用nVarTwo等价于引用argc, nVarTwo 则被删除掉，这种方法称为”复写传播”</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + 1;其后即刻重新对nVarOne赋值，这句被删除了</span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; 1+2;常量折叠，等价于nVarOne&#x3D;3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + nVarTwo; 常量传播和复写传播，等价于nVarOne &#x3D; 3 + argc ;</span><br><span class="line">    &#x2F;&#x2F; printf (&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne) ;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;其后nVar0ne没有被访问，可以用3 + argc代替</span><br><span class="line">    printf (&quot;nVarOne &#x3D; %d \r\n&quot;, 3 + argc) ;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法运算对应于汇编指令sub，计算机是通过补码将减法转变为加法形式来完成转换，有公式  </p>
<p>设有二进制数Y，其反码记为Y(反)，假定其二进制长度为8位，有:  </p>
<ul>
<li>Y + Y(反) = 1111 1111B  </li>
<li>Y + Y(反) + 1 = 0(进位丢失)  </li>
</ul>
<p>根据以上两点，可推出  </p>
<ul>
<li>Y(反) + 1 = 0 - Y&lt;==&gt;Y(反) + 1 = -Y &lt;==&gt; Y(补} = -Y  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：减法运算</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取变量nVarTwo的数据，使用scanf防止被常量化</span><br><span class="line">scanf(&quot;%d&quot;,&amp;nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量减常量的减法运算</span><br><span class="line">nVarOne &#x3D; nVarOne - 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;减法与加法混合运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 5 - nVarTwo;</span><br><span class="line">printf(&quot;nVarOne &#x3D; %d \r\n&quot;,nVarOne);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 - 常量</span><br><span class="line">nVarOne &#x3D; nVarOne - 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取变量nVarOne的数据到eax中</span><br><span class="line">00401125	mov	eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是用减法指令sub，对eax执行减等于100操作</span><br><span class="line">00401128	sub	eax,64h</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果赋值回nVarOne中</span><br><span class="line">0040112B	mov dword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，减法与加法混合运算</span><br><span class="line">nVarOne &#x3D; nVarOne +5 - nVarTwo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按照自左向右顺序依次执行</span><br><span class="line">0040112E	mov	ecx,dword ptr [ebp-4]</span><br><span class="line">00401131	add	ecx,5</span><br><span class="line">00401134	sub	ecx,dword ptr [ebp-8]</span><br><span class="line">00401137	mov	dword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;printf函数调用显示略</span><br></pre></td></tr></table></figure>

<p>Release与加法相同，就不赘述了  </p>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法运算对应的汇编指令有有符号<strong>imul</strong>和无符号<strong>mul</strong>两种，由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换成加法，或使用移位等周期较短的指令。当它们都不可转换时，才会使用乘法指令  </p>
<p><strong>乘法转换——Debug版</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，乘法运算</span><br><span class="line">&#x2F;&#x2F;防止被视为无效代码，将每条运算作为printf参数使用</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量乘常量(常量为非2的幂)</span><br><span class="line">printf(&quot;nVarOne*15 &#x3D; %d \r\n&quot;,nVarOne * 15);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量乘常量(常量值为2的幂)</span><br><span class="line">printf(&quot;nVarOne*16 &#x3D; %d&quot;,nVarOne * 16);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相乘</span><br><span class="line">printf(&quot;2*2 &#x3D; %d&quot;,2 * 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;混合运算</span><br><span class="line">printf(&quot;nVarTwo *4 +5 &#x3D; %d&quot;,nVarTwo * 4 + 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两变量相乘</span><br><span class="line">printf(&quot;nVarOne * nVarTwo &#x3D; %d&quot;,nVarOne * nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 * 常量</span><br><span class="line">printf(&quot;nVarOne*15 &#x3D; %d \r\n&quot;,nVarOne * 15);</span><br><span class="line">0040B8A4	mov	edx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;直接使用有符号乘法指令imul</span><br><span class="line">0040B8A7	imul	edx,edx,0Fh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比 常量*常量(常量值为2的幂)</span><br><span class="line">printf(&quot;nVarOne*16 &#x3D; %d&quot;,nVarOne * 16)</span><br><span class="line">0040B8B8	mov	eax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;使用左移运算代替乘法运算</span><br><span class="line">0040B8BB	shl	eax,4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，常量*常量</span><br><span class="line">printf(&quot;2*2 &#x3D; %d&quot;,2 * 2);</span><br><span class="line">&#x2F;&#x2F;在编译期间计算出2*2的结果，将表达式转换为常量值</span><br><span class="line">0040B8CC	push 4</span><br><span class="line">0040B8CE	push offest string &quot;2 * 2 &#x3D; %d&quot;(0041ffac)</span><br><span class="line">0040B8D3	call printf(0040B750)</span><br><span class="line">0040B8D8	add esp,8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，变量*常量+常量(组合运算)</span><br><span class="line">printf(&quot;nVarTwo *4 +5 &#x3D; %d&quot;,nVarTwo * 4 + 5);</span><br><span class="line">0040B8DB	mov	ecx,dword ptr [ebp-8]</span><br><span class="line">&#x2F;&#x2F;利用lea指令完成组合运算</span><br><span class="line">0040B8DE	lea	edx,[ecx*4+5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，变量*变量</span><br><span class="line">printf(&quot;nVarOne * nVarTwo &#x3D; %d&quot;,nVarOne * nVarTwo);</span><br><span class="line">0040B90A	mov	ecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;直接使用有符号乘法指令</span><br><span class="line">0040B90D	imul ecx,dword ptr [ebp-8]</span><br></pre></td></tr></table></figure>

<p>代码使用编译选项为Od+ZI。在这种侧重调试的编译方式下，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法<strong>imul</strong>指令。当常量值为2的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令,而若乘数不等于2的幂次方，则会先拆分后用<strong>imul</strong>指令进行编译  </p>
<p><strong>各类型的乘法转换示例——Release版</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;IDA直接将参数作为局部变量使用</span><br><span class="line">arg_0 &#x3D; dword ptr 4  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存环境</span><br><span class="line">push esi</span><br><span class="line">&#x2F;&#x2F;取出参数变量存入esi中</span><br><span class="line">mov esi,[esp+4+arg_0]</span><br><span class="line">&#x2F;&#x2F;经过优化后，将nVarOne*15先转化为 乘2加自身，相当于乘3</span><br><span class="line">&#x2F;&#x2F;eax &#x3D; esi*2+esi &#x3D; 3*esi</span><br><span class="line">lea	eax,[esi+esi*2]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将上一步操作结果乘4加自身，等同于乘15</span><br><span class="line">&#x2F;&#x2F;eax &#x3D; eax * 4 + eax &#x3D; 5 * eax &#x3D; 5 * (3*esi)</span><br><span class="line">lea	eax,[eax+eax*4]</span><br><span class="line">push eax</span><br><span class="line">push offset aNvaronel15D; &quot;nVarOne * 15 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; esi中的数据传送到ecx，esi中保存的为参数数据</span><br><span class="line">mov	ecx,esi</span><br><span class="line">&#x2F;&#x2F;将ecx中的数据左移4为，ecx乘以2^4</span><br><span class="line">shl	ecx,4</span><br><span class="line">push ecx</span><br><span class="line">push offset aNvarone15D; &quot;nVarOne * 16 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相乘直接转换常量值</span><br><span class="line">push 4</span><br><span class="line">push offset a22D;	&quot;2*2 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;这句话等等同于lea edx,[esi*4+5]都是混合运算</span><br><span class="line">lea	edx,ds:5[esi*4]</span><br><span class="line">push edx</span><br><span class="line">push offset aNvartwo45D;	&quot;nVarTwo * 4 +5 &#x3D;%d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此处为乘数不等于2 4 8 情况，编译优化9进行分解：(nVarTwo*1+nVarTwo*8),这样就可以使用lea了</span><br><span class="line">lea eax,[esi+esi*8+5]</span><br><span class="line">push eax</span><br><span class="line">push _offset aNvartwo95D;	&quot;nVarTwo * 9 +5 &#x3D;%d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;此处为两个变量相乘，都是未知数，无忧化</span><br><span class="line">mov	ecx,esi</span><br><span class="line">imul ecx,esi</span><br><span class="line">push ecx</span><br><span class="line">push offest aNvaroneNvartwo;	&quot;nVarOne * nVarTwo &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">add	esp,30h</span><br><span class="line">pop	esi</span><br></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ul>
<li>向下取整：所谓对x向下取整，就是取得往-∞方向最接近x的整数值，换而言之也就是取得不大于x的最大整数  </li>
</ul>
<p>在标准C语言的math.h中，定义了floor函数，其作用就是向下取整，也有人称之为“地板取整”  </p>
<ul>
<li>向上取整：所谓对x向上取整，就是取得往+∞方向最接近x的整数值，换而言之也就是取得不小于x的最小整数  </li>
</ul>
<p>在标准C语言的math.h中有定义ceil函数，其作用就是向上取整，也有人称之为“天花板取整”</p>
<ul>
<li>向0取整：所谓对x向零取整，就是取得往0方向最接近x的整数值，换而言之也就是放弃小数部分  </li>
</ul>
<p>C语言是向0取整  </p>
<p><img src="P1.PNG" alt="定义">  </p>
<p><img src="P2.PNG" alt="定义">  </p>
<p>VC++6.0对除数为整型常量的除法会进行优化:如果除数是变量，则只能使用除法指令。如果除数为常量，就有了优化的余地。根据除数值的相关特性，编译器有对应的处理方式。  </p>
<p><strong>各类型除法转换——Debug版</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：除法运算</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int	nVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个变量做除法</span><br><span class="line">printf(&quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot;, nVarOne &#x2F; nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以常量，常量为2的1次方</span><br><span class="line">printf(&quot;nVarOne &#x2F; 2 &#x3D; %d&quot;, nVarOne &#x2F; 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以非2的幂</span><br><span class="line">printf(&quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;, nVarTwo &#x2F; 7);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量对非2的幂取模</span><br><span class="line">printf(&quot;nVarTwo % 7 &#x3D; %d&quot;, nVarTwo % 7);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以常量，常量为2的3次方</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;, nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">0040B7E8	mov	eax,dword ptr [ebp+8]</span><br><span class="line">0010B7EB	mov	dword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量定义</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line">0040B7EE	mov	ecx,dword ptr [ebp+8]</span><br><span class="line">0040B7F1	mov	dword ptr [ebp-8],ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;除法运算转换特性</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 变量</span><br><span class="line">printf(&quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot;, nVarOne &#x2F; nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax中</span><br><span class="line">0040B7F4	mov	eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展高位(EDX:EAX,这里表示EDX，EAX连用表示64位数 )</span><br><span class="line">0040B7F7	cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两变量相除，直接使用有符号除法指令idiv</span><br><span class="line">0040B7F8	idiv	eax,dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;eax保存商值，作为参数压栈，调用函数printf</span><br><span class="line">0040B7FB	push eax</span><br><span class="line">0040B7FC	push offset string &quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot; (00420034)</span><br><span class="line">0040B801	call printf (0040B750)</span><br><span class="line">0040B806	add	esp,8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量 (常量值为2的1次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 2 &#x3D; %d&quot;, nVarOne &#x2F; 2);</span><br><span class="line">0040B809	mov	eax,dword ptr [ebp-4]</span><br><span class="line">0040B80C	cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自身减去扩展高位</span><br><span class="line">0040B80D	sub	eax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;和乘法运算类似，乘法是左移</span><br><span class="line">0040B80F	sar	eax,1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量 (非2的幂)</span><br><span class="line">printf(&quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;, nVarTwo &#x2F; 7);</span><br><span class="line">0040B81F	mov eax,dword ptr [ebp-8]</span><br><span class="line">00040B22	cdq</span><br><span class="line">0040B823	mov	ecx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;无忧化直接使用有符号除法指令idiv</span><br><span class="line">0040B828	idiv eax,ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 % 常量</span><br><span class="line">printf(&quot;nVarTwo % 7 &#x3D; %d&quot;, nVarTwo % 7);</span><br><span class="line">0040B838	mov	eax,dword ptr [ebp-8]</span><br><span class="line">0040B83B	cdq  &#x2F;&#x2F;执行 CDQ 后， CDQ 把第 31 bit 复制至 EDX 所有 bit</span><br><span class="line">0040B83C	mov ecx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;无忧化，直接使用有符号指令idiv</span><br><span class="line">0040B841	idiv eax,ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;除法指令过后，余数保存在扩展为edx中</span><br><span class="line">0040B843	push edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf 函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量(常量值为2的3次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;,nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax</span><br><span class="line">0040B851	mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展eax高位到edx</span><br><span class="line">0040B854	cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果eax为负数</span><br><span class="line">0040B855	and edx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用eax加edx，若eax为负数则加7，反之加0</span><br><span class="line">0040B858	add	eax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将eax右移3位</span><br><span class="line">0040B85A	sar	eax,3</span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br></pre></td></tr></table></figure>

<p>这里只对除数为2的幂的情况进行了优化处理：<br>这里运用了推导7的结论：(x+(2^n-1)) &gt;&gt; n  </p>
<p><strong>除数为2的幂</strong>  </p>
<p>上述代码中的0040B80C的cdq是符号扩展到高位edx,如果eax的最高位(符号位)为1,那么edx的值为0xFFFFFFFF，也就是-1，否则为0。0040B80D地址处的sub eax,edx指令执行的操作是将eax减去高位edx，实际上就是被除数为负数的情况下，由于除数为正数(+2的幂)，故除法的商为负数。移位运算等价于向下取整，C语言的除法是向零取整，因此需要对商为负的情况做加1调整(见推导7)，减去-1等同于加1。eax不为负则减0，等于没处理。最后sar右移完成除法。这样的设计可以避免分支结构的产生  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量(常量值为2的3次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;,nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax</span><br><span class="line">0040B851	mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展eax高位到edx</span><br><span class="line">0040B854	cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果eax为负数</span><br><span class="line">0040B855	and edx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用eax加edx，若eax为负数则加7，反之加0</span><br><span class="line">0040B858	add	eax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将eax右移3位</span><br><span class="line">0040B85A	sar	eax,3</span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br></pre></td></tr></table></figure>

<p>这里我要记录一下我的犯蠢时刻，计算机里负数的各项计算都是通过<strong>补码</strong>进行的，所以add eax，edx这句话就不会有问题，基础太差了呜呜  </p>
<p>0040B854的cdq是符号扩展到高位edx，在0040B855处对edx做位与运算，当被除数为负数时，edx的值为7，在0040B858处的add eax，edx就是被除数为负数时加上2^n-1，不为负数则加0，最后sar右移完成除法  </p>
<p><strong>除数非2的幂</strong><br>Release版中还对除数不为2的幂的情况做了优化：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;IDA中的参数标识，经过优化后，省去了局部变量，直接使用参数</span><br><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 变量 和Debug版相同，此处省略</span><br><span class="line">&#x2F;&#x2F;......</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 常量 (常量值为2的幂)和Debug版相同，此处省略</span><br><span class="line">&#x2F;&#x2F;.....</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 常量 (常量值为非2的幂)，这里的汇编代码和Debug版的汇编代码差别很大</span><br><span class="line">&#x2F;&#x2F;将数值 92492493h放到eax中</span><br><span class="line">mov	eax,92492493h</span><br><span class="line">&#x2F;&#x2F;有符号乘法，用esi乘以eax，esi中保存被除数</span><br><span class="line">imul esi</span><br><span class="line">&#x2F;&#x2F;edx为扩展的高位</span><br><span class="line">add	edx,esi</span><br><span class="line">&#x2F;&#x2F;右移2位</span><br><span class="line">sar	edx,2</span><br><span class="line">&#x2F;&#x2F;结果放回eax</span><br><span class="line">mov	eax,edx</span><br><span class="line">&#x2F;&#x2F;将eax右移31次</span><br><span class="line">shr	eax，1Fh</span><br><span class="line">&#x2F;&#x2F;加以右移结果，放入edx中</span><br><span class="line">add	edx,eax</span><br><span class="line">push edx</span><br><span class="line">push offset aNvarTwo7D; &quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;其余代码和Debug版类似，略</span><br><span class="line">&#x2F;&#x2F;......</span><br></pre></td></tr></table></figure>

<p>由于除法指令的周期比乘法要长出很多，所以release版的除法指令会被乘法和其他指令替代，这里出现了一个大数92492493，给出数学证明  </p>
<p><img src="P3.png" alt="证明">  </p>
<p>来个例子看一下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401000	_main proc near ; CODE XREF: start+AF p</span><br><span class="line">.text:00401000	arg_0 &#x3D; dword ptr 4</span><br><span class="line">.text:00401000	mov	ecx,[esp+arg_0]</span><br><span class="line">.text:00401004	mov	eax,38E38E39h</span><br><span class="line">.text:00401000  imul ecx	&#x2F;&#x2F;ecx乘以参数</span><br><span class="line">.text:0040100B	sar	edx,1	&#x2F;&#x2F;有符号移位</span><br><span class="line">.text:0040100D	mov eax,edx</span><br><span class="line">.text:0040100F	shr	eax,1Fh	&#x2F;&#x2F;无符号移位</span><br><span class="line">.text:00401012	add	edx,eax</span><br><span class="line">.text:00401014	push edx</span><br><span class="line">.text:00401015	push offset Format ; &quot;%d&quot;</span><br><span class="line">.text:0040101A	call _printf</span><br><span class="line">.text:0040101F	add esp,8</span><br><span class="line">.text:00401022	retn</span><br><span class="line">.text:00401022_main endp</span><br></pre></td></tr></table></figure>

<p>看到在地址.text: 00401004处，我们看到了mov eax, 38E38E39h，此后做了乘法和移位操作,最后直接使用edx显示。在乘法指令中，由于edx存放乘积数据的高4字节，因此直接使用edx就等价于乘积右移了32位，再算上.text:0040100B sar edx, 1，那就一共移动了33位。在地址.text: 0040100D 处，eax 得到了edx 的值，然后对eax右移了1Fh位，对应10进制也就是右移了31位，然后有个很奇怪的加法。其实这里移位的目的是得到有符号数的符号位，如果结果是正数，add edx, eax就是加0，等于什么都没干;如果结果是负数，由于其后面的代码直接使用edx作为计算结果，需要对除法的商调整加1。简单证明如下:  </p>
<p><img src="P4.png" alt="证明">  </p>
<p>于是可以推出C代码:   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%d&quot;,arg&#x2F;9);</span><br></pre></td></tr></table></figure>

<p>总结:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov	eax,MagicNumber</span><br><span class="line">imul ...</span><br><span class="line">sar	edx,...</span><br><span class="line">mov	reg,edx</span><br><span class="line">shr	reg,1Fh</span><br><span class="line">add	edx,reg</span><br><span class="line">&#x2F;&#x2F;之后就直接用edx的值，eax的不用</span><br></pre></td></tr></table></figure>

<p>遇到上面你的指令序列的时候，基本可以判定是除法优化后的代码，除法的原型为<em>a/o</em>，<strong>imul</strong>是表明的有符号计算，操作数是优前的被除数a，右移的总次数确定n的值，用公式<strong>o= 2^n/c</strong>，将MagicNumber作为c代入公式求我们的除数o的近似值，四舍五入取整，就可以恢复除法原型！  </p>
<p>再来个例子  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00401080 _main proc near ; CODE xREF: start+AF p</span><br><span class="line">.text:00401080 arg_0 &#x3D; dword ptr 4</span><br><span class="line">.text:00401080	mov ecx,[esp+arg_0]</span><br><span class="line">.text:00401084	mov eax,24924925h</span><br><span class="line">.text:00401089	mul	ecx</span><br><span class="line">.text:0040108B	sub	ecx,edx</span><br><span class="line">.text:0040108D	shr	ecx,1</span><br><span class="line">.text:0040108F	add	ecx,edx</span><br><span class="line">.text:00401091	shr	ecx,2</span><br><span class="line">.text:00401094	push ecx</span><br><span class="line">.text:00401095	push offset	Format</span><br><span class="line">.text:0040109A	call _printf</span><br><span class="line">.text:0040109F	add	esp,8</span><br><span class="line">.text:004010A2	xor	eax,eax</span><br><span class="line">.text:004010A4	retn</span><br><span class="line">.text:004010A4 _ma in endp</span><br></pre></td></tr></table></figure>

<p>手推：</p>
<p><img src="P5.png" alt="推导">  </p>
<p>于是，可以推出代码来:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf (&quot;nVarTwO &#x2F; 7 &#x3D; %d\r\n&quot;, argc &#x2F; 7);</span><br></pre></td></tr></table></figure>

<p>计算得出MagicNumber后，如果其值超出4字节整数的表达范围，编译器会对其进行调整，如上个例子中的argc/7，计算MagicNumber时，编译器选择 2^35/7，其结果超出了4字节整数的表达范围，所以编译器调整MagicNumber的取值为2^35/7-2^32  </p>
<p>公式：a/o = [((a-a * c)/2^32)/2 + a * c/2^32]/2^(n-1)  </p>
<p>总结：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax,MagicNumber</span><br><span class="line">&#x2F;&#x2F;reg表示通用寄存器</span><br><span class="line">mul reg</span><br><span class="line">sub	reg,edx</span><br><span class="line">shr	reg,1</span><br><span class="line">add	reg,edx</span><br><span class="line">shr	reg,A	&#x2F;&#x2F;这句没有，那么n就是1，否则这里就是n-1的值</span><br></pre></td></tr></table></figure>

<p>如果遇到上面的指令序列，基本可以判定出发优化后的代码，其除法原型为a/常量o，mul代表的无符号计算，用公式o = 2^(32+n)/(2^32+c)将MagicNumber作为c值代入公式求解常数除数o，即可恢复除法原型  </p>
<p>现在再来看之前的代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 92492493h疑似 2^n&#x2F;o</span><br><span class="line">. text:004010AA     mov eax, 92492493h</span><br><span class="line">;这里是流水线优化，esp和上次调用的call指令相关，和除法计算无关，可暂不理会  </span><br><span class="line">;关于流水线优化详见4.4.1小节  </span><br><span class="line">. text:004010AF     add esp,8  </span><br><span class="line"></span><br><span class="line">;有符号乘法，用esi乘以eax，esi中保存被除数</span><br><span class="line">. text:004010B2     imul esi</span><br><span class="line"></span><br><span class="line">;这里又多出一个诡异的加法</span><br><span class="line">. text:004010B4     add edx, esi</span><br><span class="line"></span><br><span class="line">;右移2位，也可看做除4</span><br><span class="line">. text:004010B6     sar edx, 2</span><br><span class="line"></span><br><span class="line">;结果给eax</span><br><span class="line">. text:004010B9     mov eax, edx</span><br><span class="line"></span><br><span class="line">;负数调整加1</span><br><span class="line">. text:004010BB     shr eax, 1Fh</span><br><span class="line">. text:004010BE     add edx，eax</span><br><span class="line">. text:004010C0     push edx</span><br><span class="line">. text:004010C1     push offset aNvartwo7D ; &quot;nVarTwo &#x2F; 7 &#x3D; td&quot; ;</span><br><span class="line">. text:004010C6     ca11 _printf</span><br></pre></td></tr></table></figure>

<p>这段代码在.text:004010B4处的加法显得很奇怪,其实这里的代码是上面介绍的除法转乘法公式的变化。在.text:004010B2处的指令是imul esi,这是个有符号数的乘法。请注意，编译器在计算MagicNumber时是作为<strong>无符号</strong>处理的，而代入除法转换乘法的代码中又是作为有符号乘数处理的。因为有符号数的<strong>最高位不是数值，而是符号位</strong>，所以，对应的有符号乘法指令是不会让最高位参与数值计算的，这会导致乘数的数学意义和MagicNumber不一致  </p>
<p>由于符号数和无符号数的存储问题，所以要将表达式调整一下  </p>
<p><img src="P6.png" alt="证明">  </p>
<p>总结  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, MagicNumber (大于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">add edx, reg</span><br><span class="line">sar edx, ...</span><br><span class="line">mov reg, edx</span><br><span class="line">shr reg, 1Fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure>

<p>当遇到以上指令序列时，基本可判定是除法优化后的代码，其除法原型为a除以常量o,imul表明是有符号计算，其操作数是优化前的被除数a,接下来统计右移的总次数以确定公式中的n值，然后使用公式<strong>o=(2^n)/c</strong>,将MagicNumber作为c值代入公式求解常量除数o，即可恢复除法原型  </p>
<ul>
<li>除数为负的非2的幂(MagicNumber大于0x7fffffffh)  </li>
</ul>
<p>总结  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, MagicNumber (大于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">sar edx,···</span><br><span class="line">mov reg,edx</span><br><span class="line">shr reg,1fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure>

<p>如果遇到以上指令序列，则基本可判定是除法优化后的代码，其除法原型为a除以常量o, imul可表明是有符号计算，其操作数是优化前的被除数a,由于MagicNumber取值大于7fffffffh，而imul和sar之间未见任何调整代码，故可认定除数为负，且MagicNumber为补码形式。接下来统计右移的总次数以确定公式中的n值，然后使用公式|o|=2^n/((2^32)-c),MagicNumber作为c值代人公式求解常量除数|o|，即可恢复除法原型  </p>
<ul>
<li>除数为负的非2的幂(MagicNumber小于0x7fffffffh)  </li>
</ul>
<p>总结  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, MagicNumber (小于等于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">sub edx, reg</span><br><span class="line">sar edx, ...</span><br><span class="line">mov reg, edx</span><br><span class="line">shr reg, 1Fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure>

<p>如果遇到以上指令序列，则基本可判定是除法优化后的代码，其除法原型为a除以常量o, imul可表明是有符号计算，其操作数是优化前的被除数a,由于MagicNumber取值小于7fffffffh，而imul和sar之间未见任何调整代码，故可认定除数为负，且MagicNumber为补码形式。接下来统计右移的总次数以确定公式中的n值，然后使用公式|o|=2^n/((2^32)-c),MagicNumber作为c值代人公式求解常量除数|o|，即可恢复除法原型  </p>
<ul>
<li>除法优化原则  </li>
</ul>
<p>这里我直接copy l0x1c师傅的blog了，没错，👴就是懒狗  </p>
<p>先给一些背景：</p>
<p>（1）比如 7 / 2 = 3 …… 1 -7 / 2 = -3 …… -1</p>
<p>比较重要的是，余数的绝对值小于除数的绝对值，并且余数和被除数同正负</p>
<p>（2）由于C语言中除法是向0取整，也就是“截断除法”</p>
<p>不难发现，正数除以正数时，截断除法相当于向下取整（3.5 -&gt; 3）；而负数除以正数时，截断除法相当于向上取整( -3.5 -&gt; -3 )</p>
<p>（3）除以2的k次幂通常会被优化成右移k位，这里考虑除以2时</p>
<p>用一个signed byte表示7，是00000111，右移一位变成00000011是3，是正确的</p>
<p>但是，考虑-7/2，-7是11111001，右移一位后变成11111100，这是-4，因为这是向下取整的结果，所以比正确的答案 -3少了1</p>
<p>代码中为了统一和效率，如果是32位的数字，会先右移31位扩展符号位。原先是正数则最高位是0，那么最后会变成32个0，也就是0,；原先是负数最高位是1，最后会变成32个1，也就是-1，暂且把这个扩展符号位后形成的数记作S,</p>
<p>那么，我们只需要把右移一位的结果，减去这个S，就可以得到正确的截断除法的值</p>
<p>7/2 = 7&gt;&gt;1 – (0) = 3 -7/2 == -7&gt;&gt;1 – (-1) = -3</p>
<p>( 这一点在例题代码中会再次提到 )</p>
<p>（4）当除以正数N，而N不是2的次幂时，编译器会生成一个magic_number（C），以使除法优化成乘法，提高效率</p>
<p>贴一道例题分析</p>
<p>![<a href="https://ctftime.org/task/5294?tdsourcetag=s_pcqq_aiomsg]" target="_blank" rel="noopener">https://ctftime.org/task/5294?tdsourcetag=s_pcqq_aiomsg]</a>  </p>
<ul>
<li>取模运算  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov reg,被除数</span><br><span class="line">and reg, 8000001F ;这里的立即数是去掉高位保留低位的掩码，其值由2^k决定</span><br><span class="line">jns LAB1</span><br><span class="line">dec reg</span><br><span class="line">or reg, FFFFFFE0</span><br><span class="line">inc reg</span><br><span class="line">LAB1 :</span><br></pre></td></tr></table></figure>

<p>当遇到以上指令序列时，基本可判定是取模代码，其取模原型为被除数(变量)对2^k(常量)执行取模运算，jns 可表明是有符号计算，考察“and reg,8000001F”这类去掉高位保留低位的代码，统计出一共保留了多少低位，即可得到k的值，代入求得2*的值后，可恢复取模代码原型  </p>
<p>对于x%(2^k)，有的编译器会得到以下代码:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;先求x&#x2F;2^5的商</span><br><span class="line">mov eax，被除数</span><br><span class="line">cdq</span><br><span class="line">and edx, 1F</span><br><span class="line">add eax, edx</span><br><span class="line">sar eax,5;这时eax已经得到了商</span><br><span class="line">;余数&#x3D;被除数-商*2^5</span><br><span class="line">shl eax,5</span><br><span class="line">sub 被除数，eax ;此时可以得到余数</span><br></pre></td></tr></table></figure>

<h2 id="算术结果溢出"><a href="#算术结果溢出" class="headerlink" title="算术结果溢出"></a>算术结果溢出</h2><ul>
<li><p>进位<br>无符号数超出存储范围叫做进位。因为没有符号位，不会破坏数据，而多出的1位数据会被进位标志位CF保存，数据产生了进位，只是进位后的1位数据1不在自身的存储空间中，而在标志位CF中。可通过查看进位标志位CF,检查数据是否进位  </p>
</li>
<li><p>溢出<br>有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位——符号位。只有有符号数才有符号位，所以溢出只针对有符号数。可查看益出标志位OF,检查数据是否溢出。OF的判定规则很简单，如果参与加法计算的数值符号一致，而计算结果符号不同，则判定OF成立，其他都不成立  </p>
</li>
</ul>
<h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2><p>VC++ 6.0使用“++”、“–” 来实现自增和自减操作。自增和自减有两种定义，一种为自增自减运算符在语句块之后，则先执行语句块，再执行自增自减;另一种恰恰相反，自增自减运算符在语句块之前，则先执行自增和自减，再执行语句块。通常，自增和自减是被拆分成两条汇编指令语句执行的  </p>
<p><strong>代码如下</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自增自减代码</span><br><span class="line">&#x2F;&#x2F;C++源码说明:除法运算</span><br><span class="line">&#x2F;&#x2F;变量定义并出初始化</span><br><span class="line">int nvarOne &#x3D; argc;</span><br><span class="line">int nvarTwo &#x3D; argc;</span><br><span class="line">&#x2F;&#x2F;变量后缀自增参与表达式运算</span><br><span class="line">nvarTwo &#x3D; 5 + (nvarOne++);</span><br><span class="line">&#x2F;&#x2F;变量前缀自增参与表达式运算</span><br><span class="line">nvarTwo &#x3D; 5 + (++nvarOne);</span><br><span class="line">&#x2F;&#x2F;变量后缀自减参与表达式运算</span><br><span class="line">nvarone &#x3D; 5 + (nvarTwo--);</span><br><span class="line">&#x2F;&#x2F;变量前缀自减参与表达式运算</span><br><span class="line">nvarone &#x3D; 5 + (--nvarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;变量对应初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后缀自增运算</span><br><span class="line">nvarTwo &#x3D; 5 + (nvarTwo++);</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne，保存在edx中</span><br><span class="line">0040BA34	mov	edx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;讲edx执行加等于5</span><br><span class="line">0040BA37	add	edx,5</span><br><span class="line">&#x2F;&#x2F;讲edx赋值给变量nvarTwo，可以看到没有对变量nvarOne执行自增操作</span><br><span class="line">0040BA3A	mov	dword ptr [ebp-8],edx</span><br><span class="line">&#x2F;&#x2F;再次取出变量nvarOne数据存入eax中</span><br><span class="line">0040BA3D	mov	eax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;执行eax加等于1</span><br><span class="line">0040BA40	add	eax,1</span><br><span class="line">将eax赋值给变量nvarOne,等同于对变量nvarOne执行自增1操作</span><br><span class="line">0040BA43	mov	dword ptr [ebp-4],ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，前缀自增运算</span><br><span class="line">nVarTwo &#x3D; 5 + (++nvarOne);</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne数据放入ecx中</span><br><span class="line">0040BA46	mov	ecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;对ecx执行加等于1的操作</span><br><span class="line">0040BA49	add	ecx,1</span><br><span class="line">&#x2F;&#x2F;将ecx赋值给变量nvarOne，完成自增1操作</span><br><span class="line">0040BA4C	mov	dword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne放到edx中</span><br><span class="line">0040BA4F	mov	edx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;对edx执行加等于5</span><br><span class="line">0040BA52	add	edx,5</span><br><span class="line">&#x2F;&#x2F;将结果edx赋值给变量nvarTwo</span><br><span class="line">0040BA55	mov	dword ptr [ebp-8],edx</span><br><span class="line">&#x2F;&#x2F;自增和自减差不多相同，add替换成sub就可</span><br></pre></td></tr></table></figure>

<h2 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h2><ul>
<li>与运算(&amp;&amp;)  </li>
<li>或运算(||)</li>
<li>非运算(!)  </li>
</ul>
<p><strong>各种关系对应的条件跳转指令如表</strong>  </p>
<table>
<thead>
<tr>
<th align="center">指令助记符</th>
<th align="center">检查标记位</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JZ</td>
<td align="center">ZF == 1</td>
<td align="center">等于0则跳转</td>
</tr>
<tr>
<td align="center">JE</td>
<td align="center">ZF == 1</td>
<td align="center">相等则跳转</td>
</tr>
<tr>
<td align="center">JNZ</td>
<td align="center">ZF == 0</td>
<td align="center">不等于0则跳转</td>
</tr>
<tr>
<td align="center">JNE</td>
<td align="center">ZF == 0</td>
<td align="center">不相等则跳转</td>
</tr>
<tr>
<td align="center">JS</td>
<td align="center">SF == 1</td>
<td align="center">符号为负则跳转</td>
</tr>
<tr>
<td align="center">JNS</td>
<td align="center">SF == 0</td>
<td align="center">符号为正则跳转</td>
</tr>
<tr>
<td align="center">JP/JPE</td>
<td align="center">PF == 1</td>
<td align="center">“1”的个数为偶数则跳转</td>
</tr>
<tr>
<td align="center">JNP/JPO</td>
<td align="center">PF == 0</td>
<td align="center">“1”的个数为奇数则跳转</td>
</tr>
<tr>
<td align="center">JO</td>
<td align="center">OF == 1</td>
<td align="center">溢出则跳转</td>
</tr>
<tr>
<td align="center">JNO</td>
<td align="center">OF == 0</td>
<td align="center">无溢出则跳转</td>
</tr>
<tr>
<td align="center">JC</td>
<td align="center">CF == 1</td>
<td align="center">进位则跳转</td>
</tr>
<tr>
<td align="center">JB</td>
<td align="center">CF == 1</td>
<td align="center">小于则跳转</td>
</tr>
<tr>
<td align="center">JNAE</td>
<td align="center">CF == 1</td>
<td align="center">不大于等于则跳转</td>
</tr>
<tr>
<td align="center">JNC</td>
<td align="center">CF == 0</td>
<td align="center">无进位则跳转</td>
</tr>
<tr>
<td align="center">JNB</td>
<td align="center">CF == 0</td>
<td align="center">不小于则跳转</td>
</tr>
<tr>
<td align="center">JAE</td>
<td align="center">CF == 0</td>
<td align="center">大于则跳转</td>
</tr>
<tr>
<td align="center">JBE</td>
<td align="center">CF == 1或ZF == 1</td>
<td align="center">小于等于则跳转</td>
</tr>
<tr>
<td align="center">JNA</td>
<td align="center">CF == 1或ZF == 1</td>
<td align="center">不大于则跳转</td>
</tr>
<tr>
<td align="center">JNBE</td>
<td align="center">CF == 0或ZF == 0</td>
<td align="center">不小于等于则跳转</td>
</tr>
<tr>
<td align="center">JA</td>
<td align="center">CF == 0或ZF == 0</td>
<td align="center">大于则跳转</td>
</tr>
<tr>
<td align="center">JL</td>
<td align="center">SF != OF</td>
<td align="center">小于则跳转</td>
</tr>
<tr>
<td align="center">JNGE</td>
<td align="center">SF != OF</td>
<td align="center">不大于等于则跳转</td>
</tr>
<tr>
<td align="center">JNL</td>
<td align="center">SF == OF</td>
<td align="center">不小于则跳转</td>
</tr>
<tr>
<td align="center">JGE</td>
<td align="center">SF == OF</td>
<td align="center">不大于等于则跳转</td>
</tr>
<tr>
<td align="center">JLE</td>
<td align="center">ZF != OF或ZF == 1</td>
<td align="center">小于等于则跳转</td>
</tr>
<tr>
<td align="center">JNG</td>
<td align="center">ZF != OF或ZF == 1</td>
<td align="center">不大于则跳转</td>
</tr>
<tr>
<td align="center">JNLE</td>
<td align="center">SF == OF且ZF == 0</td>
<td align="center">不小于等于则跳转</td>
</tr>
<tr>
<td align="center">JG</td>
<td align="center">SF == OF且ZF == 0</td>
<td align="center">大于则跳转</td>
</tr>
</tbody></table>
<h2 id="表达式短路"><a href="#表达式短路" class="headerlink" title="表达式短路"></a>表达式短路</h2><p>表达式短路通过逻辑与运算和逻辑或运算使语句根据条件在执行时发生中断，从而不予执行后面的语句。是根据逻辑与和逻辑或运算的特性，如果是与运算，当运算符左边的语句块为假值时，则直接返回假值，不执行右边的语句;如果是或运算，当运算符左边的语句块为真值时，直接返回真值，不执行右边的语句块  </p>
<p><strong>汇编代码如下</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：递归函数，用于计算整数累计，nNumber为累加值</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">&#x2F;&#x2F;当nNumber等于0时，逻辑与运算符左边的值为假，不会执行右边的语句</span><br><span class="line">&#x2F;&#x2F;形成表达式短路，从而找到递归出口</span><br><span class="line">nNumber &amp;&amp; (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">return nNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">nNumber &amp;&amp; (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">&#x2F;&#x2F;这里为短路模式汇编代码，比较变量nNumber是否等于0</span><br><span class="line">0040BAA8	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;通过JE跳转，检查ZF标记位等于1跳转</span><br><span class="line">0040BAAC	je	Accumulation+35h (0040bac5)</span><br><span class="line">&#x2F;&#x2F;跳转失败，进入递归调用</span><br><span class="line">0040BAAE	mov	eax,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;对变量nNumber减1后，结果作为参数压栈</span><br><span class="line">0040BAB1	sub	eax,1</span><br><span class="line">0040BAB4	push eax</span><br><span class="line">&#x2F;&#x2F;继续调用自己，形成递归</span><br><span class="line">0040BAB5	call @ILT+30(Accumulation) (00401023)</span><br><span class="line">0040BABA	add esp,4</span><br><span class="line">0040BABD	mov ecx,dword ptr [ebp+8]</span><br><span class="line">0040BAC0	add ecx,eax</span><br><span class="line">0040BAC2	mov dword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;返回变量nNumber</span><br><span class="line">return nNumber</span><br><span class="line">0040BAC5	mov eax,dword ptr [ebp+8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个递归函数的出口是逻辑式“&amp;&amp;”的左侧判断。逻辑运算“||”虽然与逻辑运算“&amp;&amp;”有些不同，但它们的构成原理相同，只需稍作修改就可以解决上方代码的问题，<strong>代码如下</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，和上面的类似</span><br><span class="line">int Accumulation (int nNumber)&#123;</span><br><span class="line">&#x2F;&#x2F;当nNumber等于0时，逻辑或运算符的左边如果为真就不执行右边的语句</span><br><span class="line">&#x2F;&#x2F;形成表达式短路，从而找到递归的出口</span><br><span class="line">(nNumber &#x3D;&#x3D; 0) || (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">return nNumber;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">(nNumber &#x3D;&#x3D; 0) || (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">00401618	cmp	dword ptr [ebp+8],0</span><br><span class="line">0040161C	je Acumulation+35h (00401635)</span><br><span class="line">0040161E	mov	eax,dword ptr [ebp+8]</span><br><span class="line">00401621	sub	eax,1</span><br><span class="line">00401624	push eax</span><br><span class="line">00401625	call @ILT+30(Accumulation) (00401023)</span><br><span class="line">0040162A	add	esp,4</span><br><span class="line">0040162D	mov ecx,dword ptr [ebp+8]</span><br><span class="line">00401630	add	ecx,eax</span><br><span class="line">00401632	mov	dword ptr [ebp+8],ecx</span><br><span class="line">return nNumber</span><br><span class="line">00401635	mov eax,dword ptr [ebp+8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>条件表达式也称为三目运算：<br>            表达式1 ? 表达式2 : 表达式3<br>这个意思是如果表达式1是真值，则执行表达式2，如果是假值，则执行表达式3  </p>
<p>表达式1，2，3都可以套用到条件表达式中。条件表达式被套用后，其执行顺序依然是由左向右，自内向外。当表达式2与表达3都为常量时，条件表达式可以被优化:而当表达式2或表达式3中的一个为变量时，条件表达式不可以被优化，会转换成分支结构。当表达式1为-一个常量值时，编译器会在编译期间得到答案，将不会有条件表达式存在，共有四套转换方案  </p>
<ul>
<li>表达式1为简单比较，而表达式2和表达式3两者的差值等于1  </li>
<li>表达式1为简单比较，而表达式2和表达式3两者的差值大于1  </li>
<li>表达式1为复杂比较，而表达式2和表达式3两者的差值大于1</li>
<li>表达式2和表达式3有一个为变量，于是无优化  </li>
</ul>
<p><strong>方案一具体代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，条件表达式</span><br><span class="line">int Condition(int argc , int n)&#123;</span><br><span class="line">&#x2F;&#x2F;比较参数argc是否等于5，真值返回5，假值返回6</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 5 : 6;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编比较</span><br><span class="line">&#x2F;&#x2F;清空eax</span><br><span class="line">00401678	xor eax,eax</span><br><span class="line">0040167A	cmp	dword ptr [ebp+8],5</span><br><span class="line">&#x2F;&#x2F;setne检查ZF标记位，当ZF&#x3D;&#x3D;1，则赋值al为0，反之则赋值al为1</span><br><span class="line">0040167E	setne al</span><br><span class="line">&#x2F;&#x2F;若argc等于5则al&#x3D;&#x3D;0，反之al&#x3D;&#x3D;1，执行这句后，eax正好为5&#x2F;6</span><br><span class="line">00401681	add	eax,5</span><br></pre></td></tr></table></figure>

<p><strong>方案二具体代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，条件表达式</span><br><span class="line">int Condition(int argc , int n)&#123;</span><br><span class="line">&#x2F;&#x2F;比较参数argc是否等于5，真值返回5，假值返回6</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 4 : 10;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编比较</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 4 : 10;</span><br><span class="line">00401678	mov	eax,dword ptr [ebp+8]</span><br><span class="line">0040167B	sub	eax,5</span><br><span class="line">0040167E	neg	eax</span><br><span class="line">00401680	sbb	eax,eax</span><br><span class="line">&#x2F;&#x2F;eax的取值只可能为0或者0xFFFFFFFF</span><br><span class="line">00401682	and	eax,6</span><br><span class="line">00401685	add	eax,4</span><br></pre></td></tr></table></figure>

<p>对于argc == 5这种等职的比较，VC++会使用减法和求补运算来判断是否为真值，如果我们的argc不为5，那么执行sub指令后的eax就不为0，neg的指令会将eax的符号位发生改变，也就是求补的运算，如果eax为0，也就是argc为5的话，那么0进行补+1，也是0，那么CF=0，我们现在假设CF=1的情况，那么执行sbb eax,eax 等同于了 eax-eax-CF 那么eax会变成0xFFFFFFFF，另一个情况就是0，使用eax与6进行与运算，如果eax数值为0xFFFFFFFF那么 想与就是6，相加4就是10，如果是0的情况那么直接就是0+4 = 4  </p>
<p><strong>总结</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">sub reg,A</span><br><span class="line">neg	reg</span><br><span class="line">sbb reg,reg</span><br><span class="line">and reg,B</span><br><span class="line">add reg,C</span><br><span class="line">&#x2F;&#x2F;reg &#x3D;&#x3D; A ? C : B</span><br></pre></td></tr></table></figure>

<p>如果表达式2大于表达式3,那么最后加的数字为一个负数。这是由表达式3减去表达式2得到的数值  </p>
<p><strong>方案三具体代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，条件表达式</span><br><span class="line">int Condition(int argc,int n)&#123;</span><br><span class="line">	return argc &lt; &#x3D; 8 ? 4 ：10；</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编代码</span><br><span class="line">return argc &lt; &#x3D; 8 ? 4 ：10；</span><br><span class="line">&#x2F;&#x2F;清空eax,与方案1类似</span><br><span class="line">00401678	xor	eax,eax</span><br><span class="line">0040167A	cmp	dword ptr [ebp+8],8</span><br><span class="line">&#x2F;&#x2F;根据变量与8进行比较的结果，使用setg指令，当标记位SF&#x3D;OF且ZF&#x3D;0赋值al为1</span><br><span class="line">符号标志位SF（Sign Flag），符号标志SF用来反映运算结果的符号位，他与运算结果的最高位相同</span><br><span class="line">溢出标志位OF（Overflow Flag）：比如有一个杯子，放水放满了再放就出去了，叫溢出，但是怎么区别看起来都是最高位的问题</span><br><span class="line">零标志位ZF（Zero Flag），零标志ZF用来反映运算结果是否为0，如果运算结果为0，则值为1，否则值为0，在判断运算结果是否为0时，可以用此标志位</span><br><span class="line">&#x2F;&#x2F;用于检查变量数据是否大于8，大于则赋值1，小于就赋值0</span><br><span class="line">0040167E	setg al</span><br><span class="line">&#x2F;&#x2F;此时al中只能为0或1，执行自减的操作，eax中为0xFFFFFFFF或0</span><br><span class="line">00401681	dec eax</span><br><span class="line">&#x2F;&#x2F;使用al和0xFA做与运算，eax中是0xFFFFFFFA或者0</span><br><span class="line">&#x2F;&#x2F;2-3&#x3D;0xFFFFFFFA</span><br><span class="line">00401682	and	al,0FAh</span><br><span class="line">&#x2F;&#x2F;由于eax只能有两个结果0xFFFFFFFA(-6)或0，加0x0A后结果比然为4，10</span><br><span class="line">00401684	add	eax，0Ah</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先调整reg为0或者为-1</span><br><span class="line">and     reg, A</span><br><span class="line">add     reg, B</span><br></pre></td></tr></table></figure>

<p>遇到这样的代码块，需要重点考察and前的指令，以辨别真假逻辑的处理方式。对于上例中dec reg这样的指令，之前reg只能是0或者是1，因此这里的dec其实是对reg进行修正，如果原来reg为1, dec后修正为0，否则为ffffff，便于其后的and运算。这时候要根据and前的指令流程分析原来的判定在什么情况下会导致reg为0offfffff或者0，以便于还原。编译器这样做是为了避免产生分支语句。而对于顺序结构，处理器会预读下一条指令，以提高运行效率  </p>
<p><strong>无优化使用分支结果</strong>  </p>
<p>如果表达式2或者表达式3中的值为未知数时候，就无法使用之前的方案去优化，编译器会那招正常的语句流程进行比较和判断，选择对应的表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：条件表达式</span><br><span class="line">int Condition(int argc,int n)&#123;</span><br><span class="line">	return argc ? 8 : n;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编代码</span><br><span class="line">return argc ? 8 : n;</span><br><span class="line">&#x2F;&#x2F;比较变量argc</span><br><span class="line">00401448	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;使用JE跳转，检查变量argc是否等于0，跳转的地址为0x00401457位置</span><br><span class="line">004014CC	je Condition+27 (00401457)</span><br><span class="line">&#x2F;&#x2F;跳转失败说明操作数1为真，将表达式1的值(立即数8)存入局部变量ebp-4中</span><br><span class="line">0040144E	mov dword ptr [ebp-4],8</span><br><span class="line">&#x2F;&#x2F;跳转到返回值赋值处</span><br><span class="line">00401455	jmp Condition+2Dh (00145d)</span><br><span class="line">&#x2F;&#x2F;参数2的数据存入eax中</span><br><span class="line">00401457	mov	eax，dword ptr [ebp+0Ch]</span><br><span class="line">0040145A	mov dword ptr [ebp-4],eax</span><br><span class="line">0040145D	mov	eax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;恢复现场</span><br><span class="line">00401466	ret</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>&lt;&lt;</strong>:左移运算，最高位左移到CF中，最低位补零<br><strong>&gt;&gt;</strong>:右移运算，最高位不变，最低位右移到CF中<br><strong>|</strong>:位或运算，在两个数的相同位上，只要有一个为1，则结果为1<br><strong>&amp;</strong>:位与运算，在两个数的相同位上，只有同时个1，则结果为1<br><strong>^</strong>:异或运算，在两个数的相同位上，当两个值相同时为0，不同时为1<br><strong>~</strong>:取反运算  </p>
<p><strong>位运算——Debug版</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码对应汇编，位运算(有符号数)</span><br><span class="line">&#x2F;&#x2F;左移运算3次</span><br><span class="line">argc &#x3D; argc &lt;&lt; 3;</span><br><span class="line">00401498	mov	eax,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;左移运算对应汇编指令SHL</span><br><span class="line">0040149B	shl	eax,3</span><br><span class="line">0040149E	mov	dword ptr [ebp+8],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，右移运算5</span><br><span class="line">argc &#x3D; argc &gt;&gt; 5;</span><br><span class="line">004014A1	mov	ecx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;右移运算对应汇编指令SAR</span><br><span class="line">004014A4	sar	ecx,5</span><br><span class="line">004014A7	mov	dword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，位或运算，变量argc低16位不变，高16位设置为1</span><br><span class="line">argc &#x3D; argc | 0xFFFF0000</span><br><span class="line">004014AA	mov edx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;位或运算对应汇编指令OR</span><br><span class="line">004014AD	or	edx,0FFFF0000h</span><br><span class="line">004014B3	mov	dword ptr [ebp+8],edx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，将变量argc低16位清0，高位不变</span><br><span class="line">argc &#x3D; argc &amp; 0xFFFF0000</span><br><span class="line">&#x2F;&#x2F;位与运算对应汇编指令AND</span><br><span class="line">004014B9	and eax，0xFFFFh</span><br><span class="line">004014BE	mov	dword ptr [ebp+8],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量argc做异或运算</span><br><span class="line">argc &#x3D; argc ^ 0xFFFF0000</span><br><span class="line">004014C1	mov	ecx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;异或运算对应汇编指令XOR</span><br><span class="line">004014C4	xor ecx,0FFFF0000h</span><br><span class="line">004014CA	mov	dword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，将argc按位取反</span><br><span class="line">argc &#x3D; ~argc;</span><br><span class="line">004014CD	mov	edx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;取反运算对应汇编指令NOT</span><br><span class="line">004014D0	not	edx</span><br><span class="line">004014D2	mov	dword ptr [ebp+8],edx</span><br></pre></td></tr></table></figure>

<p><strong>无符号数位移</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：无符号数位移</span><br><span class="line">int BitOperation(int argc)&#123;</span><br><span class="line">	unsigned int nVar &#x3D; argc;</span><br><span class="line">	nVar &lt;&lt;&#x3D; 3;</span><br><span class="line">	nVar &gt;&gt;&#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码讲解</span><br><span class="line">unsigned int nVar &#x3D; argc;</span><br><span class="line">004016C8	mov	eax,dword ptr [ebp+8]</span><br><span class="line">004016CB	mov	dword ptr [ebp-4],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量nVar左移3位</span><br><span class="line">nVar &lt;&lt;&#x3D; 3;</span><br><span class="line">004016CE	mov	ecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;和有符号数左移一样</span><br><span class="line">004016D1	shl	ecx,3</span><br><span class="line">004016D4	mov	dword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量nVar右移5位</span><br><span class="line">004016D7	mov	edx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;使用shr进行右移位，最高位补0，最低位进CF</span><br><span class="line">004016DA	shr edx,5</span><br><span class="line">004016DD	mov dword ptr [ebp-4],edx</span><br></pre></td></tr></table></figure>

<p>符号数与无符号数的差别在右移运算，有符号数对应的指令为sar，可以保留符号位;无符号数不需要符号位，所以直接使用shr将最高位补0  </p>
<h2 id="编译器使用的优化技巧"><a href="#编译器使用的优化技巧" class="headerlink" title="编译器使用的优化技巧"></a>编译器使用的优化技巧</h2><p><strong>代码优化</strong>:是指为了达到某一种优化目的对程序代码进行变换。这样的变换有一个原则:<strong>变化前和变换后等价</strong>  </p>
<p>就优化目的而论，代码优化一般有四个方向：  </p>
<ul>
<li>执行速度优化</li>
<li>内存存储空间优化</li>
<li>磁盘存储空间优化</li>
<li>编译时间优化</li>
</ul>
<p>编译器的工作过程中可以分为几个阶段:预处理→词法分析→语法分析→语义分析→中间代码生成→目标代码生成。其中，优化的机会一般存在于中间代码生成和目标代码生成这两个阶段。尤其是在中间代码生成阶段所做的优化，这类优化不具备设备相关性，在不同的硬件环境中都能通用，因此编译器设计者广泛采用这类办法  </p>
<ul>
<li><p>常量折叠<br>x = 1 + 2<br>1和2都是常量，所以结果可以预见，直接生成x = 3  </p>
</li>
<li><p>常量传播<br>接上面的代码，其后代码为y = x + 3;由于上例最后生成了x = 3，其结果还是可以预见的，所以直接生成y = 6  </p>
</li>
<li><p>减少变量<br>假设一个 x = i * 2 y = j * 2 if(x&gt;y){}这里的x和y比较等价于i和j的比较，所以如果后面没有引用x，y，那么就会直接去掉x，y，生成 if(i&gt;j)</p>
</li>
<li><p>公共表达式<br>那么假设 x = i * 2，y = i * 2所以 i * 2 叫做公共表达式，可以归并为一个，x = i * 2，y = x  </p>
</li>
<li><p>复写传播<br>类似于常量传播，但是目标变成了变量，示例如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; a;</span><br><span class="line">……</span><br><span class="line">y &#x3D; x + c;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果省略号表示的代码中没有修改变量x，则可以直接用变量a代替x：<br>y = a + c  </p>
<ul>
<li><p>剪去不可达分支<br>如果if作用域内的代码内容永远不会被执行，因此整个if代码块没有存在的理由  </p>
</li>
<li><p>还有顺序语句代替分支，强度削弱，数学变换，代码外提等等  </p>
</li>
</ul>
<h3 id="流水线优化"><a href="#流水线优化" class="headerlink" title="流水线优化"></a>流水线优化</h3><ol>
<li>取指令：CPU从高速缓存或内存中取机器码  </li>
<li>指令译码：分析指令的长度，功能和寻址方式</li>
<li>按寻址方式确定操作数：指令的操作数可以是寄存器，内存单元或者立即数，如果操作数在内存单元里，这一步就要计算出有效地址</li>
<li>取操作数：按操作数存放的位置获得数值，并存放在临时寄存器中</li>
<li>执行指令：由控制单元或者计算单元执行指令规则的操作</li>
<li>存放计算结果</li>
</ol>
<p>来个例子~  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行指令： add	eax,dword ptr ds:[ebx+40DA44]</span><br><span class="line">对应的机器代码： 0383	44DA4000</span><br></pre></td></tr></table></figure>

<p>Intel处理器位小端序排列，数据的高位对应内存的高地址，低位对应内存的低地址  </p>
<p>步骤：取指令，得到第一个十六进制字节：0x03，并且eip+1，译码知道这个指令是加法，但是信息不够，于是乎将0x03放入处理器的指令队列缓存中，取指令得到第二个十六进制字节：0x83，机器码放入处理器的指令队列缓存中，eip+1，译码后知道这个寄存器相对寻址方法的加法，而且参与寻址的寄存器是ebx，存放的目标是eax，后面还有4字节的偏移，指令长度确定后，机器码放入处理器的指令队列，取地址，得到第三个十六进制字节：0x44，这是指令中包含的4字节地址偏移量信息的第一个字节，放入内部暂存区，ebx保存在ALU，准备计算有效的地址，eip+1，之后依次开始取指令0xDA 0x40 0x00 放入寄存器，eip依次+1，这时候eax的值传给ALU，调度MMU，得到内存单元，传送到ALU，计算结果，最后将计算结果存回eax中  </p>
<p><strong>流水线</strong>  </p>
<p>来个例子~  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004010AA	mov	eax,92492493h</span><br><span class="line">004010AF	add	esp,8</span><br></pre></td></tr></table></figure>

<p>执行这段代码，不具备流水线的处理器先读取004010AA处的二进制指令，然后开始译码等操作，这–系列工作的每–步都是需要时间的，比如取指令，内存管理单元开始工作，其他部件闲置等待，等拿到了指令才进行下一步工作。于是，为了提高效率，Intel 公司从486开始就引入了流水线的机制  </p>
<p>引入流水线之后，在第一条流水线执行mov指令的过程中，第二条流水线就可以开始对add执行读取和译码了，Intel采用长流水线设计，把每条指令划分出很多阶段，使得每个步骤的工作内容简单，但这容易取指令错误的时候回滚操作过多，AMD厂商使用多流水线设计，回滚错误少，但电路设计复杂  </p>
<p><strong>注意点</strong>  </p>
<ul>
<li><p>指令相关性<br>对于顺序安排的两条指令，后一条指令的执行依赖前–条指令的硬件资源，这样的情况就是指令相关，如下面的代码所示:<br>add     edx,esi<br>sar     edx,2<br>由于以上两条代码都需要访问并设置edx，因此只能在执行完add edx,esi后才能执行sar edx, 2。这样的情况会存在寄存器的争用，影响并行效率，应尽量避免  </p>
</li>
<li><p>地址相关性  </p>
</li>
</ul>
<p>对于顺序安排的两条指令，前一条指令需要访问并回写到某一地址上，而后一条指令也需要访问这一-地址，这样的情况就是地址相关，如下面的代码所示:  </p>
<p>add     [00401234], esi<br>mov     eax, [00401234]  </p>
<p>由于第一条指令访问的是0x401234地址，那么只能第一条指令操作完后再去执行第二条语句，会影响效率，VC++的O2的release选项生成的代码会考虑流水线执行的工作方式</p>
<p>代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0040101F	push eax</span><br><span class="line">00401020	push offset aNvarone2D ; &quot;nVarOne &#x2F; 2 &#x3D; %d&quot;</span><br><span class="line">00401025	call _printf</span><br><span class="line">0040102A	mov	eax,92492493h</span><br><span class="line">0040102F	add	esp,8</span><br><span class="line">00401032	imul esi</span><br><span class="line">00401034	add edx,esi</span><br><span class="line">00401036	sar edx,2</span><br><span class="line">00401039	mov eax,edx</span><br><span class="line">0040103B	shr eax,1Fh</span><br><span class="line">0040103E	add	edx,eax</span><br></pre></td></tr></table></figure>

<p>恢复栈顶的指令add esp,8，中间有mov eax,92492493h指令，这里为流水线优化，因为后面的imul esi需要设置eax，把计算结果的低位放在eax中，那么中间换成add esp,8防止了寄存器争用，后面的这里的 add edx,esi 与 sar edx,2不能移动是因为，在后面的mov eax,edx 与 edx有关系，如果位置移动的话，我们会出现edx的一个的计算结果不正确，于是乎不能改变顺序  </p>
<h3 id="分支优化"><a href="#分支优化" class="headerlink" title="分支优化"></a>分支优化</h3><p>配合流水线的工作模式，处理器增加了一个分支目标缓冲器，在流水线的工作模式下，如果遇见分支结构，我们就可以利用分支目标缓冲器预测并且读取指令的目标地址，分支目标缓冲器在程序运行的时候将动态记录和调整转移指令的目标地址，可以记录多个地址，进行表格化的管理，当发生转移的时候秒如果分支目标缓冲器中有记录，下一条指令在取指令阶段就会将其作为目标地址，如果我们记录地址不等于实际目标地址，就会被流水线冲刷，用一个分支，多次与邪恶失败，就会更新记录目标地址，所以我们在编写多重循环的时候，要把大循环放在内层，可以增加分支预测的准确度  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i &lt; 10; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;下面每次循环会预测成功9999次</span><br><span class="line">&#x2F;&#x2F;第一次没有预测，最后退出循环的时候预测失败1次</span><br><span class="line">&#x2F;&#x2F;重复10次</span><br><span class="line">for(int j &#x3D; 0 ; j &lt; 10000 ; j++)&#123;</span><br><span class="line">	a[i][j]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i &lt; 10000; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;下面每次循环会预测成功9次</span><br><span class="line">&#x2F;&#x2F;第一次没有预测，最后退出循环的时候预测失败1次</span><br><span class="line">&#x2F;&#x2F;重复10000次</span><br><span class="line">for(int j &#x3D; 0 ; j &lt; 9 ; j++)&#123;</span><br><span class="line">	a[i][j]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高速缓存优化规则"><a href="#高速缓存优化规则" class="headerlink" title="高速缓存优化规则"></a>高速缓存优化规则</h3><ol>
<li><p>数据对齐<br>cache不会保存VA的二进制低位，对于Intel的32位处理器来说，如果访问的地址是4的倍数，则可以直接查询并提取之;如果不是4的倍数，则需要访问多次。因此，VC++编译器在设置变量地址时会按照4字节边界对齐  </p>
</li>
<li><p>数据集中<br>将访问次数多的数据或代码尽量安排在-起，一方面是cache在抓取命中数据时会抓取周围的其他数据;另- -方面是虚拟内存分页的问题，如果数据分散，保留到多个分页中，就会导致过多的虚拟地址转换，甚至会导致缺页中断频繁发生，这些都会影响效率  </p>
</li>
<li><p>减少体积<br>命中率高的代码段应该减少体积，尽量放入cache中，以提高效率  </p>
</li>
</ol>
<p>第四章记录完毕<del>~</del></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++反汇编与逆向分析技术(二)</title>
    <url>/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/</url>
    <content><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(四)  </p>
<a id="more"></a>  
<h1 id="变量在内存中的位置和访问方式"><a href="#变量在内存中的位置和访问方式" class="headerlink" title="变量在内存中的位置和访问方式"></a>变量在内存中的位置和访问方式</h1><ul>
<li><p>变量的作用域</p>
<p>指的是变量在源码中可以被访问到的范围。全局变量属于进程作用域，也就是说，在整个进程中都能够访问到这个全局变量;静态变量属于文件作用域，在当前源码文件内可以访问到:局部变量属于函数作用域，在函数内可以访问到;在“{}”语句块内定义的变量，属于块作用域，只能在定义变量的“{ }”块内访问到。</p>
</li>
<li><p>变量的生命周期</p>
<p>指的是变量所在的内存从分配到释放的这段时间。变量所在的内存被分配后，我们可以形象地将这比喻为变量的生命开始;变量所在的内存被释放后，我们可以将这比喻为变量的消亡。</p>
</li>
</ul>
<h2 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h2><p>在大多数情况下，在PE文件中的只读数据节中，常量的节属性被修饰为不可写，而全局变量和静态变量则在属性为可读写的数据节中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int g_nVariableType &#x3D; 117713190;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">008F19D0 55                   push        ebp  </span><br><span class="line">008F19D1 8B EC                mov         ebp,esp  </span><br><span class="line">008F19D3 81 EC C0 00 00 00    sub         esp,0C0h  </span><br><span class="line">008F19D9 53                   push        ebx  </span><br><span class="line">008F19DA 56                   push        esi  </span><br><span class="line">008F19DB 57                   push        edi  </span><br><span class="line">008F19DC 8D BD 40 FF FF FF    lea         edi,[ebp-0C0h]  </span><br><span class="line">008F19E2 B9 30 00 00 00       mov         ecx,30h  </span><br><span class="line">008F19E7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  </span><br><span class="line">008F19EC F3 AB                rep stos    dword ptr es:[edi]  </span><br><span class="line">008F19EE B9 26 C0 8F 00       mov         ecx,offset _DC5A83E8_main@cpp (08FC026h)  </span><br><span class="line">008F19F3 E8 33 F8 FF FF       call        @__CheckForDebuggerJustMyCode@4 (08F122Bh)  </span><br><span class="line">	scanf_s(&quot;%d&quot;, &amp;g_nVariableType);</span><br><span class="line">008F19F8 68 00 A0 8F 00       push        offset g_nVariableType (08FA000h)  </span><br><span class="line">008F19FD 68 30 7B 8F 00       push        offset string &quot;%d&quot; (08F7B30h)  </span><br><span class="line">008F1A02 E8 4D F7 FF FF       call        _scanf_s (08F1154h)  </span><br><span class="line">008F1A07 83 C4 08             add         esp,8  </span><br><span class="line">	printf(&quot;%d \r\n&quot;, g_nVariableType);</span><br><span class="line">008F1A0A A1 00 A0 8F 00       mov         eax,dword ptr [g_nVariableType (08FA000h)]  </span><br><span class="line">008F1A0F 50                   push        eax  </span><br><span class="line">008F1A10 68 34 7B 8F 00       push        offset string &quot;%d \r\n&quot; (08F7B34h)  </span><br><span class="line">008F1A15 E8 2C F6 FF FF       call        _printf (08F1046h)  </span><br><span class="line">008F1A1A 83 C4 08             add         esp,8  </span><br><span class="line">&#125;</span><br><span class="line">008F1A1D 33 C0                xor         eax,eax  </span><br><span class="line">008F1A1F 5F                   pop         edi  </span><br><span class="line">008F1A20 5E                   pop         esi  </span><br><span class="line">008F1A21 5B                   pop         ebx  </span><br><span class="line">008F1A22 81 C4 C0 00 00 00    add         esp,0C0h  </span><br><span class="line">008F1A28 3B EC                cmp         ebp,esp  </span><br><span class="line">008F1A2A E8 06 F8 FF FF       call        __RTC_CheckEsp (08F1235h)  </span><br><span class="line">008F1A2F 8B E5                mov         esp,ebp  </span><br><span class="line">008F1A31 5D                   pop         ebp  </span><br><span class="line">008F1A32 C3                   ret</span><br></pre></td></tr></table></figure>

<p>通过对代码的分析可知，访问全局变量与访问常量类似——都是通过立即数来访问。由于全局变量在编译期就已经确定了具体的地址，因此编译器在编译的过程中可以计算出一个固定的地址值。而局部变量需要进入作用域内，通过申请栈空间存放，利用栈指针ebp或esp间接访问，其地址是-一个未知可变值，编译器无法预先计算。</p>
<p>全局变量在内存中的地址顺序是<strong>先定义的变量在低地址，后定义变量在高地址。</strong></p>
<p>全局变量的特征：</p>
<ul>
<li>所在地址为数据区，生命周期与所在模块一致</li>
<li>使用立即数间接访问</li>
</ul>
<p>局部变量的特征：</p>
<ul>
<li>所在地址为栈区，生命周期与所在的函数作用域一致</li>
<li>使用ebp或esp间接访问</li>
</ul>
<h2 id="局部静态变量的工作方式"><a href="#局部静态变量的工作方式" class="headerlink" title="局部静态变量的工作方式"></a>局部静态变量的工作方式</h2><p>静态变量分为全局静态变量和局部静态变量。</p>
<p>全局静态变量等价于<strong>编译器限制外部源码文件访问的全局变量。</strong></p>
<p>局部静态变量比较特殊，它不会随作用域的结束而消失，并且在未进人作用域之前就已经存在，其生命周期也和全局变量相同。<strong>局部静态变量会预先被作为全局变量处理，而它的初始化部分只是在做赋值操作。</strong></p>
<p>来个demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：全局变量的访问</span><br><span class="line">void ShowStatic(int nNumber)&#123;</span><br><span class="line">	static int g_snNumber &#x3D; nNumber;				&#x2F;&#x2F;定义局部静态变量，赋值为参数</span><br><span class="line">	printf(&quot;%d \r\n&quot;,g_snNumber);					&#x2F;&#x2F;显示静态变量</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; 5;i++)&#123;</span><br><span class="line">		ShowStatic(i);								&#x2F;&#x2F;循环调用显示局部静态变量的函数，每次传入不同值</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ShowStatic 函数内实现过程</span><br><span class="line">void ShowStatic (int nNumber) &#123;</span><br><span class="line">;在Debug版下保存环境、开辟栈、初始化部分略</span><br><span class="line">static int g_snNumber &#x3D; nNumber;					&#x2F;&#x2F;定义局部静态变量</span><br><span class="line">0040D9D8	xor		eax,eax							;清空eax</span><br><span class="line">;取地址0x004257CC处1字节数据到al中</span><br><span class="line">0040D9DA	mov		al, [&#39; ShowStatic&#39; : :&#39;2&#39;: :$S1 (004257cc) ] </span><br><span class="line">;将eax与数值1做位与运算，eax最终结果只能是0或1</span><br><span class="line">0040D9DF	and		eax,1</span><br><span class="line">0040D9E2	test	eax,eax</span><br><span class="line">;比较eax， 不等于0则执行跳转，跳转到地址0x0040D9FE处</span><br><span class="line">0040D9E4	jne		ShowStatic+3Eh (0040d9fe)</span><br><span class="line">;将之前比较是否为0值的地址取出数据到c1中</span><br><span class="line">0040D9E6	mov		c1,byte ptr [&#39; ShowStatic&#39; ::&#39;2&#39;: :$S1 (004257cc)]</span><br><span class="line">;将c1与数值1做位或运算，cl的最低位将被置1，其他位不变</span><br><span class="line">0040D9EC	or		cl,1</span><br><span class="line">;再将置位后的cl存回地址0x004257CC处</span><br><span class="line">0040D9EF	mov		byte ptr [&#39;ShowStatic&#39; ::&#39;2&#39;::SS1 (004257cc)],cl</span><br><span class="line">;取出参数信息放入edx中</span><br><span class="line">0040D9F5	mov		edx, dword ptr [ebp+8]</span><br><span class="line">;将edx赋值到地址0x004257C8处，即将局部静态变量赋值为edx中保存的数据</span><br><span class="line">0040D9F8 	mov		dword ptr [___sbh_sizeHeaderList+4 (004257c8)] , edx</span><br><span class="line">printf(&quot;%d \r\n&quot;, g_snNumber); &#x2F;&#x2F; 显示局部静态变量中的数据</span><br><span class="line">;局部静态变量的访问，和全局变量的访问方式一样</span><br><span class="line">0040D9FE	mov		eax,[__ sbh_sizeHeaderList+4 (004257c8)]</span><br><span class="line">;printf略</span><br></pre></td></tr></table></figure>

<p>地址0x004257CC中保存了局部静态变量的一个标志，这个标志占位1个字节。通过位运算，将标志中的一位数据置1，以此判断局部静态变量是否已经被初始化过。由于一个静态变量只使用了1位，而1个字节数据占8位，因此这个标志可以同时表示8个局部静态变量的初始状态。通常，在VC++6.0中，标志所在的内存地址在最先定义的局部静态变量地址的附近，如最先定义的整型局部静态变量在地址0x004257C0处，那么标记位通常在地址0x004257C4或0x004257BC处。当同一作用域内超过8个局部静态变量时，下一个标记位将会在第9个定义的局部静态变量地址附近。识别局部静态变量的标志位地址并不是目的，主要是根据这个标志位来区分全局变量与局部静态变量。</p>
<p>但是当局部静态变量被初始化为一个常量值时，这个局部静态变量<strong>在初始化过程中不会产生任何代码</strong>。</p>
<p>由于初始化的数值为常量，即多次初始化不会产生变化。这样无需再做初始化标志，编译器采用了<strong>直接以全局变量方式处理，</strong>优化了代码，提升了效率。虽然转换为了全局变量，但仍然不可以超出作用域访问。那么编译器是如何让其他作用域对局部静态变量不可见的呢?通过<strong>名称粉碎法</strong>，在编译期将静态变量重新命名。</p>
<p>来个总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; reg_flag表示存放初始化标志的寄存器r8，通常使用寄存器中的低位，如al等</span><br><span class="line">;INIT__FLAG表示初始化标记</span><br><span class="line">mov		reg_flag,	INIT_FLAG</span><br><span class="line">; reg_data表示存放静态变量初值的寄存器</span><br><span class="line">mov		reg_data,	mem				; reg_data值为初值，其来源可能因程序不同而不同</span><br><span class="line">test	reg_data,	1\2\8..0x80		;测试标志位</span><br><span class="line">jxx		INIT_END					;跳转成功，表示已经被初始化过</span><br><span class="line">or		reg_flag, 	1\2\8..0x80		;修改标志寄存器中的数据</span><br><span class="line">; STATIC_DATA表示静态变量</span><br><span class="line">mov		STATIC_DATA,reg_data		;初始化静态变量</span><br><span class="line">mov		INIT_FLAG,reg_flag			;修改该静态变量初始化标志位</span><br><span class="line">INIT_END;</span><br></pre></td></tr></table></figure>

<h2 id="堆变量"><a href="#堆变量" class="headerlink" title="堆变量"></a>堆变量</h2><p>new和malloc的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明(Debug 编译选项) ; new与malloc</span><br><span class="line">&#x2F;&#x2F; mal1oc 内部实现</span><br><span class="line">char * pCharMalloc &#x3D; (char*) malloc (10) ;</span><br><span class="line">_CRTIMP void * __cdecl malloc (</span><br><span class="line">	size_t nSize</span><br><span class="line">	)&#123;</span><br><span class="line">		&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">		return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;new内部实现</span><br><span class="line">char * pCharNew &#x3D; new char [10] ;</span><br><span class="line">void * operator new( unsigned int cb ) &#123;</span><br><span class="line">	return _nh_malloc( cb, 1 ) ;</span><br><span class="line">&#125;</span><br><span class="line">void *  __cdecl _nh_malloc (</span><br><span class="line">	size_t nSize,</span><br><span class="line">	int nhFlag</span><br><span class="line">	)&#123;</span><br><span class="line">		&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">		return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆空间的分配类似于商场中的商铺管理，malloc是从商场的空地中划分出一块作为商铺，而new则可以将划分好的商铺直接租用。由于malloc缺少商铺的营业范围规定，因此需要将申请好的堆强制转换以说明其类型方可使用，而new则无需这种操作，直接可以使用。</p>
<p>申请堆空间的过程中调用了函数 _ heap_ alloc_dbg， 其中使用 _CrtMemBlockHeader结构描述了堆空间中的各个成员。在内存中，堆结构的每个节点都是使用双向链表的形式存储的，在 _CrtMemBlockHeader 结构中定义了前指针pBlockHeaderPrev 和后指针pBlockHeaderNext，通过这两个指针就可遍历程序中申请的所有堆空间。成员lRequest记录了当前堆是第几次申请的，例如第10次申请堆操作对应的数值为0x0A; 成员gap为保存堆数据的数组，在Debug版下，这个数据的前后4个字节被初始化为0xFD,用于检测堆数据访问过程中是否有越界访问。 _CrtMemBlockHeader 结构的原型如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _CrtMemBlockHeader&#123;</span><br><span class="line">	struct _CrtMemBlockHeader *pBlockHeaderNext ;	&#x2F;&#x2F;下一块堆空间首地址(实际上指向的是前一次申请的堆信息)</span><br><span class="line">	struct _CrtMemBlockHeader *pBlockHeaderPrev;	&#x2F;&#x2F;上一块堆空间首地址(实际上指向的是后一次申请的堆信息)</span><br><span class="line">	char  * szFileName;</span><br><span class="line">	int	 nLine;</span><br><span class="line">	size_t	nDataSize;								&#x2F;&#x2F;堆空间数据大小</span><br><span class="line">	int  nBlockUse;</span><br><span class="line">	long  lRequest;									&#x2F;&#x2F;堆申请次数</span><br><span class="line">	unsigned char  gap[nNoMansLandSize];			&#x2F;&#x2F;堆空间数据</span><br><span class="line">&#125; _CrtMenBlockHeader;</span><br></pre></td></tr></table></figure>

<p>来个实操，我太懒了直接拿书上的图吧，嘻嘻嘻</p>
<p><img src="P1.jpg" alt="堆空间数据说明"></p>
<p>在图中，内存监视窗口的数据为使用malloc后申请的堆空间数据。new或malloc函数返回的地址为堆数据地址0x00431BF0，堆数据地址减4后，其数据为0xFDFDFDFD,这是往上越界的检查标志。堆数据地址减8后数据为0x2A,表示此堆空间为第0x2A次申请堆操作，说明在其之前多次申请过堆空间。堆数据空间的容量存储在地址0x00431BE0处，该堆空间占10个字节大小。地址0x00431BD0处为上一个堆空间首地址。地址0x00431BD4处的数据为0，表示没有下个一堆空间。在堆数据的末尾也加入了0xFDFDFDFD，这是往下越界的检查标志，这是程序编译方式为Debug版的重要特征之一。</p>
<h1 id="数组和指针的寻址"><a href="#数组和指针的寻址" class="headerlink" title="数组和指针的寻址"></a>数组和指针的寻址</h1><h2 id="数组在函数内"><a href="#数组在函数内" class="headerlink" title="数组在函数内"></a>数组在函数内</h2><p>对于数组的识别，判断数据在内存中是否连续并且类型是否一致，均符合即可将此段数据视为数组。</p>
<p>在C++中，字符串本身就是数组，根据约定，该数组的最后-一个数据统一使用0作为字符串结束符。在VC++ 6.0编译器下，为字符类型的数组赋值(初始化)其实是复制字符串的过程。这里并不是单字节复制，而是每次复制4字节的数据。两个内存间的数据传递需要借用寄存器，而每个寄存器一次性可以保存4字节的数据，如果以单字节的方式复制就会浪费掉3字节的空间，而且多次数据传递也会降低执行效率。如果字符串字节数不满足4的倍数，<strong>最后一次数据复制过程中按照1或者2字节的方式复制。</strong></p>
<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><p>来份代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组作为参数</span><br><span class="line">void Show(char szBuff[])&#123;</span><br><span class="line">	strcpy(szBuff,&quot;Hello,World&quot;);</span><br><span class="line">	printf(&quot;%S&quot;,szBuff);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	char szHello[20] &#x3D; &#123;0&#125;;</span><br><span class="line">	Show(szHello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">; Debug保存环境初始化栈略</span><br><span class="line">char szHe11o[20] &#x3D; &#123;0&#125;;</span><br><span class="line">; ebp-14h为数组szHello首地址，数组初始化为0</span><br><span class="line">0040B7C8	mov		byte ptr [ebp-14h] ,0</span><br><span class="line">0040B7CC	xor		eax,eax</span><br><span class="line">0040B7CE	mov		dword ptr [ebp-13h] ，eax</span><br><span class="line">0040B7D1	mov		dword ptr [ebp-0Fh] ，eax</span><br><span class="line">0040B7D4	mov		dword ptr [ebp-0Bh] ，eax</span><br><span class="line">0040B7D7	mov		dword ptr [ebp-7h] ，eax</span><br><span class="line">0040B7DA	mov		word ptr [ebp-3h] ，ax</span><br><span class="line">0040B7DE	mov		byte ptr [ebp-1h] ，al</span><br><span class="line">Show(szHello);</span><br><span class="line">0040B7E1	lea		ecx,[ebp-14h]				;取数组首地址存入ecx</span><br><span class="line">0040B7E4	push	ecx	</span><br><span class="line">0040B7E5	call	@ILT+5 (Show) (0040100a) 	;调用Show函数</span><br><span class="line">0040B7EA	add		esp,4</span><br><span class="line">; 略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Show函数实现部分</span><br><span class="line">void Show (char szBuff []) &#123;</span><br><span class="line">strcpy (szBuff, &quot;Hello world&quot;) ;</span><br><span class="line">;获取常量首地址，并将此地址压入栈中作为strcpy参数</span><br><span class="line">0040B488	push	offset string &quot;Hello world&quot; (0041f01c)</span><br><span class="line">;取函数参数 szBuff地址存入eax中</span><br><span class="line">0040B48D	mov		eax , dword ptr [ebp+8]</span><br><span class="line">;将eax压栈作为strcpy参数</span><br><span class="line">0040B490	push	eax</span><br><span class="line">0040B491	call	strcpy (00404570)</span><br><span class="line">0040B496	add		esp,8</span><br><span class="line">printf(szBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组作为参数时，数组的下标值被省略了。这是因为，当数组作为函数形参时，函数参数中保存的是数组的首地址，是一个指针变量。</p>
<p>在release版下，字符串处理函数会被作为内联函数编译处理，康康：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码对照</span><br><span class="line">int GetLen (char szBuff[] ) &#123;</span><br><span class="line">	return strlen(szBuff);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用O2选项后的优化代码</span><br><span class="line">sub_401000 proc near							;函数起始处</span><br><span class="line">arg_0 &#x3D; dword ptr 4								;参数标号</span><br><span class="line">push	edi</span><br><span class="line">mov		edi, [esp+4+arg_0]						;获取参数内容，向edi中赋值字符串首地址</span><br><span class="line">or		ecx,0FFFFFFFFh							;将ecx置为-1，是为了配合repne scasb指令</span><br><span class="line">xor		eax,eax</span><br><span class="line">;repne&#x2F;repnz与scas指令结合使用，表示串未结束(ecx!&#x3D;0)</span><br><span class="line">;当eax与串元素不相同(ZF&#x3D;0)时，继续重复执行串搜索指令</span><br><span class="line">;可用来在字符串中查找和eax值相同的数据位置</span><br><span class="line">repne scasb										;执行该指令后，ecx中保存了字符串长度的补码</span><br><span class="line">not		ecx										;先对ecx取反</span><br><span class="line">dec		ecx										;对取反后的ecx减1,得到字符串长度</span><br><span class="line">pop		edi						</span><br><span class="line">mov		eax,ecx									;设置eax为字符串长度，用于函数返回</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp									;函数终止处</span><br></pre></td></tr></table></figure>

<p>​    这个实现过程为先将eax清零，然后通过指令repne scasb遍历字符串，寻找和eax匹配的字符。由于指令repne scasb中的前缀repne是用来考察ecx的值，因此在ecx不为0且ZF标志为0时才重复操作，在操作过程中对ecx自动减1。</p>
<p>​    ecx的初始值为0xffffffff，有符号数值为-1，repne前缀每次执行时会自动减1，如果edi指向的内容为字符串结束符(asc 值0),则重复操作结束。注意，重复操作完成时ecx的计数包含了字符串末尾的0。假设字符串长度为Len,我们可得到等式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ecx(终值) &#x3D; ecx(初值) - (Len+1)</span><br><span class="line">将ecx初值 -1 代入得：</span><br><span class="line">ecx(终值) &#x3D; -1 - (Len+1) &#x3D; -(Len+2)</span><br><span class="line">定义neg为求补运算，则有:</span><br><span class="line">neg(ecx(终值)) &#x3D; Len + 2</span><br><span class="line">求补运算等价于取反加1，定义not为取反运算，则有:</span><br><span class="line">neg(ecx(终值))+1 &#x3D; Len + 2</span><br><span class="line">解方程求Len:</span><br><span class="line">Len &#x3D; not(ecx(终值)) - 1</span><br></pre></td></tr></table></figure>

<p>那strcpy函数原型也比较好分析了，release版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;main函数讲解略</span><br><span class="line">;Show函数实现</span><br><span class="line">;int __cdecl sub_401000 (char *Format) 				;函数类型识别</span><br><span class="line">sub_401000 proc near</span><br><span class="line"></span><br><span class="line">Format &#x3D; dword ptr 4								;函数参数识别</span><br><span class="line">push	esi</span><br><span class="line">push	edi</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;这段代码似曾相识，就是之前所分析的优化后的求字符串长度函数strlen的内联方式</span><br><span class="line">mov 	edi,offset aHelloWorld 						;&quot;Hello World&quot;</span><br><span class="line">or		ecx,0FFFFFFFFh</span><br><span class="line">xor		eax,eax</span><br><span class="line">repne scasb</span><br><span class="line">mov		eax,[esp+8+Format]							;取参数所在地址存入eax中</span><br><span class="line">not		ecx											;对ecx取反，得到字符串长度加1</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;执行指令repne scasb后，edi指向字符串末尾，减去ecx重新指向字符串首地址</span><br><span class="line">sub		edi,ecx</span><br><span class="line">push	eax											;将保存参数地址eax压栈</span><br><span class="line">mov		edx,ecx										;使用edx保存常董字符串长度</span><br><span class="line">mov		esi,edi										;将esi设置为常量字符串首地址</span><br><span class="line">mov 	edi,eax										;将edi设置为参数地址</span><br><span class="line">shr		ecx,2										;将ecx右移2位等同于将字符串长度除以4</span><br><span class="line">;此指令为拷贝字符串，每次复制4字节长度，根据ecx中的数值决定复制次数。将esi中的指向数据每次以4字节复制到edi所指向的内存中，每次复制后，esi与edi自加4</span><br><span class="line">rep movsd</span><br><span class="line">mov		ecx,edx										;重新将字符串长度存入ecx中</span><br><span class="line">;将ecx与3做位与运算，等同于ecx对4求余</span><br><span class="line">and 	ecx,3</span><br><span class="line">;和rep movsd指令功能奥似，不过是按单字节复制字符串</span><br><span class="line">rep	movsb</span><br><span class="line">call	_printf</span><br><span class="line">add		esp,4</span><br><span class="line">pop 	edi</span><br><span class="line">pop		esi</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>

<h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>​    数组作为函数得返回值与作为函数的参数差不多，都是将数组的首地址以指针的方式进行传递。不同点是当数组作为参数时，其定义所在的作用域必然在函数调用以外，在调用前已经存在，所以，在函数中对数组进行操作是没有问题的，而数组作为函数返回值则存在着一定的风险。</p>
<p>当数组为局部变量数据时，便产生了稳定性问题。当退出函数时，需要平衡栈，而数组是作为局部变量存在，其内存空间在当前函数的栈内。如果此时函数退出，栈中定义的数据将变得不稳定。由于函数退出后esp会回归到调用前的位置上，而函数内的局部数组在esp之下，随时都有可能由在其他函数的调用过程中产生的<strong>栈操作指令将其数据破坏</strong>。数据的破坏将导致函数返回结果具备不确定性，影响程序的结果，如图所示。</p>
<p><img src="P2.jpg" alt="栈平衡错误"></p>
<p>在图中，返回了函数GetNumber中定义的局部数组的首地址nArray,其所在地址处于0x0012FF00~0x0012FF1C之间。当函数调用结束后，栈顶指向了地址0x0012FF1C。此时数组nArray中的数据已经不稳定，任何栈操作都有可能将其破坏。</p>
<p>在执行“print(“%d”, pAray[7]);”后，由于需要将参数压栈，地址0x0012FF1C~0x0012FF18之间的数据已经被破坏，无法输出正常结果。</p>
<p>如果既想使用数组作为返回值，又要避免图中的错误，可以使用全局数组、静态数组或是上层调用函数中定义的局部数组。</p>
<p>well，全局数组就是很常见的那种，懒得放了，看一下静态数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">	int nOne;</span><br><span class="line">	int nTwo;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">	static int g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">int nOne;</span><br><span class="line">int nTwo;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">static in g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">0040B84D	xor		edx,edx</span><br><span class="line">0040B84F	mov		dl,byte ptr [&#39;main&#39; ::&#39;2&#39; :: $Sl (004237c8)]</span><br><span class="line">0040B855	and		edx,1</span><br><span class="line">0040B858	test	edx,edx</span><br><span class="line">0040B85A	jne		main+70h (0040b890)				;检测初始化标志位</span><br><span class="line">0040B85C	mov		al, [&#39;main&#39; :: &#39;2&#39; :: $S1 (004237c8) ]</span><br><span class="line">0040B861	or		al,1</span><br><span class="line">;将初始化标志位置1</span><br><span class="line">0040B863	mov		[&#39;main&#39; : : &#39;2&#39;: :$S1 (004237c8)] ,al</span><br><span class="line">0040B868	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">0040B86B	mov		dword ptr [&#39;main&#39; :: &#39;2&#39;::$S1+4 (004237cc)] , ecx</span><br><span class="line">0040B871	mov		edx, dword ptr [ebp-8]</span><br><span class="line">0040B874	mov		dword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+8 (004237d0)] , edx</span><br><span class="line">0040B87A	mov		dword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+0Ch (004237d4)] , 0</span><br><span class="line">0040B884	xor		eax,eax</span><br><span class="line">0040B886	mov		[&#39;main&#39; :: &#39;2&#39; : : $S1+10h (004237d8)] ,eax</span><br><span class="line">0040B88B	mov		[&#39;main&#39; :: &#39;2&#39; : : $S1+14h (004237dc)] , eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标寻址和指针寻址"><a href="#下标寻址和指针寻址" class="headerlink" title="下标寻址和指针寻址"></a>下标寻址和指针寻址</h2><p>下标访问(寻址): a[n]        <strong>效率高</strong></p>
<p>指针访问(寻址): *(a+n)</p>
<p>看一下区别，Debug版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：两种寻址方式演示</span><br><span class="line">void main()&#123;</span><br><span class="line">	char *pChar &#x3D; NULL;</span><br><span class="line">	char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">	pChar &#x3D; szBuff;</span><br><span class="line">	printf(&quot;%c&quot;,*pChar);</span><br><span class="line">	printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main()&#123;</span><br><span class="line">char *pChar &#x3D; NULL;</span><br><span class="line">004010F8	mov		dword ptr [ebp-4] ,0				;初始化指针变量为空指针</span><br><span class="line">char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">004010FF	mov		eax, [string &quot;Hel1o&quot; (00420030)]	;初始化数组</span><br><span class="line">00401104	mov		dword ptr [ebp-0Ch] , eax</span><br><span class="line">00401107	mov		cx,word ptr [string &quot;He11o&quot;+4 (00420034)]</span><br><span class="line">0040110E	mov		word ptr [ebp-8] ,Cx</span><br><span class="line"></span><br><span class="line">pChar &#x3D; szBuff;</span><br><span class="line">00401112	lea		edx, [ebp-0Ch]						;荻取数组首地址，然后使用edx保存</span><br><span class="line">00401115	mov		dword ptr [ebp-4] , edx</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,*pChar);</span><br><span class="line">00401118	mov		eax, dword ptr [ebp-4] 				;取出指针变量中保存的地址数据</span><br><span class="line">0040111B	movsx	ecx,byte ptr [eax]					;字符型指针的间接访问</span><br><span class="line">0040111E	push 	ecx</span><br><span class="line">0040111F	push	offset string &quot;%C&quot; (0042002c)</span><br><span class="line">00401124	call 	printf(00401170)</span><br><span class="line">00401129	add 	esp,8</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">;直接从地址ebp-0Ch处取出1字节的数据</span><br><span class="line">0040112C	movsx	edx,byte ptr [ebp-0Ch]</span><br><span class="line">00401130	push	edx									;将取出数据作为参数</span><br><span class="line">00401131	push	offset string &quot;%c&quot; (0042002c)</span><br><span class="line">00401136	call	printf(00401170)</span><br><span class="line">0040113B	add		esp,8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针寻址比下标寻址多一次寻址操作，效率自然低，但是指针寻址可以修改地址中保存的数据，访问其他内存中的数据，而数组下标在没有越界使用的情况下只能访问数组内的数据。</p>
<p>下标值的三种表现方式</p>
<ol>
<li><p>下标值为整型常量的寻址</p>
<p>编译器可以直接计算出数据所在的地址</p>
</li>
<li><p>下标值为整型变量的寻址</p>
<p>编译器先进行地址偏移计算，然后得出目标数据所在的地址</p>
</li>
<li><p>下标值为整型表达式的寻址</p>
<p>会先计算出表达式的结果，然后将其结果作为下标值</p>
</li>
</ol>
<p>顺带一提，数组越界就是下标越范围，蛮好懂的</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组在内存中的存储方式和一维数组是一样的，但在<strong>寻址方面</strong>，二维数组的寻址过程比一维数组多一步操作，先取得二维数组中某个一维数组的首地址，再利用此地址作为基址寻址到一维数组中某个数据地址处。</p>
<p>若其中某一下标值为常量，则不会出现二次寻址计算，二维数组寻址转换成汇编后的代码和一维数组差不多，因为下标值为常量，且类型大小可预先计算出，因此变成两常量计算。利用常量折叠可直接计算出偏移地址。</p>
<p>来个release版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">004B1090 55                   push        ebp  </span><br><span class="line">004B1091 8B EC                mov         ebp,esp  </span><br><span class="line">004B1093 83 EC 2C             sub         esp,2Ch  </span><br><span class="line">004B1096 A1 04 30 4B 00       mov         eax,dword ptr ds:[004B3004h]  </span><br><span class="line">004B109B 33 C5                xor         eax,ebp  </span><br><span class="line">004B109D 89 45 FC             mov         dword ptr [ebp-4],eax  </span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	int nArray[4] &#x3D; &#123; 1,2,3,4 &#125;;</span><br><span class="line">004B10A0 0F 28 05 40 21 4B 00 movaps      xmm0,xmmword ptr ds:[004B2140h]  </span><br><span class="line">	int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">	scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10A7 8D 45 F4             lea         eax,[ebp-0Ch]  </span><br><span class="line">	int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">	scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10AA 50                   push        eax  </span><br><span class="line">004B10AB 8D 45 F8             lea         eax,[ebp-8]  </span><br><span class="line">004B10AE C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0  </span><br><span class="line">004B10B5 50                   push        eax  </span><br><span class="line">004B10B6 68 08 21 4B 00       push        4B2108h  </span><br><span class="line">004B10BB C7 45 F4 00 00 00 00 mov         dword ptr [ebp-0Ch],0  </span><br><span class="line">004B10C2 0F 11 45 E4          movups      xmmword ptr [ebp-1Ch],xmm0  </span><br><span class="line">004B10C6 0F 11 45 D4          movups      xmmword ptr [ebp-2Ch],xmm0  </span><br><span class="line">004B10CA E8 81 FF FF FF       call        004B1050  </span><br><span class="line">	printf(&quot;nArray &#x3D; %d\r\n&quot;, nArray[i]);</span><br><span class="line">004B10CF 8B 45 F8             mov         eax,dword ptr [ebp-8]  </span><br><span class="line">004B10D2 FF 74 85 E4          push        dword ptr [ebp+eax*4-1Ch]  </span><br><span class="line">004B10D6 68 10 21 4B 00       push        4B2110h  </span><br><span class="line">004B10DB E8 40 FF FF FF       call        004B1020  </span><br><span class="line">	printf(&quot;nTwoArray &#x3D; %d\r\n&quot;, nTwoArray[i][j]);</span><br><span class="line">004B10E0 8B 4D F8             mov         ecx,dword ptr [ebp-8]  </span><br><span class="line">004B10E3 8B 45 F4             mov         eax,dword ptr [ebp-0Ch]  </span><br><span class="line">004B10E6 8D 04 48             lea         eax,[eax+ecx*2]  </span><br><span class="line">004B10E9 FF 74 85 D4          push        dword ptr [ebp+eax*4-2Ch]  </span><br><span class="line">004B10ED 68 20 21 4B 00       push        4B2120h  </span><br><span class="line">004B10F2 E8 29 FF FF FF       call        004B1020  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个”eax+ecx*2”保存了二维数组的两个下标值：i、j。寻址过程如下：</p>
<p>1)使用数组首地址加二维数组下标i乘以-维数组大小，得到一维数组首地址。<br>2)通过1)获取一维数组首地址后，加下标j乘以类型大小，得到的数据如下:<br>二维数组type nArry[M][N];使用i、j作为下标寻址<br>nArray + i * sizeof(type [N]) + j * sizeof(type)<br>= nArray+i* N * sizeof(type) +j * sizeof(type)<br>= nArray + sizeof(type)*(i *N +j)</p>
<p>三维数组类似，不列举了</p>
<h2 id="存放指针类型数据的数组"><a href="#存放指针类型数据的数组" class="headerlink" title="存放指针类型数据的数组"></a>存放指针类型数据的数组</h2><p><strong>存放指针类型的数据的数组</strong>就是数组中各数据元素都是由相同类型指针组成。</p>
<table>
<thead>
<tr>
<th align="center">组成部分1</th>
<th align="center">组成部分2</th>
<th align="center">组成部分3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型名*</td>
<td align="center">数组名称</td>
<td align="center">[元素个数]</td>
</tr>
</tbody></table>
<p>举个栗子，存储三个字符串”Hello”,”World”,”!\r\n”，指针数组是一维的，存储的是字符串的首地址，字符数组是二维的，将每个字符存储进去</p>
<p>这样寻址的时候，会发生差异：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	printf(pBuff[1]);</span><br><span class="line">01001958 B8 04 00 00 00       mov         eax,4  </span><br><span class="line">0100195D C1 E0 00             shl         eax,0  </span><br><span class="line">01001960 8B 4C 05 EC          mov         ecx,dword ptr [ebp+eax-14h]  ;一维数组寻址</span><br><span class="line">01001964 51                   push        ecx  </span><br><span class="line">01001965 E8 DC F6 FF FF       call        01001046  </span><br><span class="line">0100196A 83 C4 04             add         esp,4  </span><br><span class="line">	printf(cArray[1]);</span><br><span class="line">0100196D B8 0A 00 00 00       mov         eax,0Ah  </span><br><span class="line">01001972 C1 E0 00             shl         eax,0  </span><br><span class="line">01001975 8D 4C 05 C4          lea         ecx,[ebp+eax-3Ch]  </span><br><span class="line">01001979 51                   push        ecx  </span><br><span class="line">0100197A E8 C7 F6 FF FF       call        01001046  </span><br><span class="line">0100197F 83 C4 04             add         esp,4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符数组寻址后得到的是某一维数组的首地址</p>
<h2 id="指向数组的指针变量"><a href="#指向数组的指针变量" class="headerlink" title="指向数组的指针变量"></a>指向数组的指针变量</h2><p>当指针变量保存的数据为数组的首地址，且将此地址解释为数组时，此指针变量被称为数组指针。</p>
<p>指向一维数组的数组指针定义格式：</p>
<table>
<thead>
<tr>
<th align="center">组成部分1</th>
<th align="center">组成部分2</th>
<th align="center">组成部分3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[类型名]</td>
<td align="center">[*指针变量名称]</td>
<td align="center">[一维数组大小]</td>
</tr>
</tbody></table>
<p>对指向二维数组的数组指针执行取内容操作后，得到的还是一个地址值，再次执行取内容操作才能寻址到二维字符数组中的单个字符数据。看上去与二级指针相似，实际上并不一样。二级指针的类型为指针类型，其偏移长度在32位下固定为4字节，而数组指针的类型为数组，其偏移长度随数组而定，两者的偏移计算不同，不可混为一谈。</p>
<p>main函数的三个参数(main(int argc,char *argv[],char *envp[]))分别为：</p>
<ol>
<li>argc:命令行参数个数，整型。</li>
<li>argv:命令行信息，保存字符串数组首地址的指针变量，是一个指向数组的指针。</li>
<li>envp:环境变量信息，和argv类型相同。</li>
</ol>
<p>来个main函数参数的demo看一看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main(int argc, char **argv, char **envp &#125; &#123;</span><br><span class="line">for(inti&#x3D;1;i&lt;argc;i++)&#123;</span><br><span class="line">printf (argv[i]) ;</span><br><span class="line">00401112	mov		edx, dword ptr [ebp-4]		 ;取下标值i并将其保存到edx中</span><br><span class="line">;对指针变量取内容，得到数组首地址</span><br><span class="line">00401115	mov		eax, dword ptr [ebp+0Ch]</span><br><span class="line">;一维数组寻址，将得到的数组数据保存到ecx中</span><br><span class="line">00401118	mov		ecx, dword ptr [eax+edx*4]</span><br><span class="line">0040111B	push	ecx</span><br><span class="line">0040111C	call	printf(00401160)</span><br><span class="line">00401121	add		esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argv是一个参数，保存着字符串数组的首地址，因此需要”mov eax,dword ptr[ebp+0Ch]”指令队其取内容，得到数组首地址。</p>
<p>对三维数组 int nArray[2] [3] [4] 可转换成int (*pnArray) [3] [4] = nArray;</p>
<p>指针在地址偏移过程中需要计算出偏移量，因此需要所指向的数据类型来配合计算偏移长度。在多维数组中，可以将最高维看做是- -维 数组，其后数据为这个- -维 数组中各元素的数据类型。所以第一个维数可以省去。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>用于保存函数首地址的指针变量被称为函数指针。函数指针是不允许执行加法和减法运算的</p>
<p>来两份代码看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数指针与函数——Debug版</span><br><span class="line">void __cdecl Show()&#123;</span><br><span class="line">	printf(&quot;Show\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	void (__cdecl *pShow)(void) &#x3D; Show			&#x2F;&#x2F;函数指针赋值</span><br><span class="line">	pShow();				&#x2F;&#x2F;使用函数指针调用函数</span><br><span class="line">	Show();					&#x2F;&#x2F;直接调用函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">void (__cdecl *pShow) (void) &#x3D; Show;</span><br><span class="line">;函数名称即为函数首地址，这是一个常量地址值</span><br><span class="line">0040B90B	mov		dword ptr [ebp-38h] , offset @ILT+15 (Show) (00401014)</span><br><span class="line">0040B915	mov		edx, dword ptr [ebp-38h]</span><br><span class="line">0040B918	mov		dword ptr [ebp-38h] , edx</span><br><span class="line">pShow();</span><br><span class="line">0040B91B	mov		esi,esp</span><br><span class="line">0040B91D	call 	dword ptr [ebp-38h]			;间接调用函数</span><br><span class="line">0040B920	cmp		esi,esp						;栈平衡检查，Debug下特有</span><br><span class="line">0040B922	call	__chkesp (004012d0)			;栈平衡检查，Debug下特有</span><br><span class="line">Show();</span><br><span class="line">0040B927 	call	@ILT+15 (Show) (00401014)	;直接调用函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">带参数和返回值的函数指针——Debug版</span><br><span class="line">&#x2F;&#x2F;C++源码说明:带参数与返回类型的函数指针</span><br><span class="line">int	_stdcall Show(int nShow)&#123;</span><br><span class="line">	printf(&quot;Show : %d\r\n&quot;,nShow);</span><br><span class="line">	return nShow;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	int (__stdcall *pShow)(int) &#x3D; Show;		&#x2F;&#x2F;函数指针定义并初始化</span><br><span class="line">	int nRet &#x3D; pShow(5);					&#x2F;&#x2F;使用函数指针调用函数，并获取返回值</span><br><span class="line">	printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123; </span><br><span class="line">int (__stdcall *pShow) (int) &#x3D; Show;</span><br><span class="line">;初始化过程没有变化，仍然为荻取函数首地址并保存</span><br><span class="line">00408868	mov		dword ptr [ebp-4] ,offset @ILT+20 (Show) (00401019)</span><br><span class="line">0040886F	mov		eax, dword ptr [ebp-4]</span><br><span class="line">00408872	mov		dword ptr [ebp-4] ,eax</span><br><span class="line">int nRet &#x3D; pShow(5);</span><br><span class="line">00408875	mov		esi,esp					;保存进入函数前的栈顶，用于栈顶检查</span><br><span class="line">00408877	push	5						;压入参数5</span><br><span class="line">00408879	call	dword ptr [ebp-4]		;获取函数指针中的地址，间接调用函数</span><br><span class="line">0040887C	cmp		esi,esp					;栈顶检查</span><br><span class="line">00408883	mov		dword ptr [ebp-8],eax	;接收函数返回值数据</span><br><span class="line">printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><p>在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别:结构体的访问控制默认为public，而类的默认访问控制是private。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>一般来说，类对象的计算公式如下：</p>
<p><strong>对象长度 = sizeof(数据成员1) + sizeof(数据成员2) + sizeof(数据成员3) + … + sizeof(数据成员n)</strong></p>
<p>但是会出现以下例外：</p>
<ol>
<li><strong>空类</strong>。空类中没有任何数据成员，按照该公式计算得出的对象长度为0字节。类型长度为0，则此类的对象不占据内存空间。而实际情况是，空类的长度为1字节。如果对象完全不占用内存空间，那么空类就无法取得实例对象的地址，this 指针失效，因此不能被实例化。而类的定义是由成员数据和成员函数组成，在没有成员数据的情况下，还可以有成员函数，因此仍然需要实例化，分配了1字节的空间用于类的实例化，这1字节的数据并没有被使用。</li>
<li><strong>静态数据成员</strong>。当类中的数据成员被修饰为静态时，对象的长度计算又会发生变化。虽然静态数据成员在类中被定义，但它与静态局部变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见，同类对象将共同享有静态数据成员的空间。</li>
<li><strong>内存对齐</strong>。在VC++6.0中，类和结构体中的数据成员是根据它们在类或结构体中出现的顺序来依次申请内存空间的，由于内存对齐的原因，它们并不- -定会像数组那样连续地排列。由于数据类型不同，因此占用的内存空间大小也会不同，在申请内存时，会遵守一定的规则。</li>
</ol>
<p>重点讲一下第三种：</p>
<p>在为结构体和类中的数据成员分配内存时，结构体中的当前数据成员类型长度为M，指定的对齐值为N，那么实际对齐值为q = min(M, N)，其成员的地址安排在q的倍数上。如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Struct tagTEST&#123;</span><br><span class="line">	short sShort;</span><br><span class="line">	int nInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员sShort 的地址为<strong>0x0012FF74</strong>，类型为short,<strong>占2字节</strong>内存空间。VC++ 6.0指定的对齐值默认为8，short 的长度为2，于是实际的对齐值取较小者2。所以，short 被分配在地址0x0012FF74处，此地址是2的倍数，可分配。此时，轮到为第二个数据成员分配内存了，如果分配在sShort后，应在地址0x0012FF76处，但第二个数据成员为int类型，<strong>占4字节</strong>内存空间，与指定的对齐值比较后，实际对齐值取int类型的长度4，而地址0x0012FF76不是4的倍数，<strong>需要插入两个字节填充，以满足对齐条件</strong>，因此第二个数据成员被定义在地址<strong>0x0012FF78</strong>处。</p>
<p>上例讲到了结构体成员对齐值的问题，现在讨论一下对齐值对结构体整体大小的影响。如果按VC++ 6.0默认的8字节对齐，那么结构体的整体大小要能被8整除，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sruct&#123;</span><br><span class="line">	double dDouble;				&#x2F;&#x2F;所在地址: 0x0012FF00~0x0012FF08之间，占8字节</span><br><span class="line">	int nInt;					&#x2F;&#x2F;所在地址: 0x0012FF08~0x0012FF0C之间，占4字节</span><br><span class="line">	short sShort;				&#x2F;&#x2F;所在地址: 0x0012FF0C-0x0012FF10之间，占2字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中结构体成员的总长度为8+4+2=14，按默认的对齐值设置要求，结构体的整体大小<strong>要能被8整除</strong>，于是编译器在最后一个成员sShort所占内存之后<strong>加入2字节空间填补</strong>到整个结构体中，使总大小为8+4+2+2=16,这样就满足了对齐的要求。</p>
<p>但是，并非设定了默认对齐值就将结构体的对齐值锁定。如果结构体中的数据成员类型，最大值为M，指定的对齐值为N,那么实际对齐值为min(M, N),如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Struct&#123;</span><br><span class="line">	char cChar;					&#x2F;&#x2F;应占1字节内存空间，如所在地址为0x0012FF00</span><br><span class="line">	int nInt;					&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;				&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上结构应该按照4字节的方式对齐，其布局格式如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cChar		所在地址; 0x0012FF00~0x0012FF04之间，占4字节，对齐nInt</span><br><span class="line">nInt		所在地址: 0x0012FF04~0x0012FF08之间，占4字节</span><br><span class="line">sShort		所在地址: 0x0012FF08~0x0012FF0C之间，占2字节，另外填充2字节</span><br></pre></td></tr></table></figure>

<p>既然有默认的对齐值，就可以在定义结构体时进行调整，VC++ 6.0中可使用预编译指令#pragma pack(N)来调整对齐大小。修改以上示例，调整对齐值为1，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line">Struct&#123;</span><br><span class="line">	char cChar;					&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">	int nInt;					&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;				&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    调整对齐值后，根据对齐规则，在分配nInt时无需插入空白数据。对齐值为1, nInt 占4字节大小，很明显，使用pack设定的对齐值更小，因此采用对齐值1的倍数来计算分配内存空间的首地址，nInt 只需紧靠在cChar之后即可。这样cChar只占用1字节内存空间。由于设定的对齐值小于等于结构体中所有数据成员的类型长度，因此结构总长度只要是1的倍数即可。在这个例子中，结构总长度为7。</p>
<p>​    使用pack修改对齐值也<strong>并非一定会生效</strong>， 与默认对齐值一样，都需要参考结构体中的数据成员类型。<strong>当设定的对齐值大于结构体中的数据成员类型大小时，此对齐值同样是无效的</strong>。</p>
<p>当结构体中以数组作为成员时，<strong>将根据数组元素的长度计算对齐值，而不是按数组的整体大小去计算</strong>，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	char cChar;				&#x2F;&#x2F;应占1字节内存空间， 如所在地址为0x0012FF00	</span><br><span class="line">	char cArray[4];			&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;			&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    按照对齐规定，cChar 与cArray的对齐没有缝隙，无需插入空白数据，当cArray与sShort进行对齐时，cChar 与cArray在内存中将会占5字节，此时按照结构中当前的数据类型short进行对齐，插入1字节的数据即可，其结构布局如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cChar						所在地址: 0x0012FF00~0x0012FF01之间，占1字节</span><br><span class="line">cArray[4]					所在地址: 0x0012FF01-0x0012FF06之间，占5字节</span><br><span class="line">sShort						所在地址: 0x0012FF06-0x0012FF08之间，占2字节</span><br></pre></td></tr></table></figure>

<p>​    当结构体中出现结构体类型的数据成员时，不会将嵌套的结构体类型的整体长度参与到对齐值计算中，而是以嵌套定义的结构体所使用的对齐值进行对齐，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct tagOne&#123;</span><br><span class="line">	char cChar;				&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">	char cArray[4];			&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;			&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br><span class="line">struct tagTwo&#123;</span><br><span class="line">	int nInt;				&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	tagOne one;				&#x2F;&#x2F;应占8字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    在以上结构中，虽然tagOne结构占8字节大小，但由于其对齐值为2,因此tagTwo结构体中的最大类型便是int,以4作为对齐值。所以，结构tagTwo的总大小并非以8字节对齐的16字节，而是以4字节对齐的12字节。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>指针访问结构体或类成员的公式：</p>
<p>假设type为某个正确定义的结构体或者类，member是type中可以访问的成员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type *p</span><br><span class="line">&#x2F;&#x2F;此处略去p的赋值</span><br><span class="line">&#x2F;&#x2F;以下是整型加法</span><br><span class="line">p-&gt;member的地址 &#x3D; 指针p的地址值 + member在type中的偏移量</span><br></pre></td></tr></table></figure>

<p>举个栗子~如果有以下定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">	int m_int;				&#x2F;&#x2F;在结构体内的偏移量为0 </span><br><span class="line">	float m_float;			&#x2F;&#x2F;在结构体内的偏移量为4</span><br><span class="line">&#125;;</span><br><span class="line">struct A a;					&#x2F;&#x2F;假设这个结构体变量a的地址为0x0012ff00</span><br><span class="line">struct A *pA &#x3D; &amp;a;			&#x2F;&#x2F;定义结构体指针，并赋初值</span><br><span class="line">printf(&quot;%p&quot;,&amp;pA-&gt;m_float);	&#x2F;&#x2F;结果</span><br></pre></td></tr></table></figure>

<p>那么pA-&gt;m_float的地址=0x0012ff00 + 4 = 0x0012ff04</p>
<p>ok~，来看一份Debug版的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：类定义以及数据成员的访问</span><br><span class="line">class CTest&#123;</span><br><span class="line">	public:</span><br><span class="line">	void SetNumber(int nNumber)&#123;				&#x2F;&#x2F;公有函数成员</span><br><span class="line">		m_nInt &#x3D; nNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	public:</span><br><span class="line">		int m_nInt;								&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">	CTest Test;</span><br><span class="line">	Test.SetNumber(5);							&#x2F;&#x2F;调用成员函数</span><br><span class="line">	printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);		&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CTest Test;</span><br><span class="line">Test.SetNumber(5);								&#x2F;&#x2F;类对象定义</span><br><span class="line">0040B768 	push	5							;压入参数5</span><br><span class="line">0040B76A	lea		ecx, [ebp-4]				;取出对象Test的首地址存入ecx中</span><br><span class="line">;调用成员函数</span><br><span class="line"></span><br><span class="line">0040B76D	call	@ILT+10 (CTest::SetNumber) (0040100f)</span><br><span class="line">printf (&quot;CTest : %d\r\n&quot;, Test.m_nInt);</span><br><span class="line">;取出对象首地址处4字节的数据m_nInt存入eax中</span><br><span class="line">0040B772	mov		eax, dword ptr [ebp-4]</span><br><span class="line">0040B775	push	eax							;将eax中保存的数据成员m_ nInt向成员函数传参</span><br><span class="line">0040B776	push	offset string &quot;CTest : d\r\n&quot; (0042001c)</span><br><span class="line">0040B77B	call	printf(00401060)</span><br><span class="line">0040B780	add		esp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SetNumber函数讲解</span><br><span class="line">void SetNumber(int nNumber)&#123;					&#x2F;&#x2F; SetNumber成员函数实现</span><br><span class="line">0040B7B0	push	ebp</span><br><span class="line">0040B7B1	mov		ebp,esp</span><br><span class="line">0040B7B3	sub		esp,44h</span><br><span class="line">0040B7B6	push	ebx</span><br><span class="line">0040B7B7	push	esi</span><br><span class="line">0040B7B8	push	edi</span><br><span class="line">0040B7B9	push	ecx							;注意，ecx中保存了对象Test的首地址</span><br><span class="line">0040B7BA	lea		edi,[ebp-44h]</span><br><span class="line">0040B7BD	mov		ecx,11h</span><br><span class="line">0040B7C2	mov		eax,0CCCCCCCCh</span><br><span class="line">0040B7C7	rep stos 	dword ptr [edi]</span><br><span class="line">0040B7C9	pop ecx								;还原ecx</span><br><span class="line">;将ecx中的数据存入ebp-4地址处，该地址处保存着调用对象的首地址，即this指针</span><br><span class="line">0040B7CA	mov		dword ptr [ebp-4],ecx</span><br><span class="line">m_nInt &#x3D; nNumber;</span><br><span class="line">;取出对象的首地址并存入eax</span><br><span class="line">0040B7CD	mov		eax, dword ptr [ebp-4]</span><br><span class="line">;取出参数中的数据并保存到ecx中</span><br><span class="line">0040B7D0	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">;这里是给成员m_ nInt賦值。由于eax是对象的首地址，成员m_ nInt的偏移量为0,如果写成这样可能更容易理解: mov dword ptr [eax+0] ,ecx</span><br><span class="line">0040B7D3	mov		dword ptr [eax] , ecx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用默认的调用约定时，在调用成员函数的过程中，编译器做了一个“小动作”:利用寄存器ecx保存了对象的首地址，并以寄存器传参的方式传递到成员函数中，这便是this指针的由来。这样的默认调用约定称为thiscall。</p>
<p>在VC++的环境下，识别this指针的关键点是在函数的调用过程中使用了ecx作为第一个参数，并且在ecx中保存的数据为对象的首地址，但并非所有的this指针的传递都是如此。thiscall的栈平衡方式与__stdcall相同，都是由被调用方负责平衡。但是，两者在传参的过程中却不一样，声明为thiscall的函数，第一个参数使用寄存器ecx传递，而非通过栈顶传递。而且thiscall并不属于关键字，它是C++中成员函数特有的调用方式，在C语言中是没有这种调用方式的。因此函数无法显式声明为thiscall调用方式，而类的成员函数默认是thiscall调用方式。所以，在分析过程中，如果看到某函数使用ecx传参，且ecx中保留了对象的this指针，以及在函数实现代码内，存在this指针参与的寄存器相对间接访问方式，如[reg+8]，即可怀疑此函数为成员函数。</p>
<p>当使用其他调用方式(如stdcall) 时，this 指针将不再使用ecx传递，而是改用栈传递，举个栗子~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组和局部变量的定义以及初始化</span><br><span class="line">class CTest&#123;</span><br><span class="line">	public:</span><br><span class="line">	void __stcall SetNumber(int nNumber)&#123;				&#x2F;&#x2F;公有函数成员</span><br><span class="line">		m_nInt &#x3D; nNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	public:</span><br><span class="line">		int m_nInt;								&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">	CTest Test;</span><br><span class="line">	Test.SetNumber(5);							&#x2F;&#x2F;调用__stdcall成员函数</span><br><span class="line">	printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);		&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数调用过程</span><br><span class="line">Test.SetNumber(5) ;</span><br><span class="line">0040B808	push	5</span><br><span class="line">0040B80A	lea		eax,[ebp-8]					;荻取对象首地址并存入eax中</span><br><span class="line">0040B80D	push	eax							;将eax作为参数压栈</span><br><span class="line">0040B80E	call	@ILT+15 (CTest::SetNumber) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数SetNumber的实现过程</span><br><span class="line">void __stdcall SetNumber (int nNumber) &#123;</span><br><span class="line">;Debug 初始化过程略</span><br><span class="line">m_nInt &#x3D;  nNumber;</span><br><span class="line">0040B7C8	mov		eax, dword ptr [ebp+8] 		;取出this指针并存入eax中</span><br><span class="line">0040B7CB	mov		ecx, dword ptr [ebp+0Ch]	;取出参数nNumber并存入ecx中</span><br><span class="line">0040B7CE	mov		dword ptr [eax] , ecx		;使用eax取出成员并赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 __ cdecl 调用方式和 __gstdcall 调用方式只是在参数平衡时有所区别，this指针不容易识别。</p>
<p>使用thiscall调用放式的成员函数的要点分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea		ecx,[mem]							;取对象首地址并存入ecx中，要注意观察内存</span><br><span class="line">call	FUN_ADDRESS							;调用成员函数</span><br><span class="line">;在函数调用内，ecx尚未重新赋值之前</span><br><span class="line">mov		XXX,ecx								;发现函数内使用ecx中的数据，说明函数调用前对ecx的赋值</span><br><span class="line">;实际上是在传递参数</span><br><span class="line">;其后ecx中的内容会传递给其他寄存器</span><br><span class="line">mov		[reg+i],XXX 						;发现了寄存器相对间接寻址方式，如果能排除数组访问，那就能说明reg中保存的是结构体或者类对象的首地址</span><br></pre></td></tr></table></figure>

<p>符合以上特点，基本可判定这是调用类的成员函数。通过分析函数代码中访问ecx的方式，并结合内存窗口，以ecx中的值为地址去观察其数据，可以进一-步分析并还原出对象中的各数据成员。</p>
<p>__ stdcall与 __cdecl调用方式的成员函数分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea		reg,[mem]							;取出对象首地址并存入寄存器变量中</span><br><span class="line">push	reg									;将保存对象首地址的寄存器作为参数压栈</span><br><span class="line">call	FUN_ADDRESS							;调用成员函数</span><br><span class="line">;在函数调用内，将第一个函数参数作为指针变量，以寄存器相对间接寻址方式访问</span><br></pre></td></tr></table></figure>

<h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>当类中定义了静态数据成员时，由于静态数据成员和静态变量原理相同(是一个含有作用域的特殊全局变量)，因此该静态数据成员的初值会被<strong>写入编译链接后的执行文件</strong>中。当程序被加载时，操作系统将执行文件中的数据读到对应的内存单元里，静态数据成员便已经存在，而这时类并没有实例对象。所以静态数据成员和对象之间的生命周期不同，并且静态数据成员也不属于某一对象，与对象之间是一对多的关系。静态数据成员仅仅和类相关，和对象无关，多个对象可以共同拥有同一个静态数据成员。</p>
<p>两个对象各自的成员数据在内存中的地址不同，而<strong>静态数据成员的地址却相同</strong>。如图</p>
<p><img src="P3.jpg" alt="普通数据成员和静态数据成员"></p>
<p><strong>在计算类和对象的长度时，静态数据成员不被计算在内。</strong></p>
<p>普通数据成员的地址是一个栈空间地址，而<strong>静态数据成员的是一个常量地址，可通过立即数间接寻址的方式访问</strong>。访问时无需this指针。</p>
<h2 id="对象作为函数参数"><a href="#对象作为函数参数" class="headerlink" title="对象作为函数参数"></a>对象作为函数参数</h2><p>对象作为函数的参数时，其传参过程与数组不同:数组变量的名称代表数组的首地址，而对象的变量名称却不能代表对象的首地址。传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份(复制),将复制的数据作为形参传递到调用函数中使用。</p>
<p>来个栗子~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：参数为对象的函数调用</span><br><span class="line">class CFunTest&#123;</span><br><span class="line">	public:</span><br><span class="line">		int m_nOne;</span><br><span class="line">		int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">	printf(&quot;%d %d\r\n&quot;,FunTest.m_nOne,FunTest.m_nTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	CFunTest FunTest;</span><br><span class="line">	FunTest.m_nOne &#x3D; 1;</span><br><span class="line">	FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">	ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;注意，这里没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">00401098	mov		dword ptr [ebp-8],1				;数据成员m_nOne所在地址为ebp-8</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040109F	mov		dword ptr [ebp-4],2				;数据成员m_nTwo所在地址ebp-4</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">004010A6	mov		eax, dword ptr [ebp-4]</span><br><span class="line">004010A9	push	eax								;传入数据成员m_nTwo</span><br><span class="line">004010AA	mov		ecx, dword ptr [ebp-8] </span><br><span class="line">004010AD	push	ecx								;传入数据成员m_ nOne</span><br><span class="line">004010AE	call	@ILT+10 (ShowFunTest) 0040100f)</span><br><span class="line">004010B3	add		esp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShowFunTest (CFunTest FunTest) &#123;</span><br><span class="line">printf (&quot;%d %d\r\n&quot; , FunTest.m_nOne, FunTest.m_nTwo);</span><br><span class="line">;取出数据成员m_nTwo作为printf函数的第三个参数</span><br><span class="line">00401038	mov		eax, dword ptr [ebp+ 0Ch]</span><br><span class="line">0040103B 	push	eax</span><br><span class="line">;取出数据成员m_nOne作为printf函数的第二个参数</span><br><span class="line">0040103C	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">0040103F	push	ecx</span><br><span class="line">00401040	push	offset string &quot;%d %d\r\n&quot; (0042001c)</span><br><span class="line">00401045	call	printf(00401120)</span><br><span class="line">0040104A	add		esp,0Ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的体积不大，只有两个数据成员，编译器在调用函数传参的过程中分别将对象的两个成员荡产两个int类型数据依次压栈，类对象中的数据成员的传参顺序为:最先定义的数据成员最后压栈，最后定义的数据成员最先压栈。</p>
<p>来看看数组当参数的情况~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明;此代码为修改版，添加了数组成员char m_szName [32]</span><br><span class="line">class CFunTest &#123;</span><br><span class="line">public:</span><br><span class="line">	int m_nOne;</span><br><span class="line">	int m_nTwo;</span><br><span class="line">	char m_szName[32];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">&#x2F;&#x2F;显示对象中各数据成员的信息</span><br><span class="line">printf (&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">	CFunTest FunTest;</span><br><span class="line">	FunTest.m_nOne &#x3D; 1;</span><br><span class="line">	FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">	strcpy(FunTest.m_szName, &quot;Name&quot;);				&#x2F;&#x2F;赋值数据成员数组</span><br><span class="line">	ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">;初始化部分略</span><br><span class="line">printf(&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">00401038	lea		eax,[ebp+10h]					;取成员m_szName的地址</span><br><span class="line">0040103B	push	eax								;将成员m_ szName的地址作为参数压栈</span><br><span class="line">0040103C	mov		ecx,dword ptr [ebp+0Ch]			;取成员m_nTwo中的数据</span><br><span class="line">0040103F	push	ecx								</span><br><span class="line">00401040	mov		edx, dword ptr [ebp+8] 			;取成员m_nOne中的数据</span><br><span class="line">00401043	push	edx	</span><br><span class="line">00401044	push	offset string &quot;%d%d%s\r\n&quot; (0042002c)</span><br><span class="line">00401049	call	printf (00401120)</span><br><span class="line">0040104E	add		esp,10h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对照，main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">0040B7E8	mov		dword ptr [ebp-28h],1 			;数据成员m_nOne所在地址为ebp-28h</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040B7EF	mov		dword ptr [ebp-24h],2 			;数据成员m_nTwo所在地址为ebp-24h</span><br><span class="line">strcpy (FunTest.m_szName, &quot;Name&quot;);</span><br><span class="line">0040B7F1	push	offset string &quot;Name&quot; (0041302c)</span><br><span class="line">0040B7F6	lea		eax,[ebp-20h]					;数组成员m_szName所在地址为ebp-20h</span><br><span class="line">0040B7FE	push	eax</span><br><span class="line">0040B7FF	call	strcpy(00404650)</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">0040B804	add		esp,0FFFFFFEOh					;调整栈顶，抬高32字节</span><br><span class="line">0040B807	mov		ecx,0Ah							;设置循环次数为10</span><br><span class="line">0040B80C	lea		esi,[ebp-28h]					;获取对象的首地址并保存到esi中</span><br><span class="line">0040B80F	mov		edi,esp							;设置edi为当前栈顶</span><br><span class="line">;执行10次4字节内存复制，将esi所指向的数据复制到edi中，类似memcpy的内联方式</span><br><span class="line">0040B811	rep movs 	dword ptr [edi],dword ptr [esi]</span><br><span class="line">0040B813	call	@ILT+10 (ShowFunTest) (0040100f)</span><br><span class="line">0040B818	add		esp,28h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码清单9-6中，在传递类对象的过程中使用了“add esp, 0FFFFFFE0h”来调整栈顶指针esp，0FFFFFEOh 是补码，转换后为-20h,等同于esp-20h。前面讲过，参数变量在传递时，需要向低地址调整栈顶指针esp,此处申请的32字节栈空间，<strong>加上strcpy未平衡的8字节参数空间，都用于存放参数对象FunTest的数据。将对象FunTest中的数据依次复制到申请的栈空间中。</strong></p>
<p>上面两份代码定义的类都没有定义构造函数和析构函数。由于对象作为参数在传递过程中会制作一份对象的复制数据，当向对象分配内存时，如果有构造函数，编译器会再调用一次构造函数，并做一些初始化工作。当代码执行到作用域结束时，局部对象将被销毁，而对象中可能会涉及资源释放的问题，同样，编译器也会再调用一次局部对象的析构函数，从而完成资源数据的释放。</p>
<p>当对象作为函数的参数时，由于重新复制了对象，等同于又定义了一个对象，在某些情况下会调用特殊的构造函数——<strong>拷贝构造函数</strong>。当函数退出时，复制的对象作为函数内的局部变量，将被销毁。当析构函数存在时，则会调用析构函数，这时候会出现问题，来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：涉及资源申请与释放的类的对象</span><br><span class="line">class CMString&#123;</span><br><span class="line">public:</span><br><span class="line">	CMString()&#123;</span><br><span class="line">		m_pString &#x3D; new char[10];			&#x2F;&#x2F;申请堆空间，只要不释放，进程退出前将一直存在</span><br><span class="line">		if(m_pString &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		strcpy(m_pString,&quot;Hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	~CMString()&#123;</span><br><span class="line">		if(m_pString !&#x3D; NULL)&#123;				&#x2F;&#x2F;检查资源</span><br><span class="line">			delete m_pString;				&#x2F;&#x2F;释放空间</span><br><span class="line">			m_pString &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	char *GetString()&#123;</span><br><span class="line">		return m_pString;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char *m_pString;						&#x2F;&#x2F;数据成员定义，保存堆的首地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数CMString类对象的函数</span><br><span class="line">void ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">	printf (MyStringCpy.GetString());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;main函数实现</span><br><span class="line">void main()&#123;								</span><br><span class="line">	CMyString MyString;						&#x2F;&#x2F;类对象定义</span><br><span class="line">	ShowMyString (MyString);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对照，main函数分析</span><br><span class="line">void main()&#123;								</span><br><span class="line">CMyString MyString;	</span><br><span class="line">;获取对象的首地址，放入ecx中作为this指针</span><br><span class="line">0040121D	lea		ecx, [ebp- 10h]</span><br><span class="line">;调用构造函数</span><br><span class="line">00401220	call	@ILT+5 (CMyString::CMyString) (0040100a)</span><br><span class="line">;记录同一作用域内该类的对象个数</span><br><span class="line">00401225	mov		dword ptr [ebp-4],0</span><br><span class="line">ShowMyString (Mystring);</span><br><span class="line">;MyString对象长度为4，一个寄存器单元刚好能存放</span><br><span class="line">;于是eax获取对象首地址处4字节的数据，即数据成员m_pString</span><br><span class="line">0040122C	mov		eax,dword ptr [ebp-10h]	</span><br><span class="line">0040122F	push	eax	</span><br><span class="line">00401230	call	@ILT+15 (ShowMyString) (00401014)</span><br><span class="line">00401235	add		esp,4</span><br><span class="line">&#125;		&#x2F;&#x2F; main函数结束处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">00401238	mov		dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;获取对象首地址，传入ecx作为this指针</span><br><span class="line">0040123F	lea		ecx, [ebp-10h]</span><br><span class="line">;调用析构函数</span><br><span class="line">00401242	call	@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111E    ret</span><br><span class="line">&#x2F;&#x2F;构造函数与析构函数讲解略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ShowMyString函数的实现过程分析</span><br><span class="line">vold ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">004010B0	push	ebp</span><br><span class="line">004010B1	mov		ebp,esp</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;异常链处理过程&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">004010B3	push	0FFh</span><br><span class="line">004010B5	push	offset __ehhandler$?ShowMyString@@YAXVCMyString@@@Z (00410d39)</span><br><span class="line">004010BA	mov		eax,fs:[00000000]	</span><br><span class="line">004010C0	push	eax</span><br><span class="line">004010C1	mov		dword ptr fs:[0],esp</span><br><span class="line">004010C8	sub		esp,40h</span><br><span class="line">004010CB	push	ebx</span><br><span class="line">004010CC	push	esi</span><br><span class="line">004010CD	push	edi</span><br><span class="line">004010CE	lea		edi,[ebp-4Ch]	</span><br><span class="line">004010D1	mov		ecx,10h</span><br><span class="line">004010D6	mov		eax,0CCCCCCCCh</span><br><span class="line">004010DB	rep stos	dword ptr [edi]</span><br><span class="line">004010DD	mov		dword ptr [ebp-4],0 			;作用域内的对象个数</span><br><span class="line">printf(MyStringCpy.GetString());</span><br><span class="line">;取参数1的数据成员m_pString的地址(即对象酋地址)并保存到ecx中作为this指针</span><br><span class="line">;注意，此m_pString地址非main函数中的对象MyString的首地址</span><br><span class="line">004010E4	lea		ecx,[ebp+8]						;取参数1的地址</span><br><span class="line">;调用成员函数GetString, 该方法的讲解略</span><br><span class="line">004010E7	call	@ILT+0 (CMyString::GetString) (00401005)</span><br><span class="line">004010EC	push	eax								;将返回eax中保存的字符串的首地址作为参数压栈</span><br><span class="line">004010ED	call	printf (00401310)</span><br><span class="line">004010F2	add		esp,4</span><br><span class="line">&#125;													&#x2F;&#x2F;ShowMyString函数的结尾处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">004010F5	mov		dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;取参数1的地址，作为this指针调用析构函数</span><br><span class="line">004010FC	lea		ecx,[ebp+8]</span><br><span class="line">004010FF	call	@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111E	ret</span><br></pre></td></tr></table></figure>

<p>在代码中，当对象作为参数被传递时，参数MyStringCpy复制了对象MyString中的数据成员m_pString，产生了两个CMyString类的对象。由于没有编写拷贝构造函数，因此在传参的时候就没有被调用，这个时候编译器以浅拷贝处理，它们的数据成员m_pString都指向了同一个堆地址，如图所示。</p>
<p><img src="P4.jpg" alt="复制对象与原对象对比"></p>
<p>根据图所示，两个对象中的数据成员m_pString指向了相同地址，当函数ShowMyString调用结束后，便会释放对象MyStringCpy，以对象MyStringCpy的首地址作为this指针调用析构函数。在析构函数中，调用delete函数来释放掉对象MyStringCpy的数据成员m_ pString 所保存的堆空间的首地址。但对象MyStringCpy是MyString的复制品，真正的MyString还存在，而数据成员m_pString所保存的堆空间的首地址却被释放，如果出现以下代码便会产生错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMyString MyString;</span><br><span class="line">&#x2F;&#x2F;当该函数调用结束后，对象MyString中的数据成员m_pString所保存的堆空间已经被释放掉，再次使用此对象中的数据成员m_pString便无法得到堆空间的数据</span><br><span class="line">ShowMyString (MyString);</span><br><span class="line">ShowMyString (MyString);					;显示地址中为错误数据</span><br></pre></td></tr></table></figure>

<p>两个方案解决这个问题</p>
<ol>
<li><strong>深拷贝数据</strong>:在复制对象时，编译器会调用一次该类的拷贝构造函数，给编码者一次机会。深拷贝利用这次机会将原对象的数据成员所保存的资源信息也制作一份副本。这样，当销毁复制对象时，销毁的资源是复制对象在拷贝构造函数中制作的副本，而非原对象中保存的资源信息。</li>
<li><strong>设置引用计数</strong>:在进入拷贝构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放掉申请的资源，否则引用计数减1。</li>
</ol>
<h2 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h2><p>对象作为返回值与对象作为参数的处理方式非常类似。对象作为参数时，进入函数前预先将对象使用的栈空间保留出来，并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。</p>
<p>来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：在函数内定义对象并将其作为返回值</span><br><span class="line">class CReturn&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_nNumber;</span><br><span class="line">	int m_nArry[10];</span><br><span class="line">&#125;;</span><br><span class="line">CReturn GetCReturn()&#123;</span><br><span class="line">	CReturn RetObj;</span><br><span class="line">	RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">		RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return RetObj;					&#x2F;&#x2F;返回局部对象</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char* argv[])&#123;</span><br><span class="line">	CReturn objA;</span><br><span class="line">	objA &#x3D; GetCReturn();</span><br><span class="line">	printf(&quot;%d %d %d&quot;,objA.m_nNumber,objA.m_nArry[0],objA.m_nArry[9]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数和析构函数略</span><br><span class="line">&#x2F;&#x2F;main函数代码分析</span><br><span class="line"></span><br><span class="line">void main(int argc, char* argv[]) &#123;</span><br><span class="line">00401290	push	ebp</span><br><span class="line">00401291	mov		ebp,esp</span><br><span class="line">00401293	sub		esp,0C4h				;预留返回对象的栈空间</span><br><span class="line">00401299	push	ebx</span><br><span class="line">0040129A	push	esi</span><br><span class="line">0040129B	push	edi</span><br><span class="line">0040129C	lea		edi,[ebp-0C4h]</span><br><span class="line">004012A2	mov		ecx,31h</span><br><span class="line">004012A7	mov		eax,0CCCCCCCCh</span><br><span class="line">004012AC	rep stos	dword ptr[edi]</span><br><span class="line">CReturn objA;</span><br><span class="line">objA&#x3D; GetCReturn();</span><br><span class="line">004012AE	lea		eax,[ebp- 84h]			;获取返回对象的栈空间首地址</span><br><span class="line">;将返回对象的首地址压入栈中，用于保存返回对象的数据</span><br><span class="line">004012B4	push	eax</span><br><span class="line">;调用函数GetCReturn, 见下文对GetCReturn的实现过程的分析</span><br><span class="line">004012B5	call	@ILT+45 (GetCReturn) (00401032)</span><br><span class="line">004012BA	add		esp,4</span><br><span class="line">;函数调用结束后，eax中保存着地址ebp-84h， 即返回对象的首地址</span><br><span class="line">004012BD	mov		esi,eax 				;将返回对象的首地址存入esi中</span><br><span class="line">004012BF	mov		ecx,0Bh 				;设置循环次数</span><br><span class="line">004012C4	lea		edi,[ebp-58h] 			;获取临时对象的首地址</span><br><span class="line">;每次从返回对象中复制4字节数据到临时对象的地址中，共复制11次</span><br><span class="line">004012C7	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">004012C9	mov		ecx,0Bh 				;重新设置复制次数</span><br><span class="line">004012CE	lea		esi,[ebp-58h] 			;获取临时对象的首地址</span><br><span class="line">004012D1	lea		edi,[ebp-2Ch] 			;获取对象objA的首地址</span><br><span class="line">;将数据复制到对象objA中</span><br><span class="line">004012D4	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;GetCReturn 的实现过程分析</span><br><span class="line">CReturn GetCReturn() &#123;</span><br><span class="line">0040CE90	push	ebp</span><br><span class="line">0040CE91	mov		ebp,esp</span><br><span class="line">0040CE93	sub		esp,70h					;调整栈空间，预留临时返回对象与局部对象的内存空间</span><br><span class="line">0040CE96	push	ebx</span><br><span class="line">0040CE97	push	esi</span><br><span class="line">0040CE98	push	edi</span><br><span class="line">0040CE99	lea		edi,[ebp-70h]</span><br><span class="line">0040CE9C	mov		ecx,1Ch</span><br><span class="line">0040CEA1	mov		eax,0CCCCCCCCh</span><br><span class="line">0040CEA6	rep stos 	dword ptr [edi]</span><br><span class="line">CReturn RetObj;</span><br><span class="line">RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">;为数据成员nNumber賦值0，地址ebp-2Ch便是对象Retobj的酋地址</span><br><span class="line">0040CEA8	mov		dword ptr [ebp-2Ch],0</span><br><span class="line">for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">	RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">0040CED4	jmp		GetCReturn+28h(0040ceb8)	;for循环分析略，直接看退出函数时的处理</span><br><span class="line">return RetObj;</span><br><span class="line">0040CED6	mov		ecx,0Bh					;设置循环次数为11次</span><br><span class="line">0040CEDB	lea		esi,[ebp-2Ch]			;获取局部对象的首地址</span><br><span class="line">0040CEDE	mov		edi,dword ptr [ebp+8] 	;荻取返回对象的首地址</span><br><span class="line">;将局部对象RetObj中的数据复制到返回对象中</span><br><span class="line">0040CEE1	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">0040CEE3	mov		eax,dword ptr [ebp+8] 	;获取返回对象的首地址并保存到eax中，作为返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码演示了函数返回对象的全过程。在调用GetCReturn前，编译器将在main函数中申请的返回对象的首地址作为参数压栈，在函数GetCReturn调用结束后进行了数据复制，将GetCReturn函数中定义的局部对象RetObj的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象objA，从而达到返回对象的目的。因为在这个示例中不存在函数返回后为对象的引用赋值，所以这里的返回对象是临时存在的，也就是C++中的临时对象，作用域仅限于单条语句。</p>
<p>这个临时对象的产生原因主要是C++程序员可能采用这类写法，如GetCReturn().m_nNumber,这只是针对返回对象的操作，而此时函数已经退出，其栈帧也被关闭。函数退出后去操作局部对象显然不合适，因此只能由函数的调用方准备空间，建立临时对象，然后将函数中的局部对象复制给临时对象，再把这个临时对象交给调用方去操作。本例中的objA = GetCReturn();是个赋值运算，由于赋值时GetCReturn函数已经退出，其栈空间已经关闭，同理objA不能直接和函数内局部对象做赋值运算，因此需要临时对象记录返回值以后再来参与赋值。</p>
<p>虽然使用临时对象进行了数据复制，但是同样存在出错的风险。这与对象作为参数时遇到的情况一样，由于使用了临时对象进行数据复制，当临时对象被销毁时，会执行析构函数。如果析构函数中有对资源释放的处理，就有可能造成同一个资源多次释放的错误。</p>
<p>编译器在处理简单的结构体和类结构的时候，开启O2优化后，难以识别他们与局部变量的区别</p>
<p>来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct tagUnknow&#123;</span><br><span class="line">	short m_sShort;</span><br><span class="line">	int m_nInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">;int ___cdec1 main(int arge, const char **argv， const char **envp)</span><br><span class="line">sub		esp,8				</span><br><span class="line">lea		eax,[esp+8+var_8]	;获取局部变量的地址并存入eax中</span><br><span class="line">mov		[esp+8+var_8],3		;赋值局部变量1</span><br><span class="line">push	eax					;将局部变量的地址作为参数传递</span><br><span class="line">mov		[esp+0Ch+var_4],2	;腻值局部变量2</span><br><span class="line">call	sub_401000			;调用函数sub_401000</span><br><span class="line">add		esp,0ch</span><br><span class="line">retn</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">sub_401000 proc near</span><br><span class="line">arg_0 &#x3D; dword ptr 4			;有一个参数</span><br><span class="line">mov		eax,[esp+arg_0]		;获取参数并保存到eax中</span><br><span class="line">;从eax保存的地址中取出2字节数据，结合后面一条指令可推断这是对象成员的寻址，因为参数指针指向的数据类型不一致</span><br><span class="line">movsx	ecx,word ptx [eax]	</span><br><span class="line">mov		edx,[eax+4]			;寄存器相对间接寻址方式，这是对象成员的寻址</span><br><span class="line">push	ecx					;将荻取数据作为参数压栈</span><br><span class="line">push	edx</span><br><span class="line">push	offset aDD</span><br><span class="line">call	printf</span><br><span class="line">add		esp,0Ch</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>

<p>在通常情况下，VC++6.0编译的代码默认<strong>以thiscall方式调用成员函数</strong>，因此会使用ecx来保存this 指针，从而进行参数传递，但并非具有ecx传参的函数就一定是成员函数。当使用__fastcall 时，同样可以在反汇编代码中体现出ecx传参。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;((struct A*)NULL)-&gt; m_ float 不会崩溃，这时求m_ float 的地址，根据前面提出的结构体寻址公式:</span><br><span class="line">p-&gt;member的地址&#x3D;指针p的地址值+ member在type中的偏移量</span><br><span class="line">代入得:</span><br><span class="line">&amp;((struct A*)NULL)-&gt; m_ float&#x3D;0 +4&#x3D;4，这个表达式实际上是求结构体内成员的偏移量。</span><br><span class="line">可以定义如下宏，用于在不产生对象的情况下取得成员偏移量:</span><br><span class="line">#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)</span><br></pre></td></tr></table></figure>

<p>这个结束了~</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++反汇编与逆向分析技术</title>
    <url>/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》</p>
<a id="more"></a>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="IDA函数识别"><a href="#IDA函数识别" class="headerlink" title="IDA函数识别"></a>IDA函数识别</h2><p>IDA可以识别出函数MessageBoxA及其各参数的信息，IDA通过SIG文件来识别已知的函数信息<br>常用的SIG文件放置在了IDA安装目录中的SIG文件夹下<br><a href="https://blog.csdn.net/youyou519/article/details/100140265" target="_blank" rel="noopener">SIG文件制作</a></p>
<h2 id="反汇编引擎的工作原理"><a href="#反汇编引擎的工作原理" class="headerlink" title="反汇编引擎的工作原理"></a>反汇编引擎的工作原理</h2><p><img src="%E5%9B%BE1.jpg" alt="Intel指令结构图">  </p>
<ol>
<li><p>Instruction Prefixes:指令前缀<br>指令前缀是可选的，作为指令的补助说明信息存在，主要用于以下4种情况  </p>
<ul>
<li>重复指令：如REP、REPE、REPZ  </li>
<li>跨段指令：如MOV DWORD PTR FS:[XXXX],0</li>
<li>将操作数从32位转为16位：如MOV AX，WORD PTR DS:[EAX]</li>
<li>将地址从16位转为32位：如MOV EAX，DWORD PTR DS:[BX+SI]  </li>
</ul>
</li>
<li><p>Opcode:指令操作码<br>Opcode为机器码中的操作符部分，用来说明指令语句执行什么样的操作<br>汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条Opcode码，但由于操作数类型不同，所占长度也不相同，因此对于非单字节指令来说，解析一条汇编指令单凭Opcode是不够的，还需要Mode R/M、SIB、 Displacement 的帮助，才能够完整地解析出汇编信息  </p>
</li>
<li><p>Mode R/M：操作数类型<br>ModeRM是辅助Opcode解释汇编指令助记符后的操作数类型。R表示寄存器，M表示内存单元。Mode RM占一个字节的固定长度<br><img src="%E5%9B%BE2.jpg" alt="Mode R/M">  </p>
</li>
<li><p>SIB: 辅助Mode R/M，计算地址偏移<br>SIB的寻址方式为基址+变址，如MOV EAX,DWORD PTR DS:[EBX+ECX*2],其中的ECX、乘数2都是由SIB来指定的。SIB的结构如图1-15所示。SIB占1个字节大小，第0、1、2位用于指定作为基址的寄存器;第3、4、5位用于指定作为变址的寄存器:第6、7位用于指定乘数，由于只有两位，因此可以表示4种状态，这4种状态分别表示乘数为1.2、4、8<br><img src="%E5%9B%BE3.jpg" alt="SIB">  </p>
</li>
<li><p>Displacement：辅助Mode R/M，计算地址偏移<br>Displacement用于辅助SIB，如MOV EAX,DWORD PTR DS:[EBX+ECX*2+3]这条指<br>令，其中的“+3”是由Displacement来指定的  </p>
</li>
<li><p>Immediate：立即数<br>用于解释指令语句中操作数为-一个常量值的情况  </p>
</li>
</ol>
<h1 id="第二章-C-反汇编揭秘"><a href="#第二章-C-反汇编揭秘" class="headerlink" title="第二章 C++反汇编揭秘"></a>第二章 C++反汇编揭秘</h1><h2 id="浮点数的编码方式"><a href="#浮点数的编码方式" class="headerlink" title="浮点数的编码方式"></a>浮点数的编码方式</h2><p>float类型在内存中占4字节(32 位)。最高位用于表示符号;在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如图  </p>
<p><img src="%E5%9B%BE4.jpg" alt="float类型二进制存储">  </p>
<p>在进行二进制转换前，需要对单精度浮点数进行科学记数法转换。例如，将float类型的12.25f转换为IEEE编码，需将12.25f转换成对应的二进制数1100.01,整数部分为1100,小数部分为01 ;小数点向左移动，每移动1次指数加1，移动到除符号位的最高位为1处，停止移动，这里移动3次。对12.25f进行科学记数法转换后二进制部分为1.10001，指数部分为3。在IEEE编码中，由于在二进制情况下，最高位始终为1，为一个恒定值，故将其忽略不计。这里是一个正数，所以符号位添0  </p>
<p>所以，转换为:  </p>
<ul>
<li>符号位: 0  </li>
<li>指数位：十进制3+127，转换为二进制是10000010  </li>
<li>尾数位：10001000000000000000000  </li>
</ul>
<p>这里指数位+127是因为指数可能出现负数，127的二进制表示为01111111，规定当指数域小于01111111时为一个负数，反之为正数，因此01111111为0  </p>
<p>12.25f转换后的IEEE编码按二进制拼接为010000010100010000000000000000。转换<br>成十六进制数为0x41440000,内存中以小尾方式进行排列，故为00 00 44 41  </p>
<p>浮点数-0.125f转换IEEE编码后，将会是一一个符号位为1,指数部分为负的小数。-0. 125f经转换后二进制部分为0.001,用科学记数法表示为1.0，指数为-3  </p>
<p>所以转换结果为:  </p>
<ul>
<li>符号位: 1  </li>
<li>指数位：十进制(-3)+127，转换为二进制是01111100  </li>
<li>尾数位：00000000000000000000000  </li>
</ul>
<p>上面的两个浮点数小数部分转换为二进制时都是有穷的，如果小数部分转换为二进制时得到一个无穷值，则会根据尾数部分的长度舍弃多余的部分。单精度浮点数1.3f,小数部分转换为二进制就会产生无穷值，依次转换为: 0.3、0.6、 1.2、 0.4、 0.8、1.6、1.2、0.4、0.8…转换后得到的二进制数为1.01001100110011001100110,到第23位终止，尾数部分无法保存更大的值  </p>
<p>转换结果为：  </p>
<ul>
<li>符号位: 0  </li>
<li>指数位：十进制(0)+127，转换为二进制是01111111  </li>
<li>尾数位：01001100110011001100110  </li>
</ul>
<h2 id="基本的浮点数指令"><a href="#基本的浮点数指令" class="headerlink" title="基本的浮点数指令"></a>基本的浮点数指令</h2><p>浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1)。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0) 中的数据将装入ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表2-1所示，其中，IN表示操作数人栈，OUT 表示操作数出栈  </p>
<p><img src="%E5%9B%BE6.jpg" alt="常用浮点数指令表">  </p>
<pre><code>
类型转换函数_ftol的实现  

;保存环境，预留语句变量空间
0040E688  push  ebp
0040E689  mov   ebp,esp
0040E68B  add   esp,0f4h  

;浮点异常检查、CPU与FPU的同步工作
0040E68E  wait
0040E68E  fnstcw  word ptr [ebp-2]
0040E692  wait
0040E693  mov   ax,word ptr [ebp-2]
0040E697  or    ah, 0Ch
0040E69A  mov   word ptr [ebp-4] ,ax
0040E69E  fldcw  word ptr [ebp-4]  

;从ST(0)中取出8字节数据转换成整型并存入ebp-0Ch中

;将ST(0)从栈中弹出

0040E6A1  fistp  qword ptr [ebp-0Ch]
0040E6A4  fldcw  word ptr [ebp-2]

;使用eax保存整型数据的低4字节，用于返回
0040E6A7  mov   dword ptr [ebp-0ch]

;使用edx保存整型数据的高4字节，用于返回
0040E6AA  mov   edx,dword ptr [ebp-8]

;释放栈
0040E6AD  leave
0040E6AE  ret</code></pre><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>ASCII使用GB2312-80，又叫汉字国标码，保存了6763个常用汉字编码，用两个字节来表示一个汉字。在GB2312-80中用区和位来定位，第一个字节保存每个区，共94个区;第二个字节保存每个区中的位，共94位。详细信息可查看GB2312-80编码的说明  </p>
<p>Unicode使用UCS-2编码格式，最多可存储65536个字符。汉字博大精深，其中有简体字、繁体字，以及网络中流行的火星文，它们的总和远远超过了UCS-2的存储范围，所以UCS-2编码格式中只保存了常用字。为了将所有的汉字都容纳进来，Unicode也采用了与ASCII类似的方式一用 两个Unicode编码解释一个汉字，称之为UCS-4编码格式。UCS-2编码表的使用和ASCII码表的使用是一样的。每个数字编号在表中对应-一个汉字，从0x4E00到0x9520为汉字编码区。例如，在UCS-2中，“烫”字的编码为0x70EB  </p>
<p>C++使用结束符\O’作为字符串结束标志。ASCII编码使用一个字节“0’,Unicode编码使用两个字节\0’。需要注意的是，<strong>不能使用处理ASCII编码的函数对Unicode编码进行处理</strong>，因为如果Unicode编码中出现了只占用1字节的字符，就会发生解释错误  </p>
<h2 id="地址、指针和引用"><a href="#地址、指针和引用" class="headerlink" title="地址、指针和引用"></a>地址、指针和引用</h2><h3 id="指针和地址的区别"><a href="#指针和地址的区别" class="headerlink" title="指针和地址的区别"></a>指针和地址的区别</h3><p>在32位操作系统下，地址是一个由32位二进制数字组成的值。为了便于查看，转换成十六进制数字进行显示，用于标识内存编号。指针是用于保存这个编号的-种变量类型，它包含在内存中，所以可以取出指针类型变量在内存中的位置一地址。 由于指针保存的数据都是地址，所以<strong>无论什么类型</strong>的指针都占据<strong>4字节</strong>的内存空间，如图  </p>
<p><img src="%E5%9B%BE7.jpg" alt="指针和地址">  </p>
<p>指针可以根据指针类型对地址对应的数据进行解释。而一个地址值无法单独解释数据,对于图中0x0012FF68这个地址值，仅仅凭借它自己无法说明该地址处对应数据的信息。如果是在一个int 类型的指针中保存这个地址，就可以将0x0012FF68这个地址值看做是int类型数据的起始地址，向后数4字节到0x0014FF6C处。将0x0012FF68 ~0x0014FF6C中的数据按整型存储方式解释  </p>
<p><img src="%E5%9B%BE8.jpg" alt="指针和地址之间的不同点"><br><img src="%E5%9B%BE9.jpg" alt="指针和地址之间的不同点"><br><img src="P10.jpg" alt="指针和地址之间的共同点">  </p>
<h3 id="各类指针的工作方式"><a href="#各类指针的工作方式" class="headerlink" title="各类指针的工作方式"></a>各类指针的工作方式</h3><p>不同指针的源码：</p>
<pre><code>// C++源码对比，定义int类型变量，初始化为0x12345678

int nVar = 0x12345678;
;为地址赋值4字节数据12345678h
0040EB1D  mov   dword ptr [ebp-10h],12345678h

// C++源码对比，定义int类型指针变量，初始化为变量nVar地址
int *pnVar = &amp;nVar;
0040EB24  lea   ecx,[ebp-10h]
0040EB27  mov   dword ptr [ebp-14h],ecx  

// C++ 源码对比，定义char类型指针变量， 初始化为变量nvar地址
char *pcVar = (char*) &amp;nVar;
0040EB2A  lea   edx,[ebp-10h]
0040EB2D  mov   dword ptr [ebp-1ch],eax  

// C++源码对比，定义short类型的指针变量，初始化为变量nVar地址
short *psnVar = { short*) &amp;nVar ;
0040EB30  lea   eax,[ebp-10h]  
0040EB33  mov   dword ptr [ebp-1Ch],eax  

//C++源码对比，取出指针pnVar指向的地址内容并显示
printf(&quot;%08x \r\n&quot;，*pnVar) ;

;取出pnVar中保存的地址值并放入ecx中
0040EB36  mov   ecx,dword ptr [ebp-14h]

;从ecx保存的地址中，以4字节方式读取数据，存入edx中
0040EB39  mov   edx,dword ptr [ecx]

pcVar 以1字节的方式读取数据存入ecx中
psnVar 以2字节的方式读取存入eax中</code></pre><p>指针类型只支持加法和减法，指针进行运算后，指针内保存的地址值的增加或减少取决于<strong>指针类型</strong>，如int类会使地址值的变换是4  </p>
<p>type *P;//这里用type泛指某类型的指针s<br>p+n的目标地址=首地址+ sizeof( 指针类型type) * n  </p>
<p>两指针相减可以得到数组长度  </p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++将指针操作进行了封装，产生了引用类型<br>引用通过编译器寻址，而指针需要手动寻址  </p>
<pre><code>void Add (int &amp;nVar) {
;在Debug版中添加汇编代码略

nVar++;     // C++源码对比，对引用类型nVar执行++操作
;取出参数nVar中的内容放入eax中
00401078  mov   eax,dword ptr [ebp+8]  

;对eax执行取内容操作
0040107B  mov   ecx,dword ptr [eax]
0040107D  add   ecx,1
00401080  mov   edx,dword ptr [ebp+8]
00401083  mov   dword ptr [edx],ecx

}
</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h3><p>#define是一个真常量，而const是由<strong>编译器判断</strong>的假常量，实际上，const定义的变量，终究还是一个变量，只是在编译器内进行了检查，发现有修改则报错  </p>
<p>所以可以修改const常量，通过指针获取const常量的地址，强制将指针的const修饰去掉，就可以修改对应的数据内容  </p>
<pre><code>// C++源码对比，将变量nConst修饰为const
const int nConst = 5;
;将地址ebp-4赋值给4字节数据5
004010B8  mov   dword ptr [ebp-4],5

// C++源码对比，定义int类型的指针，保存nConst地址
int *pConst = (int*) &amp;nConst ; 
;获取ebp-4地址并存入eax中
004010BF  lea   eax,[ebp-4]

;将eax中的数据赋值到地址ebp-8处
004010C2  mov   dword ptr [ebp-8],eax

// C++源码对比，修改指针pConst并指向地址中的数据
*pConst = 6;
;荻取地址ebp-8中的数据并存入ecx
004010C5  mov   ecx,dword ptr [ebp-8]

;将地址ebp-8中保存的数据修改为6
004010C8  mov   dword ptr [ecx],6

// C++源码对比，将修饰为const的变量nConst腻值给nVar
int nVar = nConst ;

;将5赋值到地址ebp-0Ch处
00401OCE  mov   dword ptr [ebp-0ch],5
</code></pre><p>最后的直接赋值5是编译器做出了优化</p>
<p><img src="P11.jpg" alt="#define与const的区别"></p>
<h1 id="第三章-认识启动函数，找到用户入口"><a href="#第三章-认识启动函数，找到用户入口" class="headerlink" title="第三章 认识启动函数，找到用户入口"></a>第三章 认识启动函数，找到用户入口</h1><h2 id="程序真正入口"><a href="#程序真正入口" class="headerlink" title="程序真正入口"></a>程序真正入口</h2><p>main或WinMain函数应该是“语法规定的用户入口”，而不是“应用程序入口”。在应用程序被操作系统加载时，操作系统会分析执行文件内的数据，分配相关资源，读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实<strong>并不是main或WinMain</strong>，通常是<strong>mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup</strong>，具体视编译选项而定。其中<strong>mainCRTStartup和wmainCRTStartup</strong>是控制台环境下多字节编码和Unicode编码的启动函数，而<strong>WinMainCRTStartup和wWinMainCRTStartup</strong>则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定入口  </p>
<h2 id="VC-6-0的启动函数"><a href="#VC-6-0的启动函数" class="headerlink" title="VC++6.0的启动函数"></a>VC++6.0的启动函数</h2><p>VC++6.0在控制台和多字节编码环境下的启动函数为<strong>mainCRTStartup</strong>，由系统库<strong>KERNEL32.dll</strong>负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处  </p>
<pre><code>void mainCRTStartup (
#endif /* WPRFLAG */
#endif /* _WINMAIN_ */
    void
)

{
    //荻取版本信息
    _osver = GetVersion();
    _winminor = (_osver &gt;&gt; 8) &amp; 0x00FF;
    _winmajor = _ osver &amp; 0x00FF;
    _winver = (_ winmajor &lt;&lt; 8) + _winminor;
    _osver = (_osver &gt;&gt; 16) &amp; 0x00FFFF;

    // 堆空间初始化过程，在此函数中，指定了程序中堆空间的起始地址
    // _MT是多线程标记

#ifdef _MT
    if ( ! _heap_ init(1) )
#else /* _MT */
    if ( !_ heap_ init(0) )
#endif /* _MT */
    fast_error_ exit(_RT_HEAPINIT);

    //初始化多线程环境
#ifdef _MT
    if( !_ mtinit() )
        fast_error_exit(_RT_THREAD);
#endif /* _MT */
    _try {
        // 宽字符处理代码略

        // 多字节版荻取命令行
        _acmdln = (char *) GetCommandLineA();

    // 多字节版获环境变量信息
    _aenvptr = {char *)__crtGetEnvironmentStringsA();

    // 多字节版获取命令行信息
    _setargv();

    // 多字节版荻取环境变量信息
    _setenvp();

#endif /* WPRFLAG */
    // 初始化全局数据和浮点寄存器
    _cinit();

    // 窗口程序处理代码略

    // 宽字符处理代码略

    // 获取环境变量信息
    _initenv = _environ;

    // 调用main函数，传递命令行参数信息
    mainret = main(_argc, _argv, _environ);

#endif /* WPRFLAG */

#endif /* _WINMAIN_ */
    // 检查main函数返回值执行析构函数或atexit注册的函数指针，并结束程序
    exit (mainret);
}
// 退出结束代码略
</code></pre><ul>
<li><strong>GetVersion函数</strong>:获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息</li>
<li><strong>_ heap_ init函数</strong>:用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_heap_init传递的参数决定。_sbh_heap_init函数用于初始化堆结构信息  </li>
<li><strong>GetCommandLineA函数</strong>:获取命令行参数信息的首地址  </li>
<li><strong>_crtGetEnvironmentStringsA函数</strong>:获取环境变量信息的首地址  </li>
<li><strong>_setargv函数</strong>:此函数根据GetCommandLineA获取命令行参数信息的首地址并进行参数分析，将分离出的参数的个数保存在全局变量_arge中，将分析出的每个命令行参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量_argv中。这样就得到了命令行参数的个数，以及命令行参数信息  </li>
<li><strong>_ setenvp 函数</strong>:此函数根据__crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中  </li>
</ul>
<p>得到main函数所需的三个参数信息之后，当调用main函数时，便可以将_ _argc、 _argv、 env这三个全局变量作为参数，以栈传参方式传递到main函数中  </p>
<ul>
<li><strong>_cinit函数</strong>:用于全局数据和浮点寄存器的初始化。全局对象和I/O流等的初始化都是通过这个函数实现的。利用函数 <em>itterm 进行数据链初始化，这个函数由两个参数组成，类型为“_PVFV*”,这是一个函数指针数组，其中保留了每个初始化函数的地址。初始化函数的类型为_PVFV, 其定义原型如下:<br>typedef void (</em> cdec1 * _PVFV) (void);<br>也就是说，这个初始化函数是无参数也无返回值的，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的，具体如下所示：  </li>
</ul>
<pre><code>// 用于初始化寄存器
if (_FPinit != NULL)  
(*_ FPinit) (); //初始化浮点寄存器

// 用于初始化C语法中的数据
_initterm( _xi_a, _xi_z );

// 用于初始化C++语法中的数据
_initterm( _XC_a, _XC_z );
</code></pre><p><strong>FPinit</strong> 是一个全局函数指针，类型也是_PVFV, 如果编译器扫描代码时发现有浮点计算，则此指针保存了初始化浮点寄存器的代码地址，否则为0值。如果浮点寄存器未被初始化而进行浮点计算，程序会产生异常或错误，这类错误应属于VC++ 6.0自身设计的Bug,在VC++6.0以后的版本中已将其修复。一般而言，第一个_initterm 初始化的都是C支持库中所需的数据。参数_xi_a 为函数指针数组的起始地址，_xi_z为结束地址。 _initterm 的实现：  </p>
<pre><code>static void__ cdec1 initterm (
    _PVFV * pfbegin,
    _PVFV * pfend
)
{
    // 遍历数组的各元素
    while ( pfbegin &lt; pfend )
    {
        // 若函数指针不为空，则执行该函数
        if ( *pfbegin != NULL )
            (**pfbegin) () ;

        ++pfbegin;
    }
}</code></pre><p>在默认情况下，入口函数为main,这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置人口函数，依次选择菜单Procject→Settings →Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称。编译后调试程序，结果如图所示  </p>
<p><img src="P12.jpg" alt="重设入口函数">  </p>
<p>由于没有调用mainCRTStartup函数，所以<strong>堆空间没有被初始化</strong>，当使用堆空间时，程序会报错崩溃  </p>
<h2 id="识别main函数"><a href="#识别main函数" class="headerlink" title="识别main函数"></a>识别main函数</h2><p>main函数有如下特征是:它有3个参数，分别为命令行参数个数、命令行参数信息和环境变量信息，而且它是启动函数中唯一的具有3个参数的函数。同理，WinMain 也是启动函数中唯一的具有4个参数的函数  </p>
<pre><code>;省略部分代码

; O1lyDBG识别出的函数名称为GetCommandLineA
00401210  |. FF15 38514200   call dword ptr ds: [&lt; &amp;KERNEL32.GetCommand&gt;

;得到命令行参数
00401216  |. A3 444F4200    mov dword ptr ds: [424F44] , eax

;根据main函数特性，此处为函数_crtGetEnvironmentStringsA() 调用
0040121B  |. E8 E0240000    call ProgramE.00403700
00401220  |. A3 BC354200    mov dword ptr ds: [4235BC] , eax

;根据main函数特性，此处为函数_setargv()调用
00401225  |. E8 C61F0000    call ProgramE.004031F0

;根据main函数特性，此处为函数cinit()调用
0040122F  |. E8 8C1A0000    call ProgramE.00402CC0
00401234  |. 8B0D 00364200  mov ecx, dword ptr ds: [423600]
0040123A  |. 890D 04364200  mov dword ptr ds: [423604] , ecx
00401240  |. 8B15 00364200  mov edx, dword ptr ds: [423600] 

;压栈传参，环境变量信息
00401246  |. 52             push edx
00401247  |. Al F8354200    mov eax, dword ptr ds: [4235F8]

;压栈传参，命令行参数信息
0040124C  |. 50             push eax
0040124D  |. 8BOD F4354200  mov ecx, dword ptr ds; [4235F4]

;压栈传参，命令行参数个数
00401253  |. 51             push ecx

;此处为main函数的调用处，跟进到函数中便是main函数的实现代码流程
00401254  |. E8 ACFDFFFF    call ProgramE.00401005</code></pre>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完</p>
<a id="more"></a>
<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol>
<li>方便性  </li>
<li>有效性<br>有效性的第一层含义是提高系统资源的利用率。另一层含义是，提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。  </li>
<li>可扩充性<br>OS从早期的无结构发展称模块化结构，进而发展成层次化结构，近年来广泛采用了微内核结构，具有良好的可扩充性。  </li>
<li>开放性<br>指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。  </li>
</ol>
<h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ol>
<li>OS作为用户与计算机硬件系统之间的接口<br>用户通过命令方式、系统调用方式和图标——窗口方式来实现与操作系统的通信  </li>
<li>OS作为计算机系统资源的管理者<br>OS中的资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）  </li>
<li>OS实现了对计算机资源的抽象<br>OS是铺设在计算机硬件上的多层软件的集合，不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。  </li>
</ol>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol>
<li>处理过程<br>简单来说就是将作业装在磁带上，一个一个单个处理，如图：<br><img src="%E5%9B%BE1.jpg" alt="单道批处理系统">  </li>
<li>缺点<br>资源得不到充分利用，如图：<br><img src="%E5%9B%BE2.jpg" alt="运行情况">  </li>
</ol>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol>
<li>处理过程<br>用户所提交的作业先放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。  </li>
<li>优缺点<br>（1）资源利用率高<br>（2）系统吞吐量大<br>（3）平均周转时间长<br>（4）无交互能力  </li>
</ol>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol>
<li>运行方式  </li>
</ol>
<ul>
<li>作业直接进入内存  </li>
<li>采用轮转运行方式（加入时间片）  </li>
</ul>
<ol start="2">
<li>特征  </li>
</ol>
<ul>
<li>多路性：系统允许将多台终端同时链接到一台主机上  </li>
<li>独立性：系统提供了这样的用户各自独立环境  </li>
<li>及时性：用户的请求很短时间内能得到相应  </li>
<li>交互性：用户可通过终端进行人机对话  </li>
</ul>
<h2 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h2><ul>
<li>单用户单任务操作系统  </li>
<li>单用户多任务操作系统  </li>
<li>多用户多任务操作系统  </li>
</ul>
<h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol>
<li>并行与并发  </li>
</ol>
<ul>
<li>并行性是指两个或多个事件在同一时刻发生  </li>
<li>并发性是指两个或多个事件在统一时间间隔内发生  </li>
</ul>
<ol start="2">
<li>引入进程  </li>
</ol>
<ul>
<li>进程是指：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。  </li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ol>
<li>互斥共享方式<br>一个进程访问完资源后，资源才能被另一个进程访问。资源叫做<strong>临界资源</strong>    </li>
<li>同时访问方式  </li>
</ol>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在os中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为<strong>虚拟</strong>。  </p>
<ol>
<li>时分复用技术（时间）  </li>
<li>空分复用技术（空间）  </li>
</ol>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ol>
<li>进程控制：为作业创建进程、撤销（终止）已结束的进程，以及控制进程在运行过程中的状态转换。  </li>
<li>进程同步：  </li>
</ol>
<ul>
<li>进程互斥方式：指诸进程在对临界资源进行访问时，应采用互斥方式  </li>
<li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。  </li>
</ul>
<ol start="3">
<li>进程通信：通常采用直接通信方式，由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接受命令从其消息队列中取出消息  </li>
<li>调度  </li>
</ol>
<ul>
<li>作业调度：从后备队列中按一定算法取出若干队列。为其分配运行所需资源。</li>
<li>进程调度：从就绪队列中按照一定的算法选出一个进程，执行。</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ol>
<li>内存分配  </li>
</ol>
<ul>
<li>静态分配方式：每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间。</li>
<li>动态分配方式：允许申请新的空间。  </li>
</ul>
<ol start="2">
<li>内存保护：每个程序互不打扰，操作系统的程序和数据不允许访问。</li>
<li>地址映射  </li>
<li>内存扩充  </li>
</ol>
<ul>
<li>请求调入功能：将程序所需部分从存储器中调入内存</li>
<li>置换功能：将内存和磁盘的数据进行置换  </li>
</ul>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol>
<li>共享存储器系统  </li>
</ol>
<ul>
<li>基于共享数据结构的通信方式。</li>
</ul>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol>
<li>高级调度<br>调度对象是作业，其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为其创建进程、分配资源，放入就绪队列，主要应用于多道批处理系统  </li>
<li>低级调度<br>又称为进程调度或短程调度，其调度对象是进程(或内核级线程)。其主要功能是根据某种算法决定就绪队列中的哪个进程应获得处理机。</li>
<li>中级调度<br>提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存，把能运行的调至内存。  </li>
</ol>
<h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol>
<li>处理机调度算法的共同目标<br>(1)<strong>资源利用率</strong> CPU的利用率 = CPU的有效工作时间/(CPU的有效工作时间+CPU的空闲等待时间)<br>(2)<strong>公平性</strong> 每个进程都应该获得合理的CPU时间<br>(3)<strong>平衡性</strong> 尽可能保持系统资源使用的平衡性<br>(4)<strong>策略强制执行</strong> 对所制订的策略，保证其准确执行  </li>
<li>批处理系统的目标<br>(1)<strong>平均周转时间短</strong><br>(2)<strong>系统吞吐量高</strong><br>(3)<strong>处理机利用率高</strong>  </li>
<li>分时系统的目标<br>(1)<strong>响应时间快</strong><br>(2)<strong>均衡性</strong>  </li>
<li>实时系统的目标<br>(1)<strong>截止时间的保证</strong><br>(2)<strong>可预测性</strong>  </li>
</ol>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ol>
<li>作业与作业步<br>(1)作业。不仅包含通常的程序和数据，还包括一份作业说明书，再批处理系统中，作业为基本单位从外存调入内存<br>(2)作业步。每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。每个步骤叫做一个作业步。  </li>
<li>作业的三种状态和三个阶段  </li>
</ol>
<ul>
<li>收容阶段，操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。(后备状态)</li>
<li>运行阶段(运行阶段)  </li>
<li>完成阶段(完成阶段)  </li>
</ul>
<ol start="3">
<li>先来先服务和短作业优先调度算法  </li>
</ol>
<ul>
<li>先来先服务调度算法(FCFS)  </li>
<li>短作业优先调度算法(SJF):作业越短优先级越高  </li>
<li>优先级调度算法(PSA):外部赋予作业优先级  </li>
<li>高响应比优先调度算法(HRRN):优先权 = (等待时间+要求服务时间)/要求服务时间  </li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol>
<li>非抢占方式<br>一旦处理机分配给某进程后，就一直让它运行下去，不会因为时钟中断而被抢占。<br>可能引起进程调度的因素：  </li>
</ol>
<ul>
<li>程序执行完毕，或发生某种事件使程序无法执行  </li>
<li>I/O请求  </li>
<li>原语操作如Block<br>不适用于分时系统和大多数实时系统  </li>
</ul>
<ol start="2">
<li>抢占方式<br>允许调度程序根据某一原则暂停执行中的程序，分配处理机给新的进程<br>原则：  </li>
</ol>
<ul>
<li>优先权原则：高优先级先运行  </li>
<li>短进程优先原则</li>
<li>时间片原则：时间片用完就暂停执行  <h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3>就绪队列上的每个进程每次仅运行一个时间片。  </li>
</ul>
<ol>
<li><strong>原理</strong><br>系统将所有的就绪进程按FCFS策略排成一个就绪队列。  </li>
<li><strong>进程切换时机</strong>  </li>
</ol>
<ul>
<li>执行完成</li>
<li>时间片用完，计时器中断处理程序被激活  </li>
</ul>
<ol start="3">
<li><strong>时间片大小的确定</strong><br>略大于典型交互时间  <h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3></li>
<li><strong>类型</strong>  </li>
</ol>
<ul>
<li>非抢占式优先级调度算法：一旦处理机分配给了优先级最高的进程，则一直执行下去直至完成。</li>
<li>抢占式优先级调度算法：出现了更高优先级的进程，中断当前执行进程，转而去执行更高优先级的进程。  </li>
</ul>
<ol start="2">
<li>优先级的类型  </li>
</ol>
<ul>
<li>静态优先级：进程运行过程中优先级保持不变  </li>
<li>动态优先级：随着时间增加而改变  <h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3>将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的算法。<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3></li>
</ul>
<ol>
<li>调度机制  </li>
</ol>
<ul>
<li>设置多个就绪队列，每个队列不同的优先级不同的时间片大小，在优先级愈高的队列中，其时间片就越小。  </li>
<li>每个队列采用FCFS算法。</li>
<li>按队列优先级调度。 <h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3></li>
</ul>
<ol>
<li>保证调度算法<br>这里的保证并不是优先运行，而是性能保证。</li>
</ol>
<ul>
<li>跟踪计算每个进程自创建以来已经执行的处理时间</li>
<li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n  </li>
<li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比  </li>
<li>比较各进程获得处理机时间的比率</li>
<li>选择比率最小的进程将处理机分配给它，知道超过最接近它的进程比率</li>
</ul>
<ol start="2">
<li>公平分享调度方法<br>对用户公平  </li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol>
<li>提供必要的信息<br>(1)就绪时间<br>(2)开始截止时间和完成截止时间<br>(3)处理时间<br>(4)资源要求<br>(5)优先级  </li>
<li>系统处理能力强  </li>
<li>采用抢占式调度机制  </li>
<li>具有快速切换机制<br>(1)对中断的快速响应能力<br>(2)快速的任务分派能力  <h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li>
<li>非抢占式调度算法</li>
</ol>
<ul>
<li>非抢占式轮转调度算法  </li>
<li>非抢占式优先调度算法  </li>
</ul>
<ol start="2">
<li>抢占式调度算法  </li>
</ol>
<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法  </li>
</ul>
<h3 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h3><p>任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。  </p>
<h3 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h3><p>松弛度 = 必须完成的时间 - 其本身的运行时间 - 当前时间<br>松弛度低的先运行  </p>
<h3 id="优先级倒置-priority-inversion-problem"><a href="#优先级倒置-priority-inversion-problem" class="headerlink" title="优先级倒置(priority inversion problem)"></a>优先级倒置(priority inversion problem)</h3><p>低优先级和高优先级的共享一临界资源，就会导致如果低优先级的<strong>先执行</strong>，高优先级在得到处理机后，因为临界资源被<strong>占用</strong>而被<strong>堵塞</strong>，导致低优先级的先执行  </p>
<ul>
<li>解决方法：<br>1 低优先级在进入临界区后不允许被抢占<br>2 低优先级继承高优先级的优先级，率先执行完  </li>
</ul>
<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ol>
<li>可重用资源和消耗性资源  </li>
</ol>
<ul>
<li>可重用资源：一种可供用户重复使用多次的资源，有如下性质：<br>(1)每一个可重用资源中的单元只能分配给一个进程使用，不能共享<br>(2)进程在使用可重用性资源时，必须先请求再使用<br>(3)数目固定，进程在运行期间既不能创建也不能删除  </li>
<li>可消耗资源：在进程运行期间，由进程动态创建和消耗  </li>
</ul>
<ol start="2">
<li>可抢占性资源和不可抢占资源  </li>
</ol>
<h3 id="计算机中的死锁"><a href="#计算机中的死锁" class="headerlink" title="计算机中的死锁"></a>计算机中的死锁</h3><ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁  </li>
</ul>
<h3 id="死锁的定义、必要条件和处理方法"><a href="#死锁的定义、必要条件和处理方法" class="headerlink" title="死锁的定义、必要条件和处理方法"></a>死锁的定义、必要条件和处理方法</h3><ol>
<li>定义：如果一组进程中的每一个进程都在等待仅有该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件<br>(1)互斥条件。进程对所分配道德资源进行排他性使用<br>(2)请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有<br>(3)不可抢占条件<br>(4)循环等待条件  </li>
<li>处理死锁的方法<br>(1)预防死锁：通过设置某些限制条件，去破坏一个进程<br>(2)避免死锁：用某种方法防止系统进入不安全状态，从而可以避免发生死锁<br>(3)检测死锁：通过检测机构及时检测出死锁发生，采取适当措施<br>(4)解除死锁：撤销进程，回收资源  </li>
</ol>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><ol>
<li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需地全部资源。这样就避免了资源”请求”条件。</li>
<li>第二种协议：允许一个进程只获得运行储器所需资源后，便开始运行。进程运行过程中在逐步释放已分给自己的、且已用毕地全部资源，然后再请求新的所需资源  <h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3>当一个已经保持了某些不可被抢占资源地进程，提出新的资源请求而得不到满足时，它必须释放已经保持地所有资源，待以后需要时再重新申请  <h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3>对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增地顺序请求资源。一个进程在开始时可以请求Ri的资源，以后当且仅当F(Rj)&gt;F(Ri)的时候才可以请求Rj的资源  </li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul>
<li>安全状态<br>所谓的安全状态是指系统能按某种进程推进顺序(P1,P2,···,Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成  <h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><a href="https://blog.csdn.net/qq_36260974/article/details/84404369" target="_blank" rel="noopener">银行家算法</a>  </li>
</ul>
<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储器结构"><a href="#多层结构的存储器结构" class="headerlink" title="多层结构的存储器结构"></a>多层结构的存储器结构</h3><p>可执行存储器：寄存器和主存储器<br>主存储器：内存或主存，用于保存进程运行时的程序和数据<br>寄存器：具有与处理机相同的速度  </p>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序，需经过如下步骤：</p>
<ul>
<li>编译，有编译程序对用户源程序进行编译，形成若干个目标模块  </li>
<li>链接，由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块  </li>
<li>装入，由装入程序将装入模块装入内存  <h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3>有三种装入方式：  </li>
</ul>
<ol>
<li>绝对装入方式  </li>
<li>可重定位装入方式  </li>
<li>动态运行时的装入方式<br>装入程序把装入模块装入后，并不立即把装入模块中的逻辑地址转换为物理地址，而是等到运行时才进行  </li>
</ol>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ol>
<li>静态链接方式<br>在程序运行之前，先将各目标模块及他们所需的库函数链接成一个完整的装配模块，以后不在拆开。<br>(1)对相对地址进行修改。在编译程序所产生的所有目标模块中，使用的都是相对地址。<br>(2)变换外部调用符号  </li>
<li>装入时动态链接方式<br>指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。<br>有以下优点：<br>(1)便于修改和更新<br>(2)便于实现对目标模块的共享  </li>
<li>运行时动态链接<br>对某些模块的链接推迟到程序执行时才进行  <h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2>为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻  <h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3>把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常时放在内存的低址部分。而在用户区中，仅装有一道用户程序  <h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3>将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业  </li>
<li>划分分区的方法<br>(1)分区大小相等<br>(2)分区大小不等  </li>
<li>内存分配<br>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态  </li>
</ol>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol>
<li>动态分区分配中的数据结构  </li>
</ol>
<ul>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等数据项  </li>
<li>空闲分区链：每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针  </li>
</ul>
<ol start="2">
<li>分区分配操作  </li>
</ol>
<ul>
<li>分配内存</li>
<li>回收内存  </li>
</ul>
<h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><ol>
<li>首次适应算法(FF)<br>FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按作业大小，从该分区划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中<br>该算法倾向于优先利用内存中的低址部分的空闲分区，从而保留高址部分的大空闲区  </li>
<li>循环首次适应算法(NF)<br>为了避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找  </li>
<li>最佳适应算法(BF)<br>将所有空闲分区按其容量以从小到大的顺序形成一空闲分区链  </li>
<li>最坏适应算法(WF)<br>将所有空闲分区按其容量以从大到小顺序形成一空闲分区链，每次挑选最大的从中分割一部分给作业使用  </li>
</ol>
<h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><ol>
<li>快速适应算法(QF)<br>分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针<br>搜索时分为两步：(1)根据进程长度，从索引表中寻找能容纳它的最小空闲区链表;(2)从链表中取下第一块进行分配即可<br>缺点是在分区归还主存时算法复杂，一个分区只给一个进程容易浪费  </li>
<li>伙伴系统(buddy system)<br>无论已分配分区或空闲分区，其大小均为2的k次幂。分配时找2的i次方，合并时一样  </li>
<li>哈希算法<br>利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张一空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针  </li>
</ol>
<h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol>
<li>动态重定位<br>程序在执行时，真正访问的内存地址时相对地址与重定位寄存器中的低址相加而形成的，动态重定位分区与动态分区算法除了增加了”紧凑”功能外基本上相同  </li>
</ol>
<h2 id="对换-Swapping"><a href="#对换-Swapping" class="headerlink" title="对换(Swapping)"></a>对换(Swapping)</h2><h3 id="多道程序环境下的对换技术"><a href="#多道程序环境下的对换技术" class="headerlink" title="多道程序环境下的对换技术"></a>多道程序环境下的对换技术</h3><ol>
<li>对换技术：<br>在系统中设置一个对换进程，由它将内存中暂时不能运行的进程调出到磁盘的对换区;同样也由该进程将磁盘上已具备运行条件的进程调入内存  </li>
<li>对换的类型：  </li>
</ol>
<ul>
<li>整体对换:以整个进程为单位对换  </li>
<li>页面(分段)对换:以一个”页面”或”分段”为单位进行对换  <h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3></li>
</ul>
<ol>
<li>对换空间管理的主要目标<br>(1)对文件区管理的主要目标<br>提高文件存储空间的利用率，然后提高对分及的访问速度，因此，对文件区空间的管理采取离散分配方式<br>(2)对对换空间管理的主要目标<br>提高进程换入和换出速度，然后提高文件存储空间的利用率，因此对对换空间的管理采取连续分配方式  </li>
<li>对换区空闲盘块管理中的数据结构<br>可以用空闲分区表或空闲分区链，每个表目中包含两项:对换区的首地址及其大小，分别用盘块号和盘块数表示  </li>
<li>对换空间的分配与回收<br>与动态分区一样  <h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3></li>
<li>进程的换出<br>(1)选择被换出的进程<br>(2)进程换出过程  </li>
<li>进程的换入<br>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出”就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程  </li>
</ol>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><ol>
<li><p>页面与物理块<br>(1)页面<br>分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号，内存的物理低址空间分为若干块，同样也为它们加以编号。为进程分配内存时，以块为单位，将进程中的若干个页分别装入到若干个可以不相邻接的物理块中。<br>(2)页面大小  </p>
</li>
<li><p>地址结构<br>分页地址包含两部分内容：前一部分为页号P，后一部分为位(偏)移量W，即页内地址  </p>
</li>
<li><p>页表<br>分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表  </p>
</li>
</ol>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号  </p>
<ol>
<li>基本的地址变换机构<br>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，若未出现错误，则将页表始址与页号和页表项长度的成绩相加，则得到该表项在页表中的位置  </li>
<li>具有快表的地址变换机构<br>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”<br>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中  </li>
</ol>
<h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经给地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间(EAT)  </p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>32位系统中页表可能会很大，所以有两个方法解决问题:<br>(1)对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题<br>(2)只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入  </p>
<ol>
<li>两级页表<br>将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中<br>为离散分配的页表再建立一张页表，称为<strong>外层页表</strong>，在每个页表项中记录了页表页面的物理块号  </li>
<li>多级页表  </li>
</ol>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>为每一个物理块设置一个页表项，并将它们按物理块的序号排序，其中的内容则是页号和其所隶属进程的标识符<br>在利用反置页表进行地址变换时，是根据进程标识符和页号，取检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器  </p>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul>
<li>方便编程  </li>
<li>信息共享  </li>
<li>信息保护  </li>
<li>动态增长  </li>
<li>动态链接  <h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3></li>
</ul>
<ol>
<li>分段<br>在分段存储管理方式中，作业的地址空间被划分为若干段，每个段定义了一组逻辑信息，即每个段既包含了一部分地址空间，又标识了逻辑关系，其逻辑地址由段号和段内地址所组成  </li>
<li>段表<br>在分段式存储管理系统中，为每个分段分配一个连续的分区，进程中的各个段，可以离散地装入内存中不同的分区中，然后建立一个段映射表，<em>段表</em>  </li>
<li>地址变换机构<br>段表寄存器和联想寄存器  </li>
<li>分页和分段的区别  </li>
</ol>
<ul>
<li>页是信息的物理单位  </li>
<li>页的大小固定且由系统决定  </li>
<li>分页的用户程序地址空间是一维的  </li>
</ul>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol>
<li>基本原理<br>先将程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名，系统中需要同时配置段表和页表，段表的内容与分段系统略有不同，是页表始址和页表长度  </li>
<li>地址变换过程<br>首先利用段号S，将它与段长TL进行比较。若S &lt; TL, 表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址  </li>
</ol>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>因为实际运行作业的时候可能会出现:  </p>
<ol>
<li>有的作业很大  </li>
<li>有大量作业要求运行<br>出现上述情况的原因都是内存容量不够大，所以从逻辑上扩充内存容量  <h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><h3 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h3></li>
<li>常规存储器管理方式的特征  </li>
</ol>
<ul>
<li>一次性，是指作业必须一次性地全部装入内存后方能开始运行  </li>
<li>驻留性，是指作业被装入内存后，整个作业都一直驻留再内存中，其中任何部分都不会被换出，直至作业运行结束  </li>
</ul>
<ol start="2">
<li>局部性原理<br>程序在执行时将呈现出局部性规律，即在一较短地时间内，程序的执行仅局限于某个部分，相应地，它访问的存储空间也局限于某个区域  <h3 id="虚拟存储器地定义和特征"><a href="#虚拟存储器地定义和特征" class="headerlink" title="虚拟存储器地定义和特征"></a>虚拟存储器地定义和特征</h3></li>
<li>定义<br>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充地一种存储器系统  </li>
<li>虚拟存储器的特征  </li>
</ol>
<ul>
<li>多次性：指一个作业中的程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行  </li>
<li>对换性：指一个作业中地数据和程序，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出  </li>
<li>虚拟性：指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量  <h3 id="虚拟存储器地实现方法"><a href="#虚拟存储器地实现方法" class="headerlink" title="虚拟存储器地实现方法"></a>虚拟存储器地实现方法</h3></li>
</ul>
<ol>
<li>分页请求系统<br>是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统<br>(1)硬件支持：请求分页的页表机制、缺页中断机制、地址变换机构<br>(2)实现分页请求的软件：包括有用于实现请求调页的软件和实现页面置换的软件  </li>
<li>请求分段系统<br>是在分段系统的基础上，增加了请求调段及分段置换后所形成的段式虚拟存储系统  <h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3></li>
<li>请求页表机制<br>每个页表应该包含页号、物理块号、状态位、访问字段A、修改位M、外存地址  </li>
</ol>
<ul>
<li>状态位P:用于指示该页是否已经调入内存  </li>
<li>访问字段A:用于记录本页在一段时间内被访问的次数  </li>
<li>修改位M:标识该页在调入内存后是否被修改过  </li>
<li>外存地址:用于指出该页在外存上的地址  </li>
</ul>
<ol start="2">
<li>缺页中断机构<br>每当要访问的页面不存在时，便产生一缺页中断，请求OS将所缺之页调入内存，有两个特点:<br>(1)在指令执行期间产生和处理中断信号<br>(2)一条指令在执行期间可能产生多次缺页中断  </li>
<li>地址变换机构<br><img src="%E5%9B%BE5-2.png" alt="地址变换过程">  </li>
</ol>
<h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ol>
<li>最小的物理块数的确定<br>指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行  </li>
<li>内存分配策略  </li>
</ol>
<ul>
<li>固定分配局部置换:为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，如何再调入一页，然后再调入一夜，以保证分配给该进程的内存空间不变  </li>
<li>可变分配全局置换:指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地增加或减少。如果在进程运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块中选出一块换出  </li>
<li>可变分配局部置换:只允许在该进程的内存页面选择一页换出，若频繁缺页，则增加进程页面  </li>
</ul>
<ol start="3">
<li>物理块分配算法  </li>
</ol>
<ul>
<li>平均分配</li>
<li>按比例分配  </li>
<li>优先权分配  <h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3></li>
</ul>
<ol>
<li>何时调入页面  </li>
</ol>
<ul>
<li>预调页策略</li>
<li>请求调页策略  </li>
</ul>
<ol start="2">
<li>从何处调入页面<br>外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区<br>对换区一般采用连续分配方式，文件区一般采用离散分配方式<br>(1)系统拥有足够的对换区空间:<br>这时可以全部从对换区调入所需页面<br>(2)系统缺少足够的对换区空间:<br>不会被修改的文件，直接从文件区调入，会被修改的，须先调到对换区<br>(3)UNIX方式:<br>未运行过的页面，都从文件区调入，对于曾经运行过但又被换出的页面，从对换区调入  </li>
<li>调入过程<br>先找物理块位置，如果内存未满，调入；已满，置换。被置换的若被修改过，重写进磁盘  </li>
<li>缺页率<br>访问失败次数/总访问次数  <h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><a href="https://www.cnblogs.com/Leophen/p/11397699.html" target="_blank" rel="noopener">置换算法</a><h3 id="访问内存的有效时间-1"><a href="#访问内存的有效时间-1" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3>(1)被访问页在内存中，且其对应的页表项在快表中<br>EAT = 查找快表的时间+访问实际物理地址的时间<br>(2)被访问页在内存中，且其对应的页表项不在快表中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间<br>(3)被访问页不在内存中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间+处理断页中断的时间+更新快表的时间+访问实际物理地址的时间  <h2 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h2><h3 id="多道程序度和”抖动”"><a href="#多道程序度和”抖动”" class="headerlink" title="多道程序度和”抖动”"></a>多道程序度和”抖动”</h3></li>
<li>多道程序度和处理机的利用率<br>处理机的实际利用率随着进程数的增加而提高，但达到一定数目时开始下降  </li>
<li>抖动<br>在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求  <h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3>工作集是指，在某段时间间隔里，进程实际所要访问页面的集合  <h3 id="“抖动”的预防办法"><a href="#“抖动”的预防办法" class="headerlink" title="“抖动”的预防办法"></a>“抖动”的预防办法</h3></li>
<li>采用局部置换策略  </li>
<li>把工作集算法融入到处理机调度中  </li>
<li>利用”L=S”准则调节缺页率<br>L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面的时间  </li>
</ol>
<ul>
<li>L &gt;&gt; S，说明很少缺页，磁盘未充分利用  </li>
<li>L &lt;&lt; S,说明频繁缺页</li>
<li>L = S，完美  </li>
</ul>
<ol start="4">
<li>选择暂停的进程  <h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><img src="%E5%9B%BE5-3.png" alt="段表结构">  </li>
</ol>
<ul>
<li>缺段中断机构<br>一条指令不可能被分割在两个分段中<br><img src="%E5%9B%BE5-4.png" alt="中断处理"></li>
<li>地址变换机构<br><img src="%E5%9B%BE5-5.png" alt="地址变换">  <h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3></li>
</ul>
<ol>
<li>共享段表<br>配置一张共享段表，所有各共享段表中占有一表项。在表项上面记录了共享段的段号、段长、内存始址、状态(存在)位、外存始址以及共享计数等信息  </li>
</ol>
<ul>
<li>共享进程数:显示当前共享该分段的进程数  </li>
<li>存取控制字段:赋予不同进程不同权限  </li>
<li>段号:不同的进程有不同的段号  </li>
</ul>
<ol start="2">
<li>共享段的分配与回收<br>(1)共享段的分配<br>对第一个请求使用该共享段的进程，系统为该共享段分配一物理区，再把共享段调入该区。同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中添加一表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1，之后的count+1，再添加表项<br>(2)共享段的回收<br>撤销进程段表中共享段所对应的表项,count-1  </li>
<li>分段保护  </li>
</ol>
<ul>
<li>越界检查  </li>
<li>存取控制检测  </li>
<li>环保护机构  <h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h3></li>
</ul>
<ol>
<li>中断和陷入  </li>
</ol>
<ul>
<li>中断是指CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，叫做外中断  </li>
<li>陷入是CPU内部事件引发的中断，如运算溢出，程序出错，称为内中断  </li>
</ul>
<ol start="2">
<li>中断向量表和中断优先级  </li>
</ol>
<ul>
<li>中断向量表是为每种设备配以中断的不同类，处理的时候直接查表找处理程序</li>
<li>中断优先级，为每个中断规定不同的优先级  </li>
</ul>
<ol start="3">
<li>多中断源的处理方式</li>
</ol>
<ul>
<li>屏蔽中断<br>当处理机在处理一个中断时，将屏蔽其他所有中断  </li>
<li>嵌套中断<br>(1)当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求<br>(2)高优先级的中断请求可以抢占正在运行的低优先级中断的处理机  <h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3></li>
<li>测定是否有未响应的中断信号  </li>
<li>保护被中断进程的CPU环境  </li>
<li>转入相应的设备处理程序  </li>
<li>中断处理  </li>
<li>恢复CPU的现场并退出中断：<br>是否会返回到被中断的进程取决于哪个阶段：</li>
<li>是否采用屏蔽中断方式，若采用则返回  </li>
<li>采用的是中断嵌套方式，若没有更高优先级的中断，仍被返回被中断进程  <h3 id="对I-O设备的控制方式"><a href="#对I-O设备的控制方式" class="headerlink" title="对I/O设备的控制方式"></a>对I/O设备的控制方式</h3></li>
</ul>
<ol>
<li>采用轮询的可编程I/O方式<br>设置busy标志，输入未完成时为1，完成时为0  </li>
<li>使用中断的可编程I/O方式<br>CPU和I/O设备可以并行操作  </li>
<li>直接存储器访问方式  </li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android逆向学习</title>
    <url>/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是TG:HACK2020的一道比赛题目<br>题目给的hint很误导人…反正我没看出来  </p>
<a id="more"></a>
<blockquote>
<blockquote>
<blockquote>
<p>Hint<br>Random title?  </p>
</blockquote>
</blockquote>
</blockquote>
<p>这是题目描述：Someone found this very old game lying around. Apparently there is an extremely funny joke in there somewhere.</p>
<p>之前没怎么做过安卓题目，所以这次真是学到了很多<br>题目的名字叫Bad intentions<br>上Google搜索之后发现是一堆歌曲，好吧这肯定跟题目没啥关系<br>当搜索apk intentions的时候就出现了有用的信息：<br><img src="1.jpg" alt="google搜索结果">  </p>
<p>所谓的apk intentions就是指这个程序能不能被外部访问，或者进行数据交换  </p>
<blockquote>
<blockquote>
<blockquote>
<p>Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动 作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的 交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>然后就是如何查看这个apk包中有没有调用intent这个类了<br><code>aapt dump xmltree gaiainvaders.apk AndroidManifest.xml</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。  </p>
</blockquote>
</blockquote>
</blockquote>
<p>关于AndroidManifest.xml这个文件的介绍<a href="https://www.jianshu.com/p/3b5b89d4e154" target="_blank" rel="noopener">点这</a></p>
<p>就会输出如下信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E: activity (line&#x3D;19)  </span><br><span class="line">    A:android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;20)</span><br><span class="line">          E: action (line&#x3D;21)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;23)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br><span class="line">    E: activity (line&#x3D;26)</span><br><span class="line">        A: android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.JokeActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.JokeActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;27)</span><br><span class="line">          E: action (line&#x3D;28)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;30)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看出了是调用了intent类的，而且发现一个JokeActivity的类。联想到题目描述觉得应该是这个文件了，用jeb打开看一下(我当时做这道题的时候没想到这，被其他地方误导了)  </p>
<p><img src="2.jpg" alt=""></p>
<p>这是JokeActivity方法，我当时被这个给迷惑了…  </p>
<p><img src="3.jpg" alt=""></p>
<p>到这可以看出来是个AES加密，写出脚本就可以跑出来了(大概，我没试)<br>还有一种更简单的方法<br>学习一下<br>上述提到了intent这个包，它是对于Android程序安全性相关性很大的包，有了它之后我们就可以对这个APK进行调试<br><code>adb install gaiainvaders.apk</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>adb全称Android Debug Bridge，是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。说直白一点就是通过adb可以实现<strong>用命令行控制设备。</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>使用adb有两种方法  </p>
<ol>
<li>需要安装安卓手机模拟器，这里我选择了网易的mumu模拟器，安装之后在<strong>platform-tools</strong>下运行adb程序<br><code>adb connect 127.0.0.1:7555</code><br>每个模拟器默认的端口不一样，具体的<a href="https://www.cnblogs.com/HakunaMatata-/p/10609307.html" target="_blank" rel="noopener">看这</a><br>等它显示success之后就表示连接上了，之后执行安装命令就好了  </li>
<li>用安卓手机之间连接，手机进入开发者模式，cmd中输入<br><code>adb devices</code><br>之后就安装就可以了  </li>
</ol>
<p>然后我们只需要运行JokeActivity这个类就能得到flag了，这里用<br><code>adb shell am start -n &quot;no.tghack.gaiainvaders/.JokeActivity&quot;</code>  </p>
<blockquote>
<blockquote>
<blockquote>
<p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.</p>
</blockquote>
</blockquote>
</blockquote>
<p>启动的方法为</p>
<p><code>adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}</code>  </p>
<p>然后就得到了flag<br><img src="4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python2的encode(&#39;hex&#39;)在python3上的解决</title>
    <url>/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  </p>
<a id="more"></a>  

<p>python2对于字符串转换成hex编码的时候使用的是str本身具有的方法，即str.encode(‘hex’)<br>但是这个方法在python3中取消了，解决方案如下：<br>首先  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; bytes(str,encoding &#x3D; &#39;utf-8&#39;)  </span><br><span class="line">str1.hex()</span><br></pre></td></tr></table></figure>
<p>即可  </p>
<p>顺便扩充一下知识：  </p>
<h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><h3 id="1-使用bytes函数创建bytes"><a href="#1-使用bytes函数创建bytes" class="headerlink" title="1.使用bytes函数创建bytes"></a>1.使用bytes函数创建bytes</h3><ul>
<li>bytes() 创建一个空的bytes  </li>
<li>bytes(int) 创建一个int位的全位0的bytes  </li>
<li>bytes(iterabl_of_ints) 可迭代数字组成的bytes(比如range)</li>
<li>bytes(string,encoding[,errors]) 等价于string.encode()</li>
<li>bytes(bytes of buffer) 创建一个bytes的copy  </li>
</ul>
<h3 id="2-直接定义"><a href="#2-直接定义" class="headerlink" title="2.直接定义"></a>2.直接定义</h3><p>比如：</p>
<p>​ b = b’abc’</p>
<p>​ b = b’\x61’</p>
<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><ul>
<li>string.encode()</li>
<li>int.tobytes()</li>
<li>bytes.from</li>
<li>bytes函数定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes()</span><br><span class="line">b&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(3)</span><br><span class="line">b&#39;\x00\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(range(3))</span><br><span class="line">b&#39;\x00\x01\x02&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;中国&#39;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(b)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br></pre></td></tr></table></figure>


<p>直接创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; b&#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<p>类型转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; 97</span><br><span class="line">&gt;&gt;&gt; n.to_bytes(1,byteorder&#x3D;&#39;big&#39;)</span><br><span class="line">b&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;中国&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.encode(encoding &#x3D; &#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;61&#39;)</span><br><span class="line">b&#39;a&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytes的显示方式"><a href="#bytes的显示方式" class="headerlink" title="bytes的显示方式"></a>bytes的显示方式</h2><blockquote>
<blockquote>
<blockquote>
<p>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</p>
</blockquote>
</blockquote>
</blockquote>
<p>只有ASCII中的字符串是可以直接在bytes类型中显示出来的，所有大于127的数值用转义字符表达。</p>
<p>比如，内存中的字节对象用十六进制表示为61，在python中显示的方式不是b’\x61’ 而是b’a’；而b’\xe4’显示方式就是b’\xe4’；注意：仅仅是显示方式而已</p>
<p>另外，并不是所有的小于127的都可以被友好的显示出来，有些对象本身不可显示，就显示其十六进制表示。比如</p>
<p>b’\x00’</p>
<p>bytes的一般方法<br>bytes类似于string；在方法上，除了自己特有的方法外，跟str也类似。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.find(b&#39;\x63&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.replace(b&#39;\61&#39;,b&#39;A&#39;)</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure>
<h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><p>bytearray是可变的bytes数据类型，可以通过bytearray创建和定义</p>
<h3 id="一：bytearray-定义"><a href="#一：bytearray-定义" class="headerlink" title="一：bytearray()定义"></a>一：bytearray()定义</h3><ul>
<li><p>bytearray() 创建一个空的bytearray</p>
</li>
<li><p>bytearray(int) 创建一个int位的全位0的bytearray</p>
</li>
<li><p>bytearray(iterabl_of_ints) 可迭代数字组成的bytearray(比如range)</p>
</li>
<li><p>bytearray(string,encoding[,errors]) 将一个字符串编码为bytearray</p>
</li>
<li><p>bytearray(bytes of buffer) 创建一个bytearray</p>
<h3 id="二-bytearray的方法定义"><a href="#二-bytearray的方法定义" class="headerlink" title="二: bytearray的方法定义"></a>二: bytearray的方法定义</h3></li>
<li><p>bytearray.fromhex()  </p>
<h3 id="bytearray的一般方法"><a href="#bytearray的一般方法" class="headerlink" title="bytearray的一般方法"></a>bytearray的一般方法</h3></li>
</ul>
<p>bytearray具备bytes的操作方法，像字符串一样操作；</p>
<p>另外bytearray还具备像list一样的操作方法，比如pop，append等</p>
<h3 id="bytes-和-bytearray的方法"><a href="#bytes-和-bytearray的方法" class="headerlink" title="bytes 和 bytearray的方法"></a>bytes 和 bytearray的方法</h3><p>十六进制和字节类型的相互转换  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bytes.fromhex()</span><br><span class="line">bytearray.fromhex()</span><br><span class="line">bytes.hex()</span><br><span class="line">bytesarray.hex()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; ba &#x3D; bytearray(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;hell&#39;</span><br><span class="line">&gt;&gt;&gt; ba</span><br><span class="line">bytearray(b&#39;hell&#39;)</span><br><span class="line">&gt;&gt;&gt; b.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&gt;&gt;&gt; ba.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br></pre></td></tr></table></figure>

<p>但是decode的好像没有特别好的办法除了使用binascii模块…  </p>
<h2 id="binascii模块的使用"><a href="#binascii模块的使用" class="headerlink" title="binascii模块的使用"></a>binascii模块的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>binascii模块包含很多用来方法来转换二进制和各种ASCII编码的二进制表示法。通常不直接使用这些功能，而是使用封装模块，如uu, base64或binhex。binascii模块包含用C语言编写更快的低级功能，通常为高级模块所使用。  </p>
<ul>
<li>相关模块  </li>
</ul>
<ol>
<li>base64 模块</li>
<li>binhex 模块</li>
<li>uu 模块</li>
<li>quopri 模块  </li>
</ol>
<h3 id="UU编码"><a href="#UU编码" class="headerlink" title="UU编码"></a>UU编码</h3><p>相关函数binascii.a2b_uu(string)和binascii.b2a_uu(data)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="Binhex编码"><a href="#Binhex编码" class="headerlink" title="Binhex编码"></a>Binhex编码</h3><p>相关函数有：binascii.rledecode_hqx(data) ，binascii.rlecode_hqx(data)，binascii.b2a_hqx(data) ，binascii.crc_hqx(data, crc)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>binascii.a2b_base64(string)：转换的base64数据块为二进制，并返回二进制数据。一次可以传递多行。和base64. b64decode对应。 binascii.b2a_base64(data)：转换二进制数据为一行base64编码的ASCII字符。返回字符串包含换行符。根据base64的标准data的长度最大为57。和base64. b64encode对应。，更多资料点<a href="http://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">这</a>  </p>
<h3 id="QP编码"><a href="#QP编码" class="headerlink" title="QP编码"></a>QP编码</h3><p>Quoted-printable，或QP encoding，没有规范的中文译名，可译为“可打印字符引用编码”、“使用可打印字符的编码”。Quoted-printable是使用可打印的 ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。  </p>
<p>QP使用”=”开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.  </p>
<p>binascii.a2b_qp(string[, header])：转换引述打印数据块为二进制，并返回二进制数据。多行可以在同一时间被传递。如果可选参数头存在和真实，下划线将被解码为空格。  </p>
<p>实际上，QP码是是把’\x00’转换成’=00’，也就是替换’\x’为’=’。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D;&#39;\x00&#x3D;&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;&#x3D;\x00hello&#39;</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; encoded &#x3D; binascii.b2a_qp(s)</span><br><span class="line">&gt;&gt;&gt; encoded</span><br><span class="line">&#39;&#x3D;3D&#x3D;00hello&#39;</span><br><span class="line">&gt;&gt;&gt; decoded &#x3D; binascii.a2b_qp(encoded)</span><br><span class="line">&gt;&gt;&gt; print decoded</span><br><span class="line">&#x3D;hello</span><br><span class="line">&gt;&gt;&gt; print repr(decoded)</span><br><span class="line">&#39;&#x3D;\x00hello&#39;</span><br></pre></td></tr></table></figure>

<h3 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h3><p>binascii.crc32(data[, crc])：计算的data 的32位校验和CRC- 32时，crc为初始CRC 。crc32与ZIP文件的校验和一致。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print binascii.crc32(&quot;hello world&quot;)</span><br><span class="line">222957957</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot;hello&quot;)</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot; world&quot;, crc) &amp; 0xffffffff</span><br><span class="line">&gt;&gt;&gt; print &#39;crc32 &#x3D; 0x%08x&#39; % crc</span><br><span class="line">crc32 &#x3D; 0x0d4a1185</span><br><span class="line">&gt;&gt;&gt; crc</span><br><span class="line">222957957</span><br></pre></td></tr></table></figure>

<h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><p>binascii.b2a_hex(data)和binascii.hexlify(data)：返回二进制数据的十六进制表示。每个字节被转换成相应的 2位十六进制表示形式。因此，得到的字符串是是原数据长度的两倍。 binascii.a2b_hex(hexstr) 和 binascii.unhexlify(hexstr)：从十六进制字符串hexstr返回二进制数据。是b2a_hex的逆向操作。 hexstr必须包含偶数个十六进制数字（可以是大写或小写），否则报TypeError。  </p>
<pre><code>&gt;&gt;&gt; s = &apos;hello&apos;
&gt;&gt;&gt; b = b2a_hex(s)
&gt;&gt;&gt; print b
68656c6c6f
&gt;&gt;&gt; a2b_hex(b)
&apos;hello&apos;
&gt;&gt;&gt; b = hexlify(s)
&gt;&gt;&gt; print b
68656c6c6f
&gt;&gt;&gt; unhexlify(b)
&apos;hello&apos;</code></pre><p>参考博客：<a href="https://www.jianshu.com/p/701960098b7a" target="_blank" rel="noopener">https://www.jianshu.com/p/701960098b7a</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译</title>
    <url>/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>今天由一道入群题入手之后了解到了静态编译这个知识：  </p>
<ul>
<li><a id="more"></a>  

</li>
</ul>
<h3 id="1-静态编译："><a href="#1-静态编译：" class="headerlink" title="1.静态编译："></a>1.静态编译：</h3><p>编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，<br>使可执行文件在运行时不需要依赖于动态链接库.</p>
<h3 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2.动态编译:"></a>2.动态编译:</h3><p>动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一<br>方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>
<p>然后静态库的连接与使用看<a href="https://www.cnblogs.com/xiaotianxiedaima/p/9824643.html" target="_blank" rel="noopener">这</a></p>
<p>IDA使用sig文件的说明看<a href="https://www.jianshu.com/p/7a1441e4f355" target="_blank" rel="noopener">这</a><br>但是我的libc.a是在/usr/lib/x86_64-linux-gnu下的并不是这篇博客的libx32下的<br>然后这道题好像因为glibc版本的关系，还是有一些库函数没被解出来，所以我被迫爆破出了flag…  </p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Diary</title>
    <url>/2020/03/21/kittener&#39;s%20blog/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="290e199acad66200eb3d0022e9e7606322a286a1095b6deec02f71a0ebdc78b4">638d200a7a6cc82e36cc5fe4837307bf2f1b2c0e755fa0341ce2aa62d621334ca03f47f0d1d23791e3c383e9c3c5299c0699a0325d9275d45ad0615f9d79a1f456850b84327df89dac6eb7ec5bc8f05b25879971126fb0b3e37254699e1af27abe27d0c4fda4d1e2d1454366e96bc8616f2a9b700ee381de8cebdf7490123091716a07b0ff8ad54771aa2f99a6e48e9d1e60afe0c4fdc77e1e4742363a0200716163f991198267ffcb3052e34c4ccb749051d227eb21eec619f09e9269cf606c22470e1eb0cd6811843959bb4c155136863ab6685af267a4849dec7688b3b6399deb9ec86eefdc1e70d086c9dab34d391010deac696aee1b4d38c6d18e1942dd3695290d9ce96ce24b883ba31bd49e439e0144324d81b27a9e20b08975fb3f79475e9a9d3ea1b650fc139abd05971fc89c353c784490d09fd67dcaea2bc8d1556d35cffa37bd4937a8ab872036b3fc90291448fa41049b965f32b10afb4df7e550b8a6b2d3dc52c2d6c26f6401e4df353f01e3ef97b6e594e09579e794c9e21ed99e9d4b71e90a535c8820e8bdd2e03ea93c9468ca6b99a6d28d1583c0799787cda60074849e0e3446e032de1fc4d474db50c7818be62e4baf892c413371effd03c5c65a7ebc7e439179a6754e05719b9e01fa5cae26523dfa4ea64b57d7a486c6a023596b0330ce2cefc0f566f03a6d451ebc41e3dd88ef4d9b860608128954dff88086364e9574a21655a975d7857130fdbc9bae6fc23902154f3ba47f40bc0f4349165bea34e57aa19f88bd72d6719393397aca9ecb7d0c54fb505ad5d5a5aba9d9a8ca92cffe4af76ad62e093e879b56d138a5d7b53e55ef7d24fbecc534031422708e6f678dcdb082de4b33e542fdc9325152bad46f65ffce0e0c94d4c7aae301cb5fca3ce99307eb39ad6f163e9918a689e1f2086af73b792bee815fdb03ede02ccfc5f84786227440a318b66b3890f3b793bcdf7dfd7439aaa269d3f0c02770c92cd662de08ef98839db2ba60cdfd491056c2ba094175bdf1cd5308b53113486e0ef93a3594a9bf29792bfcab4ba10b0dc816fa7e9ce6c2a0b25db76856a3da698968823b1eb8039e7b126823dc3badbbc6c7a022e0b6677a370907262a74ab3b4a930b82cce6a7ccef9fa2fcfc8269c2cb557884ba8adce1eb17430b1aae55bad0cff501a07b2203558d17bcd5564bb16706f0a13faa89ca79f7c416301a33c47259d548758c820e9532ec426b06c4af781a2efff58acb74ed504493584c0e087c59e80934b5004c5897c41bebd3d3d2bfe0aabb9fb38214dfb7229560e3616c25e4d066fa48ca197583ee4ae50ef6afa37b21084f049b36181c33200953172bd26d863d344eff7a1c975f1a0f28af0d989b89bf4bd565405e7b273222551b942b18e4fcc29ece69132c9fe2c78f844ef1ab40ab1167ad2797089d4aa5793952cfed4296ab8e488f7a4e70bf0c6b2e3f1b4939c9f5caf27ea6facbcd94419018eb1543488b853ca96d28e5f5e0c8c4b3652ca931c7877b591933fea338a8e8ec6aeaa38eb84b46c89fcf92291d1c7274d0382c5d586f019d05785a1a48e6e61511e28e361cb2174b532b8cd9b5156a66d036e4e188e840242ca4f91f9210f4c56d8148cb3a4475a09e2537a29cc7d0fc0a621f1a52a01166e074f5213eab1e951dc654a600c570e911d675ada4c0da88c88681486d946ea21786e26d9e04b657bb5bf114e6151941cd771771af082d80f9839f0a29888d39db4cc6205e7eab242027709aad2bff5513f704cf60a331b89c727458e68aee1f4598ff1ad826bdfdeaf507b038fab2b2bdfaaae14137cd633f58fd3c6bbe8b390792114a666b6b0f7cbb0b27e8c605914b3561b42fc469d680d8c12c9b95d57e3a05bbc1c994479ff64a4b39bbe74e5d1f261caf596255f144fd45de662254b84c316946ff5c439babf95ec79ce1e3d7c67d92d975369ea4b3ee53e8be0c7156df5b7e8ae7969044f28f7f338e81d05564df252ada33c5c9f114cfc238271fc2e95881e2d658897af7ba97021d1ed60fc6a710c17361975b2199252b6426f3ff8614c9c2da70a09176bba02f715ae72af18e337c0a216bb6bcd2ce49675322a170000a772778e60f2bce645a5c03209dd8ff373849e9373507637a8de5833cc9ea3bc078d5d3513f50ed9b86028c4ba9be43e840b6c3cbd17f8faa95ac2e211787452d191906e35577a141cb044424b03df6f208a24c4533cbb1a30c19c2bbccc753b4f6d698ba94ee5fee0d51af608c266aa9dd8de21a5f7b01a0e4264c798f2faba1d29eb972f4e3895d3d91f7c72399af449cda1e140c8ecd7e907e9a258fa2ccba15b271ac3f4e23bc6a2b7a77306070c2a508587b41ca684b8312fcc710bc0d7796eede8e954b8303b0d9a564d963a965bb494b558e8c5ad9c4f158e07858f94c7a5895a3541648d98a317ea115c2901da7dec9d401ea8cc0c0ad746ee9b7253e666f7dd768d8a0a0ce935b7241931d51dbdc0944b355ff09dd41b6848464136c16470ea117837be4115dcac6d31347b04518f1fa2adc08492bd5dfb4d10cb84b2a0e814772737e2c9e814466e62efa40ac3bb6d0df9e61769f48eca2aeac5542dc3d2066e0a21a944db5b314d9c22980a7bd482b7ff79544a0034e0c5849b6c591d579926459ca7e8114d206a58817d88803d834b4e7ede5d7611bf8a122b3bee581171dca2d0dc2bf6e3f963710fa3834f2f2375a66167489aeea159613d9d8cfa5651c7aeee13e9dc5e0b4bd0dc681422a2d182c41ab21eec77e2bfde40ca2241c14e63548df95e630bc0f670aec926dfffba04f558aefc5d9b9113b505e3836e0797b9df41fefc0db2d24ee9abffd7bae940ccb4e1a4c03cddd0f06763ee536bf48055e877e357d1b6f00e4645d5a4d04e6c371bb48ebdfc9afec146c93e0526300a2dc0012840bb6d661f216b28d8174237e9ae5b8fbb2e9aab04a259d774955b0fc84fd36dfec49978b8607981acb7d047b3d240b38b9236357931973ece042d5ce2041c81a94b36b0717458d6e411e3f9bf4bb0700547c8e3ec5360ab216b46e6f4552cc62685bc87ae73e9e85f128ab6de424a45413d2704bea3b3c4b8de38dcc2a82aa40124cd8cc40d8d97119b9664a31929dfa3bc85a8e838198a8299df9a732a00fff268342b3d04d5455987f61a115056639b64688a54c04f3f09cf59f8a737c73b0c6e9fb12383b800c537d9142d9774fa1a656331ab3aee794362e76b5bd92fb1b4b86ceb59b792e44986a28f1ac6f4321753ec7dcadae498eedd4d461960b0bdf187570081192b13f145f067ae392d7512bd5a4acf614ca037ec89838fb61fbbce3007786b75ad2bc9fc9f766c5da345134cb541bb102b5725fe96177cfd97bf82b11e95616c6c813a01f9623eff58e61a54214eeb80a9708f31aeef989492898ff2de5b8b16b92b6e8c154411e1f67b395b6df099c60ca6bd140a619a6a687cab3ea6c7563739a243a9f339e7321e4a425a99eda623d95a2b50b55ae7a0b0da9d0ab504349fb6d48a48205a61da8d99a38e531e564ed05c45cb4116892b2b14cef9772f7d45c5f93f6aa54bd0b9813528de423ea6a6bf1e1f497690d9e1e3c92826c306f09bf0c0ca7f32c08e156b9d55f23ca90ecc3161de234a8d44b480b74d6d9836fba55cd13b5ca981999ad3107f564cbd85fde400e009b49bb2bcc5183b0c17e1ebb56e6741349364439f177fd953fba10093274013a71edb155fa192ee8997e18b90e91c60cb69edd1dcd0a6fca670230e31895aba355fa73680be8bb89b642d35dea91c4b329b0f83551793e63f223e7bcb4b316b2ec5fd925e24e351aa1cbc66ccb58b5b8d62b4439eeb3ba134fd0acaf994ef696dd3731e605b36766a1a3892102d0895e8c02919044a244e188bce4c27d19d64ba0f42b4aa2e4a2ca7d87a7284e2833ec78cd5a54f827123469954df58a419b2e96f5ef702efcacfc366d6e9c41673635679a6d3aae52ee9ef0360f074910cd288cc7585028200affac4a457dd9d1cc2b2183eacf320fb416ec0aa28f48ca7db9c79c95fbf9a36fdb0b2bef7693048cb662e8db1351f9d75083d080c5374a0e9af302c7906702ba0f4d58ffd7fdff5e5fae483c9834b8c1915ebf5ba1015f8baafa09b3bd285e63c0bd6925e8defff9bc23e4435f302ca26686458c7a66e0d01da1c0d7aa7401543956b889e0b2e800428a8c5179d8707ae1e22523928c656a27fc96182771cfef7c6e3414d165671a28b77262374035183cb3848e9c97b3ffa41ba8cd4f331049f4d24e6d1617bad452f8ba7eb2cfb3b0ea3c847e5b5bdf893448e70e9ae749acb14e84a7c1c4d0e75666a8d291b972bfa2ab0d50b0049108092762b93e6114b13a5d93850712954f809dd81a774d31f6b7b2ba114580930cc4bbd22b1abddb2f342aeef9dee7f1fd727acbe6abae0722f1f0b690e3958948744319ab6f750f708654df740ba52c7d190c775d23a068800bc856d0238544f2ba3ef81aec2cc11962824d2436d08e05873ce3c3fbd4921c16d1356a9f5984abe3a4256c93a261836db169d6b2d17034581a2ba1decea7d512ebd1a0ff2bfc5415028607366d59a35f948ebc3c9b0c3ce2573723d8bed58050abb55c1c1b7be5f6f24eb24b8c53dcb38c26cec46fbae3467b44bcc93acdd8f2ec90af8e8f6b3048fa635e13c28aa55b6c2fc03c849a9961433fe714dc7695df9bd4a8c6ea075f7d384e7fabf2400c14c1e8df4d0d7a4a257aac418ac52acd698687ed67122e90d6aa1b32a878908b56802564ef458e7be471b0ce2cb90fa91d5de15233e4584f8ccab0a8d2fb2bbf631eb55c1898c76f469431c33b58fedd664e8d078fe833325b2c2d35c92a12ef015855c2a6024cd1b32c9e82dcce4d16bd0be5f4721943807df19ecc71a6fce792b16b2289e077bb62bf5828ac4246b6e87e11fa45fb8dd1be7eb10b6c9bc9e6500b04045483eba52eec239f18214e6877386723dd6883cdba1df32512933b67acc29fb27fb0f33210042c90496f6ed840d0343727befdf910808cae04fcf14f10d1e05e5b6e0fa12b03c367bd6045ea32d729bd711fda3725e11504f479676f66a144ee56d3a4b156ad4f26bc54f05653bcf2e4cb05e1ab13afa4ce68e6f6e8212e08bbdb5c2b8db2f6ee80ffe8423762244aead3639cb85b416245c4d0668920739a32ca2ce7e75f5be02c5d0afc55db3ce7ddb0b53a3b3fef8b52ae8043b40de4745fe88afa2b3c2bbc3ca35a8f625a146764b236b42af25bcc74cf95e1e39a4f880be4a2864402bae7bafb3303988a627ac3888e5c02ebd432afecf96abd930d85d251bd52521034164402960a5fb41cd6b26590b8f05d86f37b677674fb87ee5861e607963c5e17f0d95edfc01a6c289c9672f3f24e5a97b7e288e65f93bc00375aebd859845c6dba644ae9d4fed84818b560c2f67f47f3376433dee20a9fafc1ad2cf512288dec08170875f029486ff3b0785835db85c01300f2c1149ce6a813c63cf182b5cc37a839ba65bc938f71fe3d3b9343a9d7a1c72c87dc9a76b237961ffe2a7c4d2a2d7cfb8a88db6be6f898aa67fcf2f64c5bc83243b83c8cbbed370eef6f6fd00f19ca9fa1f07792deb46ca01c1f256e1f67227fa5909b3a2fa53d87fd9e6a3d5a4ec972a36e5486fc5a1d75a5a3cc1ca3611991b59751c570d6cdc71ac3b66d2adc83a764c746b86ce100a0a7893f944f43423901762f5fa8048741b89c45fe6e237900eca9d694490fba267782344d86e56a60fedb574f57605319cdc37b7cfee444707328055e002d89008607f73eb96f19f8dcd19627116d73ff414371fe26cfbd3e4e0d56a544e584bb8a05478041abb31a9d499c4daae107e56fb0d31d720a396c6cfdb5866195b19ecc2f949f403a10914d0dec35cabc51ad95dd3f26e09663b1d3a1241a631da8b9b0a6139c2f62dc6ed69809d9535f52a7761b07ba35a71635028d06dbbf1f375cb8ed13f8ce69641102eeff3b1d5ff67badee5696cadd6bacbbe2b666f3177bb91ab508eb137cc210b970ce4447ffe7b673f67453c820b75f88b7c985bcb8be930b38fadc502a5046d019d7cec1e3137eb3f4d2bf6a405680608c1ae528aeec61ee2568ae6e8fa11f1c827181ea007a6907cee6d897ade99f71db6ec029a95afadec2e8bce96476ab410676f2eec73d1c461d4a6d67e9f92ecf731e3d59b8a3de49bcd643ba805d9fed0bc974ccb51f47ba67327a14cf517fcc62173fe238f186d88d86d0aecc1e88491d7fa391b9b66f516948e11fea9a42461a8b92a9f9df27602e083e4cd06d5d0ea2302e462a91d30792cbdf8558b990f9d2b9ba4a85c4be449641935dd9a2679ada3d9828e805e9e4d5aa4c805861f3e367664418d948ccb66d2149ceb181f0817d74aba9cdfbdd790d089cc22f8c8273ed359d92562a144897b03b8c478dde3a0b386cfe38cbbab9253cf83dc1f51071a8a1b10dbc26a183e5bc983c297f299bffe96a75bd13f90c7f1cb6c1a099f47de3070d196416a58bd9186e381a10055fae79740b7c9b7d5916a4aac840cd1fddb12de19a7f808bb7c5802fb60dd6f5040a4facdf7d4a6b668ff3004a4e86a888f418a279c724296f5e705e50798076c623c5352ecab5ed5df08d5712e07c707ab1c6cf28b4a485de7c34169ab885692a11a5cfdbc87723b3949da69a60129a7a5dca22ad2d22ba6f3af4f4322331aa044484d2844e83120a44be99d0df1d7d1168306794d5388388b0e85be3221e6c7eb00e55df7714146681079a2e2a97b88d72678cb77666d27dc50c52d439af5fd4e389e4b521cf86c0530280dc50cc98f0c9f1be79049a5e372405b850aab61d7d7909e472e39c7a11781d6f45ea12275011089030ab21f6a44e0d3cfeaf318537a31739449afdad76171d2d16f1ec08b0b1d0c580a73ce89cfb1d61b8211e9a0fe64d5f425537b336acfcb752e159c49d3e12093e9b00b1ffe2de5dea43db4073541d0fd5adcd44110163a73e1c66625a60264be2d529f4d63bc3d3170ebbc61919c06c61e5deb9b77f7abb8af770c7688361ea6c2b8eb7b68f4bec3144095a2b5447acbee2b87d50494b8312c7aecfecd1978dee81ffa70dc84ea18bb585f77472f44ade7c4ad1af67ed3e05a6a4b8759791548f9380330e946298ca89ad3e576a4fc25e7b2d67a441ff750e7c8e85fe64725bc3bb682464a39ac4330dfbdc83300225fcf15875367a6d451d91b443bcd4da5f86096f059662eaeef2032db348ea1726b4a744421aa98bac454b6450460c32f1ca46be9c6848ce65cfc748c7d81726cdef6fae338e7d9cab52aaf894df46295ab662cfe876b5cafee6b01b7b1fc9bec00b72bc81c7e0c60dc7062a9241aab81144acd4717fc947bcbb24f2bf912be944f7ad4190cb1053074eefef60bdc2d15c6d6b74c819f311afcf75eb176eefc6593ae693adb1d4b528f728a6ad426ca345bcdf0248a959687a96304f721abb320ed9a4fc28d09dfea77b65bba88f1523772158883f3911657c987e917b0f81726368514a77be78ef27da7593f8b5de440c7707322acb7822fb709c4375095549a53c023bf77a33dbafd7e2e6f4035bf42bcb966b14291cb5c98112db56590e90c62759f6c658c9476aa01ec0a782ecf80d9429b3645349378e9434e405e0707fe7d0cfbb296f867107d8784f8110f6437817c48693a290883e58b845b7af406ab8d85f18debe121e311eb6cf91234117bdea2ef6647d4e4c0d1c75a5503e591a2ec773b0349c8fec256556e97e9ca624c71ca719501b7bf9fbb8c0492412a495872b5c21814048f2871efffff070a677a3aef0e2b14fbef2a66cb098a4549d85f9922b66ad5c63754bd976ae06ee92db8701ee244cfc998fb16fecb2c81db0b02b92768bf5cef4d4a19078cf082359b255ef5c494546ed5aa4266a8657f9daa3d7e68453ccbf2115bb94d884afa2f41acd0b0a14a12883e4005e51e1d2317a27f15b4dc96dc88b891acf73719cf4a66395c83b08b74e511ab9dfd8231a70500b0a742dd04d0543409100c67a8d42a074894a104fcdab75ac5f6c0727184b42baebbc75c341744ad5b90ab85b9ab873870ae71ad6db2220693cc7a2ec73c7a293df3b2dc1b2e7298edfe0f7d400f92c7fbb3b0b655ddebc2ce7694057748d131f3840b6e96092af16ac123c2644afb84b32a4ba8c92f88ea803d001e622ce69946101b069efac352a77146e3f7dfde5b9656fc0597e530183556bb9c33d3e4beaba4b6eb71294eb43e5130da7c4f7080c74636d9d414631ed5f34fc14e3f09a4e9364cca1794409047daeb7ff2ee8f4bc838c2d3ebafad4591395784f011c0e059ee0513607c5997965b9a14e7492ec5001bb37c0bb6336b1e22ec867aa2d0a73e12d4cb15d2b41cf7f1b0cc24ae4ae2d64f102ba98a0f27706d10a94c3ad6d12bc75fbd195c9bfdc11f72b6bd3fdad1fc83adf6cdcfe84b069ea19cc510902207ad8baeb98a6dc16b6cf18683a7ef213c1523afcbccd79f6302c3227c4046a977a0657e6e24455c720ad9e8379b7b3cb2492f8523a7733d8ca68e7fea1ee8ff5c124a25da1ccf9a673158c536d78c699511da81fb4c1a0d05bb4b104305bd853d6fc883605e8020bb1a3cdcd4637473e7b7405d448f01ecc5d4cc5f697f2b6d0af2bcabfa7a67c79a8758ecf554b7d233e6209805de7a8834d44e6420214997586634dfd4f846ad2dffa4122ac130f4ce80cdba07ca2e97e0d29063e5f5272ea6136174030dcbe9b9c898ca203c6558a50fd45adbc6c0b7acdba50d1f3e2385ffb2dc7d5823b4475106ae99a660d54607c47a6b24254ba2df3d4dde6734e4870b9b40b19238b2d440dd447ded19048565ea43821af246d23e05d3cb5761a528789c012f3bda475b1a15dae91bcba9155ccd2212e8782cd2e70e722e21442c41614d2d1e7a39bbd6a9104e1d5339007ed6557dd358f6bd864d1ac23e068c1d9f4bac48d4b798c8f630dc451f453126849ce25bae4285e726ad97ee2df57c1eacc602e967e39feb27685f4853ab8e90ace5405d5f94071f111cbf6b26366d44ca854edc4be87c64953819185e694a77cc3902da11737f0d1b7b932232ad24f5843b9f31e61f2be118311653967ae857e1232fa3e341f473e284ae013ea589d0c22ee5ab263debc8187f52dfe123f8d9abe0d6ce274c78a8854651a24a5a028df9c00e7a650e4550d963d9bbcbf446182b0253f513fac141ca76de23dd4a6ef9554f8a635d02a9fcbb59a296f64027db69ad458282584bba180dcc10bec00edc9bb331053c9c884437c44ef3c6780c52696e77a07b3132fae1bb927566ade4b367e06eddd6b538e0ffebae9641da1c805b384ffe05215ba72ec98206e68e003113d7ff58b0cbdfe8e5aa012f884486f8058eac3e8fd86ca91886989355bdba08a11d066805ca1a56e7edef56c49f19480ffd84357420152e7845d3e9d1a96dd8fcc2be020c60bdbb7878d5a8d3e7f69cf0ba673eb5a671d1fee64af191aa5b78847e1944bc27905541a691a0e0f9d0d4f297a6e3d7ac6a84aeec84045024b71a7db75a50b8388cc03c51c4b780f186c266814ceac50f648ddb178c3a4f4c9a0a290ad8660ec990d6445314168c52f9103e6da24cd0349234796a978aea0a3eaa852be86fb504c13664cf947bb070febeca103fb15a96325e98e050f6fb373d18265cf586c77ce51c97a252eadfbd01405464037a29f1f222ba1899250f3387e9a31fe8ea477d4a45f9d5e86fa05f8d258df879e79b56fa20ee2e6e03baf9c622cfabdf7c217453a075c33c21f293c4282c0a916d15e3e7ce53bcb3255840e8035029dcc1f76055053e2286bb3953c58f0dcda3c8aac8eebf8a7863b27c34627ee2536562a3ea1942294da5afdf1e8dac15e0efa8af1b12af1550506796636fcc9c2b6296249a05fa9f97454008d0490e0958ab0ec7f3b2468557d0639df9bf8e172143beb256cf4a973920e40c5c88cfa5f02ac53b07c3fc620231640252b73ab8b99940da14dbe62c21161879c1dce2bfd6bca3239f07a8589a2acd22693e0a5a12560b354061408e8910ae22f99c88e7921c3dc0aecc7cc6ec7ef71a51fad10ac4834d9053e529fea9a76117c058f71881b567dc0ffba7d3c33d93e24082e131e602b6b35e55b0027925814442b7361a838142bcc6ef3e37f67c4038bec3e19d3d2e425e82d4f10d8914cd630f0f3a24dd21abbf71902e34ba3633c753aaa32403685134b1d5c993d2bcb86403f32cdac9026ee0fd949d411843987a663b422d3d744d533149b5b6cdd0ed69e0f5f3274ad23e085dc31bae2021687a6fade2214f101447e3cdc149358add34d90958c27b1bf7475f3261375e5c394a860ffa1be2975f61d946a3ceafa560c7271c7fcdb3dcddce13836cd05af5ec0330365d2805995defe5b77906bcbbefe8ed3fe19d8fdd4ffd282bf15088f07106fa49010b1ce5590fddd08a7cb367bf3c0d09b284f52409fb886e88318ed6fb8fa771460b8bf88fec34fec7bc68db9a15b46d29aefc2340c71ba9427e1bd33978c82465b3e093b1cfbe327d427ef95634d3964c3d9f20ad8c200d0ee7bfec241887b5e80fd2205327cf6d7c7b98577f6b5502e8ff710083d77f70cb62aee8ae34064c1ac83c20b4e92cadbb67e467fd0380b7c4b15834f76918740bcb53aac08aa40234acbf9e8e31b5d0634303b0b62f2a38b19623fe801dc83e13a7c678fbb7dda67a5abcd538155cb7b5f41cb707092ff69171c9f878ad26826b19b751ec043a0fe3cc832aa61be6c13da42fde7c40fecc29607040f4269324c2e7cf1dde6884c3e29481b23043d03dd577a7d47f548e0c82971d68b4be23cb8cb5d89f9715cdf90cedc2d5cfd4557daad2af2f7bf7a01156703a280731b03b09432f82684ecedd854477e022402fba09792d5f644b20f897209c2e61920e932075390808323b8a295a3cfeb4cdee6c3f529d7bf30c40c06297b7ce0a92595acbf09f79de661e4faa02f2a3d36e4228da1cc5105b761a710a25de050edf3d42d821eb4999a34f3218a83b2cf41de28e964653e37dda7927f5ad9f792ada323e761bcb20f945e6bd7ae86edb2afec98f02f67378d494b74cd8b71d2fc8ffae2023ab341cb491173fb283ba6d7dc2f2b291fe83464604b5b9ff0ccb9522051c286d14a9c778a71bc1df4200a6713dc6442346f9621aaf09bc5412099a2a6d03d2537335e3bdbc11e31a3014876d7c4d46785816042b8b64d60b63e7075f8a3bde933ff7dba418302c4a86eb7a2a6ffb9e07ea2008a9362c4aefed5769774765af55f8b3080202ffc490553204b051d2c0007d7c3af4b6e457d55046e41e274e2115d265f1f0d6e9e53f3b2d4e4df0115161ebebaf56757b1790cb64bba20875a6ba3d89c2a02e6e3b0fd8d4513d3ba0ea42dd20e1582f0b4497c6944807b92020e92ba0c6881b7758b14eda6ba3e308a4804abc20cee8a1a4bf7abb4269c180055f4ab4b9530688dbfaf6b81e75c45741e03fd4c30e2540d4f581fe0b58a5dffded2b3fde5063e7a14b290f02601b2a307679520bd3666bf301e1ca5f721e56e2e69de2605226141cde73eb8cbd6a468179d5c3d446def051220fea311311ff0205de820862aa457413cb5dad6ac78090b27a93f267c67857097cf635e46bc9f2e5e9ff4737ef187bef9ab19557379e5aa930c88ddccc353ff5471d7a0d83ea1d18167bc73f2a1d76a34bd31348fb8dae13b1a66670b272bf1bcfc7f55b1f7c339aefd4ef1e0c9ba71ec4e11408af6972a92e015eaa8d67e8dd1028a7c1907521f91ba339dd16f6cb37e05348c76f1212f184a452c15b7cb7232ec2c8bbeba2110c3ade5d68f3dfa46ddb2ad66e133c6c58810822aeaf968525f1a9245db4f7b4dfa7041e5c3df5bc74542fd4c5127def0a59ad40177e956cea0dd3da8b428eb60086fdb082f206e8db262ad01be7798ad3ac718d1c7d6fc34ad6ef34d6c976c02a5cd15bb523374aba81c1d0b6e121929fe3bec23c127f59bc1e74c55266b5bd6d39bae8a9ed61e2f6ba937f9c025274e5b5b3d02c3c3802eae89cba7100b6a355d7726d81c39614e2659cb2a57760d882b90f21f77d735cd8164ab9d2acdcdb1927ca5f03a74f00d818d32efbff02c8aa20b12f9747553c9c3fea7e82f4829ed8d15fe0fd26386f062970838a28198bae6bd4272c75e52364fd5d6b1b5f50d954e762ac93e88794c6c3188006e0d828855890ad0fa9b012a67e98e327ed4e0493dcf14d1b9f3cd1621932211037af656f4c91408280e6271a59b19615fce7f2a699c144436ad2fe6863539e4bf05eff054796f14dfdf377773380ac74dcdcb9e2a6e7aaa2b2bb3287f559f6253261886ee744f6cf0b4d61a76652433614b2f839a0b6daa9a8f165133328e62f80a870c9770368702cb4a64cc394f690ff3a840c6b491c167021eb5590f4da7119510afcc45e1298f8530dff69051cbeb82a691f56964f32180e0bbdecd11cc27ee0c1aece0b4318c6c366ae0f1038ad679da9f53612eea1ee8c01b1b655b76f6f9c1fac0f895da651fedd1f5d83775fc636772ef76c211aae954414e8ca70d5aa5e58d513ca9630302829cc915f73d93b7266d705b66de45723fa9a35b4952190740f72376222d90fc174520422dd0b2a2e061014b787bca2c5ef2c57edc28fb21bbabd63e1f8dd68c8b5f439c80d711a315f77c6c7dd61771e0d4cb18c4c5327d49d597e93edcfac6b1dc3446d8b0a6d261569c1eece03dfe43fa3951ab514f6088629e092f05239c4189bfd08e6a3a8a1dabaf0b41574d6496a77d7ec922bc0a9f6cc164e4e16d35c805387f630e4fbe58770b76fd163f0d5cbd038979750d35d25da5ec589fcb69256f923dce301d612164f02fdde0b5dcc144ef3d4d625423106747ce7d59bcd65ca6252c5de870803dff2610aac929d48c19fc49b42f11694e2e816f8f12d868e1c72e5c30a1260bb24360ea61314e700d24ec7ca94111a0428d26f9affb609f1f853e9d5b599f46ce0123c475bd1ad780ad322d86cbbc363b34b2a88ecc1343337609f09dce361bb8c6d5d8b5a89d894d3c6a83fa9775ae0582c00e00216107499edcb094d115c7556d5a9eca7c547e6ff5266db5b728999fb131e5964013c0f7d4d17d89159ff56fb5bb91bb7983c8b239f216b16b4473e99e95866d4d0bbf5720b48f0e423e29b2798b5da419650c240ad6e8589caf0c12a4ce2ed15d33d3e81122b3a92cb62ba2b725a2c951535cc4264827deaff6f04b87df7f3e8f38d6c4425a9872f63a94c8005e043f4a9ab54a8586f3799729be84ee67cf0ebaa7b5c418f3c900a61a608032587bbcc4424bf2961d9905ef0e81269a8e6d1eef7b88b76b0a71c59f636958e052cd0570d168db142ff42738ce6705b179007d98e9e46ae524e83f1e370ee948b7137b67db32ec555f742983cacd853447817ebc1227ca652b79e6a2c6291539b1018c793681ba19b494ca573754721389864accfc1a91e957f8a2495e04b501cf3b1632afba9b14b6c7a809944e73f134c9285fc2b4d9ca67dfd11628607f0ca3cf43ffc1707adba2d39e2420bc163a4d4c9e31925abd43e0e811d0ed2c3ae0fa8a81ed26d3f9f3fd8febc6b2be594574f98706725bae6685d73cf59f481deb5940588b9778e02584dd650a4b7cbfea5f5ea241f9ce73689e92605ca689f1f83a3d8d9b2dabcaba60ce6b0efc40356fec3ccc75d5fb86c7a2218d84f05a81f6d1ffa33800cad49afe39a752e13a8b6867f85e6600f4d7bd111f7d5d10a891f1a72436d2ba0e883238f505255dccec7a0dcfe9a1fc5efec7e583725cec6a3dbed636a62b110109acf610a7cae001b538d29e80be8e858ec0f4636c5f3e1d19ba8644c47aee848b00be927e7229e9d7bd0a8728b34d902aee04d740356d7ef21795b88ea0e3342167d2c7af484f475c36c1c486cf39b60089a080b4df8693eb4529735ce164fd3f91018c222213769d766d12d6fedea4358845185868e4b9eb5a27c2fff7d7d69db5a5485aff0026ad30ce4e6a0ffadbbcdc20278eb12b3c777f630ecda3c920e48da65dec467e3f12599f69fe7bae1dfeee7f64d32b6770d355d837fcaa26f748caacc55012c105d1450df53d94da527c3237df69bf4b5d8ff51b97e1de95534e97644aab6e935da135b0e2058f46e5432da8a85ffdfd893d67def3ffbf9bb3f056dcdbe6c0fd07778b0bc46a749a37c8e598f98d352b47fa069b4b843eac1608d06f2912dedf6b0bfa5520e81e83ded882410d50a7a216eb2298b0f14e116019b013a853d0db6a8fefcd2eb07b57643975b2143c0bd7427e9c1cfb2dc93fe73846dd4b23cc6b9f5f64a98a1efb488eb0073971cce4d014503f4a1be2a7284582735d4d99842274c521228fc062ad570f58b26030372ccddcd3dc548c9d7208b9d1be7834ab4f1a72f4529d57ea7eee2f8762611e26d15c0efcde65a0f4d1ee06f988064c76da4532b6fdb8d7d446d9d5a72b0d2d48b8d68caba75289307513c1739cb38be302dc45fc3b7e499b23bfbf3f35e85d57d8a88be4774e857f5c148ff9285b5fe79c2bc3ba3a23959d760ff19dff4f3e86a8b4099b702434459c04b7d0536d7b9cdb3d9afa3e7a03086d7044619aa6c8cff448399b18fcdd19709614513868484b8bdce193a3e047c16f4f1b9cd826d4986a8a0f12cb98d598a4751e30b1c6c23100db34bc2e2aff9d232d9df146225f8851b5cfc54456fd4fa1e28101f169b9c86a35aa60d48ca41105ca7369e41bbd71cc1b72c17bbfaa3055e523e96ece30a1140518200865e6fc6e62a613333ef21a45f48b8dd98dd3827bc0ae773014bc6e5883c2245b98fe8b64145be49ae72ee1d88705fbdd4cd3055ff15ddaf623ea6ee6550cfff399b02276123fb207ae84f8a99586391717fa85d185a6495b54b75ccb37c9f5c1ca9b23788554d6d7777cf83ab06e613faeef966cfc050fc7a9e4cb2d19ac8a0c84a1109aa276face2f24d790c80ef92cfd1efbe0078ba37e8e1c11257542f683fd23f1eb3b9607f2d1ba9e77f4e6b140deed7eb10e1a09817ac3f09ce9e1dce627c3c3e4068c69c5015434409a1bcaf3455e005341c67d86b15c26c705d724fa037c451face49de3ecbc6f175150c666106edd8a5232abf50cfcc3c2523119796f5dc42837610576db703f82ec53f5a59eddecce592570ad0e3fd9670f1c3bed29b346abdc836824d8e85cd31297e75db233fe18674d9346eb4076d8daf7d76388a61315f022294ae23485f78f0755439a8836a4022b3de4d628a85e8100d17987e3cb1806e13fdfbc41a7300dadf4ab0071608753dffbcfffd21b3eecedae6142ebde5ffd1a1a1b6f807b7a1620aada48d755148de06b73dd3a2165423a7e2b7c739d7fe0ca095e039d3fd5ae861c80329b446665fed8ef7978507930b0e0a20ba37d7fbeaaefefb1836464aad7658567a549c106e13017fdd4774cddc9b4234a774945a0cdcd7d752f7f2c2317a955af43232f931d1720d07dd102fc5adba7c91f66899f4ff7abf33931b876e94d561a488649e5d32af304e4ac35436dd83e380c72cf6bf8a072a4104b64e56a6df3cdedba2fa2ba8fcefac7548fc3c8ce0db8620990678641149f67218e0e6457d8178fb3a0d2ed29ae4bcf39e06936223792f8a2dc7e8390e0fc7374092ff102c5c4711ef812092c58b6fab2a409b60177bf54b75d94dac1465fe15bc1f535fd738d5a3e8d7bdf4c152da072911996d37c33ed90f70401d0db13ec216c0525ca42217282a9f991debdcf7c73811ab7f3b27a55ffb725213f620ca1b3a6c3c2a7cd31498751b09c11b630d0f6da775b5e3ec849491bfa24f6a703314e64dea3e161795c42ba3fb5a0cfb855621dc5ed3849f2235c208e959d339b1d421a01d6184f064c46e63858cfe04fafcb34c7ae90db39aa3f06bf3bd254d5ad7a93d91d17b17a7f8707824a1b88103b34b23fbacb5453182ecee3240d9fc6f55a738041417b1dc558fff46c5c54e63ff4d3182026241a180f783d41165f1f06891b4d5bbb3348e414df0273c21cb7e93e66020f8ffb82c7f716a49a9e5f413426549e401e4412eccd30b6bc591d67d051b5c82684d2f85a9020c4b297fa1294030f865ae2ea86d500b483fba3dd46f7653d97941fafbfcd06280c6ac3074cfe7ae7e15bbe914757779132808ec32000c8cc21cbf3679dd0715c4eae7b86bd1020d00b6f94c274ae2a28e8f48cac6f029a73fc165e1f8ee62133a84572c4e5c6ed052a2e31430713df6c67f6817b07b8b823fb6325751191e4518101527b21242b62d5a2ac2d207536886476afd099ef1f13d21633286816352279b5ffd0a9c67a32a694cbc266ad4d9968f7b2375a65f19cbe3681ed15dab04116ae8ca64573800d544bafaf76aa66abf817173340b505fc080f48c667e673fed4d6b93c920a8aa03327ed6433dc369e815244b7cfc34197783c9289ad778e48eeb5b68c69094f62001f8a87f2e88554fc827b8921ef79fd25ebb7cbd30d6641030bd8258c36e3501a6b5fca1ba685b2ce913d6bf60fbe862a0b1295564bd4c49e560efff9509507d7cf7a39e942b45b78ee045b7610551572117c63191e5ef201c075120e22de0498d4d9516819c8d19b2331a476c8404197ab7763061e959fca974e5054f8ea182d41f1477b74157a79397d3baf04b184201dddef7114da97747f609484202f989a319cb2aa76032c8f2261df0e60549814a81a1c2524f72ca73b27f2334d2cc20ab0ffc9c85966f0b12188bacb8a5021a41eb0635ef6ee</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/19/hello-world/</url>
    <content><![CDATA[<p>这里是我的blog，记录自己的学习足迹，日常吐槽的地方，欢迎大家一起交流学习！</p>
]]></content>
  </entry>
</search>
