<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="RUQLkWDKqj" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记," />




  


  <link rel="alternate" href="/atom.xml" title="Kittener's blog" type="application/atom+xml" />






<meta name="description" content="记录一下《C++反汇编与逆向分析技术》(四)">
<meta property="og:type" content="article">
<meta property="og:title" content="C++反汇编与逆向分析技术(四)">
<meta property="og:url" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/index.html">
<meta property="og:site_name" content="Kittener&#39;s blog">
<meta property="og:description" content="记录一下《C++反汇编与逆向分析技术》(四)">
<meta property="og:image" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/P1.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/P2.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/P3.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/P4.jpg">
<meta property="article:published_time" content="2020-06-19T15:40:25.000Z">
<meta property="article:modified_time" content="2020-08-06T01:44:56.663Z">
<meta property="article:author" content="Kittener">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/P1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.kittener.top/2020/06/19/C-反汇编与逆向分析技术-四/"/>





  <title>C++反汇编与逆向分析技术(四) | Kittener's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kittener's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kittener">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kittener's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++反汇编与逆向分析技术(四)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-19T23:40:25+08:00">
                2020-06-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-08-06T09:44:56+08:00">
                2020-08-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/19/C-反汇编与逆向分析技术-四/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录一下《C++反汇编与逆向分析技术》(四)  </p>
<a id="more"></a>  
<h1 id="变量在内存中的位置和访问方式"><a href="#变量在内存中的位置和访问方式" class="headerlink" title="变量在内存中的位置和访问方式"></a>变量在内存中的位置和访问方式</h1><ul>
<li><p>变量的作用域</p>
<p>指的是变量在源码中可以被访问到的范围。全局变量属于进程作用域，也就是说，在整个进程中都能够访问到这个全局变量;静态变量属于文件作用域，在当前源码文件内可以访问到:局部变量属于函数作用域，在函数内可以访问到;在“{}”语句块内定义的变量，属于块作用域，只能在定义变量的“{ }”块内访问到。</p>
</li>
<li><p>变量的生命周期</p>
<p>指的是变量所在的内存从分配到释放的这段时间。变量所在的内存被分配后，我们可以形象地将这比喻为变量的生命开始;变量所在的内存被释放后，我们可以将这比喻为变量的消亡。</p>
</li>
</ul>
<h2 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h2><p>在大多数情况下，在PE文件中的只读数据节中，常量的节属性被修饰为不可写，而全局变量和静态变量则在属性为可读写的数据节中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int g_nVariableType &#x3D; 117713190;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">008F19D0 55                   push        ebp  </span><br><span class="line">008F19D1 8B EC                mov         ebp,esp  </span><br><span class="line">008F19D3 81 EC C0 00 00 00    sub         esp,0C0h  </span><br><span class="line">008F19D9 53                   push        ebx  </span><br><span class="line">008F19DA 56                   push        esi  </span><br><span class="line">008F19DB 57                   push        edi  </span><br><span class="line">008F19DC 8D BD 40 FF FF FF    lea         edi,[ebp-0C0h]  </span><br><span class="line">008F19E2 B9 30 00 00 00       mov         ecx,30h  </span><br><span class="line">008F19E7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  </span><br><span class="line">008F19EC F3 AB                rep stos    dword ptr es:[edi]  </span><br><span class="line">008F19EE B9 26 C0 8F 00       mov         ecx,offset _DC5A83E8_main@cpp (08FC026h)  </span><br><span class="line">008F19F3 E8 33 F8 FF FF       call        @__CheckForDebuggerJustMyCode@4 (08F122Bh)  </span><br><span class="line">	scanf_s(&quot;%d&quot;, &amp;g_nVariableType);</span><br><span class="line">008F19F8 68 00 A0 8F 00       push        offset g_nVariableType (08FA000h)  </span><br><span class="line">008F19FD 68 30 7B 8F 00       push        offset string &quot;%d&quot; (08F7B30h)  </span><br><span class="line">008F1A02 E8 4D F7 FF FF       call        _scanf_s (08F1154h)  </span><br><span class="line">008F1A07 83 C4 08             add         esp,8  </span><br><span class="line">	printf(&quot;%d \r\n&quot;, g_nVariableType);</span><br><span class="line">008F1A0A A1 00 A0 8F 00       mov         eax,dword ptr [g_nVariableType (08FA000h)]  </span><br><span class="line">008F1A0F 50                   push        eax  </span><br><span class="line">008F1A10 68 34 7B 8F 00       push        offset string &quot;%d \r\n&quot; (08F7B34h)  </span><br><span class="line">008F1A15 E8 2C F6 FF FF       call        _printf (08F1046h)  </span><br><span class="line">008F1A1A 83 C4 08             add         esp,8  </span><br><span class="line">&#125;</span><br><span class="line">008F1A1D 33 C0                xor         eax,eax  </span><br><span class="line">008F1A1F 5F                   pop         edi  </span><br><span class="line">008F1A20 5E                   pop         esi  </span><br><span class="line">008F1A21 5B                   pop         ebx  </span><br><span class="line">008F1A22 81 C4 C0 00 00 00    add         esp,0C0h  </span><br><span class="line">008F1A28 3B EC                cmp         ebp,esp  </span><br><span class="line">008F1A2A E8 06 F8 FF FF       call        __RTC_CheckEsp (08F1235h)  </span><br><span class="line">008F1A2F 8B E5                mov         esp,ebp  </span><br><span class="line">008F1A31 5D                   pop         ebp  </span><br><span class="line">008F1A32 C3                   ret</span><br></pre></td></tr></table></figure>

<p>通过对代码的分析可知，访问全局变量与访问常量类似——都是通过立即数来访问。由于全局变量在编译期就已经确定了具体的地址，因此编译器在编译的过程中可以计算出一个固定的地址值。而局部变量需要进入作用域内，通过申请栈空间存放，利用栈指针ebp或esp间接访问，其地址是-一个未知可变值，编译器无法预先计算。</p>
<p>全局变量在内存中的地址顺序是<strong>先定义的变量在低地址，后定义变量在高地址。</strong></p>
<p>全局变量的特征：</p>
<ul>
<li>所在地址为数据区，生命周期与所在模块一致</li>
<li>使用立即数间接访问</li>
</ul>
<p>局部变量的特征：</p>
<ul>
<li>所在地址为栈区，生命周期与所在的函数作用域一致</li>
<li>使用ebp或esp间接访问</li>
</ul>
<h2 id="局部静态变量的工作方式"><a href="#局部静态变量的工作方式" class="headerlink" title="局部静态变量的工作方式"></a>局部静态变量的工作方式</h2><p>静态变量分为全局静态变量和局部静态变量。</p>
<p>全局静态变量等价于<strong>编译器限制外部源码文件访问的全局变量。</strong></p>
<p>局部静态变量比较特殊，它不会随作用域的结束而消失，并且在未进人作用域之前就已经存在，其生命周期也和全局变量相同。<strong>局部静态变量会预先被作为全局变量处理，而它的初始化部分只是在做赋值操作。</strong></p>
<p>来个demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：全局变量的访问</span><br><span class="line">void ShowStatic(int nNumber)&#123;</span><br><span class="line">	static int g_snNumber &#x3D; nNumber;				&#x2F;&#x2F;定义局部静态变量，赋值为参数</span><br><span class="line">	printf(&quot;%d \r\n&quot;,g_snNumber);					&#x2F;&#x2F;显示静态变量</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; 5;i++)&#123;</span><br><span class="line">		ShowStatic(i);								&#x2F;&#x2F;循环调用显示局部静态变量的函数，每次传入不同值</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ShowStatic 函数内实现过程</span><br><span class="line">void ShowStatic (int nNumber) &#123;</span><br><span class="line">;在Debug版下保存环境、开辟栈、初始化部分略</span><br><span class="line">static int g_snNumber &#x3D; nNumber;					&#x2F;&#x2F;定义局部静态变量</span><br><span class="line">0040D9D8	xor		eax,eax							;清空eax</span><br><span class="line">;取地址0x004257CC处1字节数据到al中</span><br><span class="line">0040D9DA	mov		al, [&#39; ShowStatic&#39; : :&#39;2&#39;: :$S1 (004257cc) ] </span><br><span class="line">;将eax与数值1做位与运算，eax最终结果只能是0或1</span><br><span class="line">0040D9DF	and		eax,1</span><br><span class="line">0040D9E2	test	eax,eax</span><br><span class="line">;比较eax， 不等于0则执行跳转，跳转到地址0x0040D9FE处</span><br><span class="line">0040D9E4	jne		ShowStatic+3Eh (0040d9fe)</span><br><span class="line">;将之前比较是否为0值的地址取出数据到c1中</span><br><span class="line">0040D9E6	mov		c1,byte ptr [&#39; ShowStatic&#39; ::&#39;2&#39;: :$S1 (004257cc)]</span><br><span class="line">;将c1与数值1做位或运算，cl的最低位将被置1，其他位不变</span><br><span class="line">0040D9EC	or		cl,1</span><br><span class="line">;再将置位后的cl存回地址0x004257CC处</span><br><span class="line">0040D9EF	mov		byte ptr [&#39;ShowStatic&#39; ::&#39;2&#39;::SS1 (004257cc)],cl</span><br><span class="line">;取出参数信息放入edx中</span><br><span class="line">0040D9F5	mov		edx, dword ptr [ebp+8]</span><br><span class="line">;将edx赋值到地址0x004257C8处，即将局部静态变量赋值为edx中保存的数据</span><br><span class="line">0040D9F8 	mov		dword ptr [___sbh_sizeHeaderList+4 (004257c8)] , edx</span><br><span class="line">printf(&quot;%d \r\n&quot;, g_snNumber); &#x2F;&#x2F; 显示局部静态变量中的数据</span><br><span class="line">;局部静态变量的访问，和全局变量的访问方式一样</span><br><span class="line">0040D9FE	mov		eax,[__ sbh_sizeHeaderList+4 (004257c8)]</span><br><span class="line">;printf略</span><br></pre></td></tr></table></figure>

<p>地址0x004257CC中保存了局部静态变量的一个标志，这个标志占位1个字节。通过位运算，将标志中的一位数据置1，以此判断局部静态变量是否已经被初始化过。由于一个静态变量只使用了1位，而1个字节数据占8位，因此这个标志可以同时表示8个局部静态变量的初始状态。通常，在VC++6.0中，标志所在的内存地址在最先定义的局部静态变量地址的附近，如最先定义的整型局部静态变量在地址0x004257C0处，那么标记位通常在地址0x004257C4或0x004257BC处。当同一作用域内超过8个局部静态变量时，下一个标记位将会在第9个定义的局部静态变量地址附近。识别局部静态变量的标志位地址并不是目的，主要是根据这个标志位来区分全局变量与局部静态变量。</p>
<p>但是当局部静态变量被初始化为一个常量值时，这个局部静态变量<strong>在初始化过程中不会产生任何代码</strong>。</p>
<p>由于初始化的数值为常量，即多次初始化不会产生变化。这样无需再做初始化标志，编译器采用了<strong>直接以全局变量方式处理，</strong>优化了代码，提升了效率。虽然转换为了全局变量，但仍然不可以超出作用域访问。那么编译器是如何让其他作用域对局部静态变量不可见的呢?通过<strong>名称粉碎法</strong>，在编译期将静态变量重新命名。</p>
<p>来个总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; reg_flag表示存放初始化标志的寄存器r8，通常使用寄存器中的低位，如al等</span><br><span class="line">;INIT__FLAG表示初始化标记</span><br><span class="line">mov		reg_flag,	INIT_FLAG</span><br><span class="line">; reg_data表示存放静态变量初值的寄存器</span><br><span class="line">mov		reg_data,	mem				; reg_data值为初值，其来源可能因程序不同而不同</span><br><span class="line">test	reg_data,	1\2\8..0x80		;测试标志位</span><br><span class="line">jxx		INIT_END					;跳转成功，表示已经被初始化过</span><br><span class="line">or		reg_flag, 	1\2\8..0x80		;修改标志寄存器中的数据</span><br><span class="line">; STATIC_DATA表示静态变量</span><br><span class="line">mov		STATIC_DATA,reg_data		;初始化静态变量</span><br><span class="line">mov		INIT_FLAG,reg_flag			;修改该静态变量初始化标志位</span><br><span class="line">INIT_END;</span><br></pre></td></tr></table></figure>

<h2 id="堆变量"><a href="#堆变量" class="headerlink" title="堆变量"></a>堆变量</h2><p>new和malloc的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明(Debug 编译选项) ; new与malloc</span><br><span class="line">&#x2F;&#x2F; mal1oc 内部实现</span><br><span class="line">char * pCharMalloc &#x3D; (char*) malloc (10) ;</span><br><span class="line">_CRTIMP void * __cdecl malloc (</span><br><span class="line">	size_t nSize</span><br><span class="line">	)&#123;</span><br><span class="line">		&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">		return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;new内部实现</span><br><span class="line">char * pCharNew &#x3D; new char [10] ;</span><br><span class="line">void * operator new( unsigned int cb ) &#123;</span><br><span class="line">	return _nh_malloc( cb, 1 ) ;</span><br><span class="line">&#125;</span><br><span class="line">void *  __cdecl _nh_malloc (</span><br><span class="line">	size_t nSize,</span><br><span class="line">	int nhFlag</span><br><span class="line">	)&#123;</span><br><span class="line">		&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">		return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆空间的分配类似于商场中的商铺管理，malloc是从商场的空地中划分出一块作为商铺，而new则可以将划分好的商铺直接租用。由于malloc缺少商铺的营业范围规定，因此需要将申请好的堆强制转换以说明其类型方可使用，而new则无需这种操作，直接可以使用。</p>
<p>申请堆空间的过程中调用了函数 _ heap_ alloc_dbg， 其中使用 _CrtMemBlockHeader结构描述了堆空间中的各个成员。在内存中，堆结构的每个节点都是使用双向链表的形式存储的，在 _CrtMemBlockHeader 结构中定义了前指针pBlockHeaderPrev 和后指针pBlockHeaderNext，通过这两个指针就可遍历程序中申请的所有堆空间。成员lRequest记录了当前堆是第几次申请的，例如第10次申请堆操作对应的数值为0x0A; 成员gap为保存堆数据的数组，在Debug版下，这个数据的前后4个字节被初始化为0xFD,用于检测堆数据访问过程中是否有越界访问。 _CrtMemBlockHeader 结构的原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _CrtMemBlockHeader&#123;</span><br><span class="line">	struct _CrtMemBlockHeader *pBlockHeaderNext ;	&#x2F;&#x2F;下一块堆空间首地址(实际上指向的是前一次申请的堆信息)</span><br><span class="line">	struct _CrtMemBlockHeader *pBlockHeaderPrev;	&#x2F;&#x2F;上一块堆空间首地址(实际上指向的是后一次申请的堆信息)</span><br><span class="line">	char  * szFileName;</span><br><span class="line">	int	 nLine;</span><br><span class="line">	size_t	nDataSize;								&#x2F;&#x2F;堆空间数据大小</span><br><span class="line">	int  nBlockUse;</span><br><span class="line">	long  lRequest;									&#x2F;&#x2F;堆申请次数</span><br><span class="line">	unsigned char  gap[nNoMansLandSize];			&#x2F;&#x2F;堆空间数据</span><br><span class="line">&#125; _CrtMenBlockHeader;</span><br></pre></td></tr></table></figure>

<p>来个实操，我太懒了直接拿书上的图吧，嘻嘻嘻</p>
<p><img src="P1.jpg" alt="堆空间数据说明"></p>
<p>在图中，内存监视窗口的数据为使用malloc后申请的堆空间数据。new或malloc函数返回的地址为堆数据地址0x00431BF0，堆数据地址减4后，其数据为0xFDFDFDFD,这是往上越界的检查标志。堆数据地址减8后数据为0x2A,表示此堆空间为第0x2A次申请堆操作，说明在其之前多次申请过堆空间。堆数据空间的容量存储在地址0x00431BE0处，该堆空间占10个字节大小。地址0x00431BD0处为上一个堆空间首地址。地址0x00431BD4处的数据为0，表示没有下个一堆空间。在堆数据的末尾也加入了0xFDFDFDFD，这是往下越界的检查标志，这是程序编译方式为Debug版的重要特征之一。</p>
<h1 id="数组和指针的寻址"><a href="#数组和指针的寻址" class="headerlink" title="数组和指针的寻址"></a>数组和指针的寻址</h1><h2 id="数组在函数内"><a href="#数组在函数内" class="headerlink" title="数组在函数内"></a>数组在函数内</h2><p>对于数组的识别，判断数据在内存中是否连续并且类型是否一致，均符合即可将此段数据视为数组。</p>
<p>在C++中，字符串本身就是数组，根据约定，该数组的最后-一个数据统一使用0作为字符串结束符。在VC++ 6.0编译器下，为字符类型的数组赋值(初始化)其实是复制字符串的过程。这里并不是单字节复制，而是每次复制4字节的数据。两个内存间的数据传递需要借用寄存器，而每个寄存器一次性可以保存4字节的数据，如果以单字节的方式复制就会浪费掉3字节的空间，而且多次数据传递也会降低执行效率。如果字符串字节数不满足4的倍数，<strong>最后一次数据复制过程中按照1或者2字节的方式复制。</strong></p>
<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><p>来份代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组作为参数</span><br><span class="line">void Show(char szBuff[])&#123;</span><br><span class="line">	strcpy(szBuff,&quot;Hello,World&quot;);</span><br><span class="line">	printf(&quot;%S&quot;,szBuff);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	char szHello[20] &#x3D; &#123;0&#125;;</span><br><span class="line">	Show(szHello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">; Debug保存环境初始化栈略</span><br><span class="line">char szHe11o[20] &#x3D; &#123;0&#125;;</span><br><span class="line">; ebp-14h为数组szHello首地址，数组初始化为0</span><br><span class="line">0040B7C8	mov		byte ptr [ebp-14h] ,0</span><br><span class="line">0040B7CC	xor		eax,eax</span><br><span class="line">0040B7CE	mov		dword ptr [ebp-13h] ，eax</span><br><span class="line">0040B7D1	mov		dword ptr [ebp-0Fh] ，eax</span><br><span class="line">0040B7D4	mov		dword ptr [ebp-0Bh] ，eax</span><br><span class="line">0040B7D7	mov		dword ptr [ebp-7h] ，eax</span><br><span class="line">0040B7DA	mov		word ptr [ebp-3h] ，ax</span><br><span class="line">0040B7DE	mov		byte ptr [ebp-1h] ，al</span><br><span class="line">Show(szHello);</span><br><span class="line">0040B7E1	lea		ecx,[ebp-14h]				;取数组首地址存入ecx</span><br><span class="line">0040B7E4	push	ecx	</span><br><span class="line">0040B7E5	call	@ILT+5 (Show) (0040100a) 	;调用Show函数</span><br><span class="line">0040B7EA	add		esp,4</span><br><span class="line">; 略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Show函数实现部分</span><br><span class="line">void Show (char szBuff []) &#123;</span><br><span class="line">strcpy (szBuff, &quot;Hello world&quot;) ;</span><br><span class="line">;获取常量首地址，并将此地址压入栈中作为strcpy参数</span><br><span class="line">0040B488	push	offset string &quot;Hello world&quot; (0041f01c)</span><br><span class="line">;取函数参数 szBuff地址存入eax中</span><br><span class="line">0040B48D	mov		eax , dword ptr [ebp+8]</span><br><span class="line">;将eax压栈作为strcpy参数</span><br><span class="line">0040B490	push	eax</span><br><span class="line">0040B491	call	strcpy (00404570)</span><br><span class="line">0040B496	add		esp,8</span><br><span class="line">printf(szBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组作为参数时，数组的下标值被省略了。这是因为，当数组作为函数形参时，函数参数中保存的是数组的首地址，是一个指针变量。</p>
<p>在release版下，字符串处理函数会被作为内联函数编译处理，康康：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码对照</span><br><span class="line">int GetLen (char szBuff[] ) &#123;</span><br><span class="line">	return strlen(szBuff);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用O2选项后的优化代码</span><br><span class="line">sub_401000 proc near							;函数起始处</span><br><span class="line">arg_0 &#x3D; dword ptr 4								;参数标号</span><br><span class="line">push	edi</span><br><span class="line">mov		edi, [esp+4+arg_0]						;获取参数内容，向edi中赋值字符串首地址</span><br><span class="line">or		ecx,0FFFFFFFFh							;将ecx置为-1，是为了配合repne scasb指令</span><br><span class="line">xor		eax,eax</span><br><span class="line">;repne&#x2F;repnz与scas指令结合使用，表示串未结束(ecx!&#x3D;0)</span><br><span class="line">;当eax与串元素不相同(ZF&#x3D;0)时，继续重复执行串搜索指令</span><br><span class="line">;可用来在字符串中查找和eax值相同的数据位置</span><br><span class="line">repne scasb										;执行该指令后，ecx中保存了字符串长度的补码</span><br><span class="line">not		ecx										;先对ecx取反</span><br><span class="line">dec		ecx										;对取反后的ecx减1,得到字符串长度</span><br><span class="line">pop		edi						</span><br><span class="line">mov		eax,ecx									;设置eax为字符串长度，用于函数返回</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp									;函数终止处</span><br></pre></td></tr></table></figure>

<p>​    这个实现过程为先将eax清零，然后通过指令repne scasb遍历字符串，寻找和eax匹配的字符。由于指令repne scasb中的前缀repne是用来考察ecx的值，因此在ecx不为0且ZF标志为0时才重复操作，在操作过程中对ecx自动减1。</p>
<p>​    ecx的初始值为0xffffffff，有符号数值为-1，repne前缀每次执行时会自动减1，如果edi指向的内容为字符串结束符(asc 值0),则重复操作结束。注意，重复操作完成时ecx的计数包含了字符串末尾的0。假设字符串长度为Len,我们可得到等式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ecx(终值) &#x3D; ecx(初值) - (Len+1)</span><br><span class="line">将ecx初值 -1 代入得：</span><br><span class="line">ecx(终值) &#x3D; -1 - (Len+1) &#x3D; -(Len+2)</span><br><span class="line">定义neg为求补运算，则有:</span><br><span class="line">neg(ecx(终值)) &#x3D; Len + 2</span><br><span class="line">求补运算等价于取反加1，定义not为取反运算，则有:</span><br><span class="line">neg(ecx(终值))+1 &#x3D; Len + 2</span><br><span class="line">解方程求Len:</span><br><span class="line">Len &#x3D; not(ecx(终值)) - 1</span><br></pre></td></tr></table></figure>

<p>那strcpy函数原型也比较好分析了，release版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;main函数讲解略</span><br><span class="line">;Show函数实现</span><br><span class="line">;int __cdecl sub_401000 (char *Format) 				;函数类型识别</span><br><span class="line">sub_401000 proc near</span><br><span class="line"></span><br><span class="line">Format &#x3D; dword ptr 4								;函数参数识别</span><br><span class="line">push	esi</span><br><span class="line">push	edi</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;这段代码似曾相识，就是之前所分析的优化后的求字符串长度函数strlen的内联方式</span><br><span class="line">mov 	edi,offset aHelloWorld 						;&quot;Hello World&quot;</span><br><span class="line">or		ecx,0FFFFFFFFh</span><br><span class="line">xor		eax,eax</span><br><span class="line">repne scasb</span><br><span class="line">mov		eax,[esp+8+Format]							;取参数所在地址存入eax中</span><br><span class="line">not		ecx											;对ecx取反，得到字符串长度加1</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;执行指令repne scasb后，edi指向字符串末尾，减去ecx重新指向字符串首地址</span><br><span class="line">sub		edi,ecx</span><br><span class="line">push	eax											;将保存参数地址eax压栈</span><br><span class="line">mov		edx,ecx										;使用edx保存常董字符串长度</span><br><span class="line">mov		esi,edi										;将esi设置为常量字符串首地址</span><br><span class="line">mov 	edi,eax										;将edi设置为参数地址</span><br><span class="line">shr		ecx,2										;将ecx右移2位等同于将字符串长度除以4</span><br><span class="line">;此指令为拷贝字符串，每次复制4字节长度，根据ecx中的数值决定复制次数。将esi中的指向数据每次以4字节复制到edi所指向的内存中，每次复制后，esi与edi自加4</span><br><span class="line">rep movsd</span><br><span class="line">mov		ecx,edx										;重新将字符串长度存入ecx中</span><br><span class="line">;将ecx与3做位与运算，等同于ecx对4求余</span><br><span class="line">and 	ecx,3</span><br><span class="line">;和rep movsd指令功能奥似，不过是按单字节复制字符串</span><br><span class="line">rep	movsb</span><br><span class="line">call	_printf</span><br><span class="line">add		esp,4</span><br><span class="line">pop 	edi</span><br><span class="line">pop		esi</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>

<h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>​    数组作为函数得返回值与作为函数的参数差不多，都是将数组的首地址以指针的方式进行传递。不同点是当数组作为参数时，其定义所在的作用域必然在函数调用以外，在调用前已经存在，所以，在函数中对数组进行操作是没有问题的，而数组作为函数返回值则存在着一定的风险。</p>
<p>当数组为局部变量数据时，便产生了稳定性问题。当退出函数时，需要平衡栈，而数组是作为局部变量存在，其内存空间在当前函数的栈内。如果此时函数退出，栈中定义的数据将变得不稳定。由于函数退出后esp会回归到调用前的位置上，而函数内的局部数组在esp之下，随时都有可能由在其他函数的调用过程中产生的<strong>栈操作指令将其数据破坏</strong>。数据的破坏将导致函数返回结果具备不确定性，影响程序的结果，如图所示。</p>
<p><img src="P2.jpg" alt="栈平衡错误"></p>
<p>在图中，返回了函数GetNumber中定义的局部数组的首地址nArray,其所在地址处于0x0012FF00~0x0012FF1C之间。当函数调用结束后，栈顶指向了地址0x0012FF1C。此时数组nArray中的数据已经不稳定，任何栈操作都有可能将其破坏。</p>
<p>在执行“print(“%d”, pAray[7]);”后，由于需要将参数压栈，地址0x0012FF1C~0x0012FF18之间的数据已经被破坏，无法输出正常结果。</p>
<p>如果既想使用数组作为返回值，又要避免图中的错误，可以使用全局数组、静态数组或是上层调用函数中定义的局部数组。</p>
<p>well，全局数组就是很常见的那种，懒得放了，看一下静态数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">	int nOne;</span><br><span class="line">	int nTwo;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">	static int g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">int nOne;</span><br><span class="line">int nTwo;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">static in g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">0040B84D	xor		edx,edx</span><br><span class="line">0040B84F	mov		dl,byte ptr [&#39;main&#39; ::&#39;2&#39; :: $Sl (004237c8)]</span><br><span class="line">0040B855	and		edx,1</span><br><span class="line">0040B858	test	edx,edx</span><br><span class="line">0040B85A	jne		main+70h (0040b890)				;检测初始化标志位</span><br><span class="line">0040B85C	mov		al, [&#39;main&#39; :: &#39;2&#39; :: $S1 (004237c8) ]</span><br><span class="line">0040B861	or		al,1</span><br><span class="line">;将初始化标志位置1</span><br><span class="line">0040B863	mov		[&#39;main&#39; : : &#39;2&#39;: :$S1 (004237c8)] ,al</span><br><span class="line">0040B868	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">0040B86B	mov		dword ptr [&#39;main&#39; :: &#39;2&#39;::$S1+4 (004237cc)] , ecx</span><br><span class="line">0040B871	mov		edx, dword ptr [ebp-8]</span><br><span class="line">0040B874	mov		dword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+8 (004237d0)] , edx</span><br><span class="line">0040B87A	mov		dword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+0Ch (004237d4)] , 0</span><br><span class="line">0040B884	xor		eax,eax</span><br><span class="line">0040B886	mov		[&#39;main&#39; :: &#39;2&#39; : : $S1+10h (004237d8)] ,eax</span><br><span class="line">0040B88B	mov		[&#39;main&#39; :: &#39;2&#39; : : $S1+14h (004237dc)] , eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标寻址和指针寻址"><a href="#下标寻址和指针寻址" class="headerlink" title="下标寻址和指针寻址"></a>下标寻址和指针寻址</h2><p>下标访问(寻址): a[n]        <strong>效率高</strong></p>
<p>指针访问(寻址): *(a+n)</p>
<p>看一下区别，Debug版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：两种寻址方式演示</span><br><span class="line">void main()&#123;</span><br><span class="line">	char *pChar &#x3D; NULL;</span><br><span class="line">	char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">	pChar &#x3D; szBuff;</span><br><span class="line">	printf(&quot;%c&quot;,*pChar);</span><br><span class="line">	printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main()&#123;</span><br><span class="line">char *pChar &#x3D; NULL;</span><br><span class="line">004010F8	mov		dword ptr [ebp-4] ,0				;初始化指针变量为空指针</span><br><span class="line">char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">004010FF	mov		eax, [string &quot;Hel1o&quot; (00420030)]	;初始化数组</span><br><span class="line">00401104	mov		dword ptr [ebp-0Ch] , eax</span><br><span class="line">00401107	mov		cx,word ptr [string &quot;He11o&quot;+4 (00420034)]</span><br><span class="line">0040110E	mov		word ptr [ebp-8] ,Cx</span><br><span class="line"></span><br><span class="line">pChar &#x3D; szBuff;</span><br><span class="line">00401112	lea		edx, [ebp-0Ch]						;荻取数组首地址，然后使用edx保存</span><br><span class="line">00401115	mov		dword ptr [ebp-4] , edx</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,*pChar);</span><br><span class="line">00401118	mov		eax, dword ptr [ebp-4] 				;取出指针变量中保存的地址数据</span><br><span class="line">0040111B	movsx	ecx,byte ptr [eax]					;字符型指针的间接访问</span><br><span class="line">0040111E	push 	ecx</span><br><span class="line">0040111F	push	offset string &quot;%C&quot; (0042002c)</span><br><span class="line">00401124	call 	printf(00401170)</span><br><span class="line">00401129	add 	esp,8</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">;直接从地址ebp-0Ch处取出1字节的数据</span><br><span class="line">0040112C	movsx	edx,byte ptr [ebp-0Ch]</span><br><span class="line">00401130	push	edx									;将取出数据作为参数</span><br><span class="line">00401131	push	offset string &quot;%c&quot; (0042002c)</span><br><span class="line">00401136	call	printf(00401170)</span><br><span class="line">0040113B	add		esp,8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针寻址比下标寻址多一次寻址操作，效率自然低，但是指针寻址可以修改地址中保存的数据，访问其他内存中的数据，而数组下标在没有越界使用的情况下只能访问数组内的数据。</p>
<p>下标值的三种表现方式</p>
<ol>
<li><p>下标值为整型常量的寻址</p>
<p>编译器可以直接计算出数据所在的地址</p>
</li>
<li><p>下标值为整型变量的寻址</p>
<p>编译器先进行地址偏移计算，然后得出目标数据所在的地址</p>
</li>
<li><p>下标值为整型表达式的寻址</p>
<p>会先计算出表达式的结果，然后将其结果作为下标值</p>
</li>
</ol>
<p>顺带一提，数组越界就是下标越范围，蛮好懂的</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组在内存中的存储方式和一维数组是一样的，但在<strong>寻址方面</strong>，二维数组的寻址过程比一维数组多一步操作，先取得二维数组中某个一维数组的首地址，再利用此地址作为基址寻址到一维数组中某个数据地址处。</p>
<p>若其中某一下标值为常量，则不会出现二次寻址计算，二维数组寻址转换成汇编后的代码和一维数组差不多，因为下标值为常量，且类型大小可预先计算出，因此变成两常量计算。利用常量折叠可直接计算出偏移地址。</p>
<p>来个release版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">004B1090 55                   push        ebp  </span><br><span class="line">004B1091 8B EC                mov         ebp,esp  </span><br><span class="line">004B1093 83 EC 2C             sub         esp,2Ch  </span><br><span class="line">004B1096 A1 04 30 4B 00       mov         eax,dword ptr ds:[004B3004h]  </span><br><span class="line">004B109B 33 C5                xor         eax,ebp  </span><br><span class="line">004B109D 89 45 FC             mov         dword ptr [ebp-4],eax  </span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	int nArray[4] &#x3D; &#123; 1,2,3,4 &#125;;</span><br><span class="line">004B10A0 0F 28 05 40 21 4B 00 movaps      xmm0,xmmword ptr ds:[004B2140h]  </span><br><span class="line">	int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">	scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10A7 8D 45 F4             lea         eax,[ebp-0Ch]  </span><br><span class="line">	int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">	scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10AA 50                   push        eax  </span><br><span class="line">004B10AB 8D 45 F8             lea         eax,[ebp-8]  </span><br><span class="line">004B10AE C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0  </span><br><span class="line">004B10B5 50                   push        eax  </span><br><span class="line">004B10B6 68 08 21 4B 00       push        4B2108h  </span><br><span class="line">004B10BB C7 45 F4 00 00 00 00 mov         dword ptr [ebp-0Ch],0  </span><br><span class="line">004B10C2 0F 11 45 E4          movups      xmmword ptr [ebp-1Ch],xmm0  </span><br><span class="line">004B10C6 0F 11 45 D4          movups      xmmword ptr [ebp-2Ch],xmm0  </span><br><span class="line">004B10CA E8 81 FF FF FF       call        004B1050  </span><br><span class="line">	printf(&quot;nArray &#x3D; %d\r\n&quot;, nArray[i]);</span><br><span class="line">004B10CF 8B 45 F8             mov         eax,dword ptr [ebp-8]  </span><br><span class="line">004B10D2 FF 74 85 E4          push        dword ptr [ebp+eax*4-1Ch]  </span><br><span class="line">004B10D6 68 10 21 4B 00       push        4B2110h  </span><br><span class="line">004B10DB E8 40 FF FF FF       call        004B1020  </span><br><span class="line">	printf(&quot;nTwoArray &#x3D; %d\r\n&quot;, nTwoArray[i][j]);</span><br><span class="line">004B10E0 8B 4D F8             mov         ecx,dword ptr [ebp-8]  </span><br><span class="line">004B10E3 8B 45 F4             mov         eax,dword ptr [ebp-0Ch]  </span><br><span class="line">004B10E6 8D 04 48             lea         eax,[eax+ecx*2]  </span><br><span class="line">004B10E9 FF 74 85 D4          push        dword ptr [ebp+eax*4-2Ch]  </span><br><span class="line">004B10ED 68 20 21 4B 00       push        4B2120h  </span><br><span class="line">004B10F2 E8 29 FF FF FF       call        004B1020  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个”eax+ecx*2”保存了二维数组的两个下标值：i、j。寻址过程如下：</p>
<p>1)使用数组首地址加二维数组下标i乘以-维数组大小，得到一维数组首地址。<br>2)通过1)获取一维数组首地址后，加下标j乘以类型大小，得到的数据如下:<br>二维数组type nArry[M][N];使用i、j作为下标寻址<br>nArray + i * sizeof(type [N]) + j * sizeof(type)<br>= nArray+i* N * sizeof(type) +j * sizeof(type)<br>= nArray + sizeof(type)*(i *N +j)</p>
<p>三维数组类似，不列举了</p>
<h2 id="存放指针类型数据的数组"><a href="#存放指针类型数据的数组" class="headerlink" title="存放指针类型数据的数组"></a>存放指针类型数据的数组</h2><p><strong>存放指针类型的数据的数组</strong>就是数组中各数据元素都是由相同类型指针组成。</p>
<table>
<thead>
<tr>
<th align="center">组成部分1</th>
<th align="center">组成部分2</th>
<th align="center">组成部分3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型名*</td>
<td align="center">数组名称</td>
<td align="center">[元素个数]</td>
</tr>
</tbody></table>
<p>举个栗子，存储三个字符串”Hello”,”World”,”!\r\n”，指针数组是一维的，存储的是字符串的首地址，字符数组是二维的，将每个字符存储进去</p>
<p>这样寻址的时候，会发生差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	printf(pBuff[1]);</span><br><span class="line">01001958 B8 04 00 00 00       mov         eax,4  </span><br><span class="line">0100195D C1 E0 00             shl         eax,0  </span><br><span class="line">01001960 8B 4C 05 EC          mov         ecx,dword ptr [ebp+eax-14h]  ;一维数组寻址</span><br><span class="line">01001964 51                   push        ecx  </span><br><span class="line">01001965 E8 DC F6 FF FF       call        01001046  </span><br><span class="line">0100196A 83 C4 04             add         esp,4  </span><br><span class="line">	printf(cArray[1]);</span><br><span class="line">0100196D B8 0A 00 00 00       mov         eax,0Ah  </span><br><span class="line">01001972 C1 E0 00             shl         eax,0  </span><br><span class="line">01001975 8D 4C 05 C4          lea         ecx,[ebp+eax-3Ch]  </span><br><span class="line">01001979 51                   push        ecx  </span><br><span class="line">0100197A E8 C7 F6 FF FF       call        01001046  </span><br><span class="line">0100197F 83 C4 04             add         esp,4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符数组寻址后得到的是某一维数组的首地址</p>
<h2 id="指向数组的指针变量"><a href="#指向数组的指针变量" class="headerlink" title="指向数组的指针变量"></a>指向数组的指针变量</h2><p>当指针变量保存的数据为数组的首地址，且将此地址解释为数组时，此指针变量被称为数组指针。</p>
<p>指向一维数组的数组指针定义格式：</p>
<table>
<thead>
<tr>
<th align="center">组成部分1</th>
<th align="center">组成部分2</th>
<th align="center">组成部分3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[类型名]</td>
<td align="center">[*指针变量名称]</td>
<td align="center">[一维数组大小]</td>
</tr>
</tbody></table>
<p>对指向二维数组的数组指针执行取内容操作后，得到的还是一个地址值，再次执行取内容操作才能寻址到二维字符数组中的单个字符数据。看上去与二级指针相似，实际上并不一样。二级指针的类型为指针类型，其偏移长度在32位下固定为4字节，而数组指针的类型为数组，其偏移长度随数组而定，两者的偏移计算不同，不可混为一谈。</p>
<p>main函数的三个参数(main(int argc,char *argv[],char *envp[]))分别为：</p>
<ol>
<li>argc:命令行参数个数，整型。</li>
<li>argv:命令行信息，保存字符串数组首地址的指针变量，是一个指向数组的指针。</li>
<li>envp:环境变量信息，和argv类型相同。</li>
</ol>
<p>来个main函数参数的demo看一看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main(int argc, char **argv, char **envp &#125; &#123;</span><br><span class="line">for(inti&#x3D;1;i&lt;argc;i++)&#123;</span><br><span class="line">printf (argv[i]) ;</span><br><span class="line">00401112	mov		edx, dword ptr [ebp-4]		 ;取下标值i并将其保存到edx中</span><br><span class="line">;对指针变量取内容，得到数组首地址</span><br><span class="line">00401115	mov		eax, dword ptr [ebp+0Ch]</span><br><span class="line">;一维数组寻址，将得到的数组数据保存到ecx中</span><br><span class="line">00401118	mov		ecx, dword ptr [eax+edx*4]</span><br><span class="line">0040111B	push	ecx</span><br><span class="line">0040111C	call	printf(00401160)</span><br><span class="line">00401121	add		esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argv是一个参数，保存着字符串数组的首地址，因此需要”mov eax,dword ptr[ebp+0Ch]”指令队其取内容，得到数组首地址。</p>
<p>对三维数组 int nArray[2] [3] [4] 可转换成int (*pnArray) [3] [4] = nArray;</p>
<p>指针在地址偏移过程中需要计算出偏移量，因此需要所指向的数据类型来配合计算偏移长度。在多维数组中，可以将最高维看做是- -维 数组，其后数据为这个- -维 数组中各元素的数据类型。所以第一个维数可以省去。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>用于保存函数首地址的指针变量被称为函数指针。函数指针是不允许执行加法和减法运算的</p>
<p>来两份代码看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">函数指针与函数——Debug版</span><br><span class="line">void __cdecl Show()&#123;</span><br><span class="line">	printf(&quot;Show\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	void (__cdecl *pShow)(void) &#x3D; Show			&#x2F;&#x2F;函数指针赋值</span><br><span class="line">	pShow();				&#x2F;&#x2F;使用函数指针调用函数</span><br><span class="line">	Show();					&#x2F;&#x2F;直接调用函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">void (__cdecl *pShow) (void) &#x3D; Show;</span><br><span class="line">;函数名称即为函数首地址，这是一个常量地址值</span><br><span class="line">0040B90B	mov		dword ptr [ebp-38h] , offset @ILT+15 (Show) (00401014)</span><br><span class="line">0040B915	mov		edx, dword ptr [ebp-38h]</span><br><span class="line">0040B918	mov		dword ptr [ebp-38h] , edx</span><br><span class="line">pShow();</span><br><span class="line">0040B91B	mov		esi,esp</span><br><span class="line">0040B91D	call 	dword ptr [ebp-38h]			;间接调用函数</span><br><span class="line">0040B920	cmp		esi,esp						;栈平衡检查，Debug下特有</span><br><span class="line">0040B922	call	__chkesp (004012d0)			;栈平衡检查，Debug下特有</span><br><span class="line">Show();</span><br><span class="line">0040B927 	call	@ILT+15 (Show) (00401014)	;直接调用函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">带参数和返回值的函数指针——Debug版</span><br><span class="line">&#x2F;&#x2F;C++源码说明:带参数与返回类型的函数指针</span><br><span class="line">int	_stdcall Show(int nShow)&#123;</span><br><span class="line">	printf(&quot;Show : %d\r\n&quot;,nShow);</span><br><span class="line">	return nShow;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	int (__stdcall *pShow)(int) &#x3D; Show;		&#x2F;&#x2F;函数指针定义并初始化</span><br><span class="line">	int nRet &#x3D; pShow(5);					&#x2F;&#x2F;使用函数指针调用函数，并获取返回值</span><br><span class="line">	printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123; </span><br><span class="line">int (__stdcall *pShow) (int) &#x3D; Show;</span><br><span class="line">;初始化过程没有变化，仍然为荻取函数首地址并保存</span><br><span class="line">00408868	mov		dword ptr [ebp-4] ,offset @ILT+20 (Show) (00401019)</span><br><span class="line">0040886F	mov		eax, dword ptr [ebp-4]</span><br><span class="line">00408872	mov		dword ptr [ebp-4] ,eax</span><br><span class="line">int nRet &#x3D; pShow(5);</span><br><span class="line">00408875	mov		esi,esp					;保存进入函数前的栈顶，用于栈顶检查</span><br><span class="line">00408877	push	5						;压入参数5</span><br><span class="line">00408879	call	dword ptr [ebp-4]		;获取函数指针中的地址，间接调用函数</span><br><span class="line">0040887C	cmp		esi,esp					;栈顶检查</span><br><span class="line">00408883	mov		dword ptr [ebp-8],eax	;接收函数返回值数据</span><br><span class="line">printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><p>在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别:结构体的访问控制默认为public，而类的默认访问控制是private。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>一般来说，类对象的计算公式如下：</p>
<p><strong>对象长度 = sizeof(数据成员1) + sizeof(数据成员2) + sizeof(数据成员3) + … + sizeof(数据成员n)</strong></p>
<p>但是会出现以下例外：</p>
<ol>
<li><strong>空类</strong>。空类中没有任何数据成员，按照该公式计算得出的对象长度为0字节。类型长度为0，则此类的对象不占据内存空间。而实际情况是，空类的长度为1字节。如果对象完全不占用内存空间，那么空类就无法取得实例对象的地址，this 指针失效，因此不能被实例化。而类的定义是由成员数据和成员函数组成，在没有成员数据的情况下，还可以有成员函数，因此仍然需要实例化，分配了1字节的空间用于类的实例化，这1字节的数据并没有被使用。</li>
<li><strong>静态数据成员</strong>。当类中的数据成员被修饰为静态时，对象的长度计算又会发生变化。虽然静态数据成员在类中被定义，但它与静态局部变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见，同类对象将共同享有静态数据成员的空间。</li>
<li><strong>内存对齐</strong>。在VC++6.0中，类和结构体中的数据成员是根据它们在类或结构体中出现的顺序来依次申请内存空间的，由于内存对齐的原因，它们并不- -定会像数组那样连续地排列。由于数据类型不同，因此占用的内存空间大小也会不同，在申请内存时，会遵守一定的规则。</li>
</ol>
<p>重点讲一下第三种：</p>
<p>在为结构体和类中的数据成员分配内存时，结构体中的当前数据成员类型长度为M，指定的对齐值为N，那么实际对齐值为q = min(M, N)，其成员的地址安排在q的倍数上。如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct tagTEST&#123;</span><br><span class="line">	short sShort;</span><br><span class="line">	int nInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员sShort 的地址为<strong>0x0012FF74</strong>，类型为short,<strong>占2字节</strong>内存空间。VC++ 6.0指定的对齐值默认为8，short 的长度为2，于是实际的对齐值取较小者2。所以，short 被分配在地址0x0012FF74处，此地址是2的倍数，可分配。此时，轮到为第二个数据成员分配内存了，如果分配在sShort后，应在地址0x0012FF76处，但第二个数据成员为int类型，<strong>占4字节</strong>内存空间，与指定的对齐值比较后，实际对齐值取int类型的长度4，而地址0x0012FF76不是4的倍数，<strong>需要插入两个字节填充，以满足对齐条件</strong>，因此第二个数据成员被定义在地址<strong>0x0012FF78</strong>处。</p>
<p>上例讲到了结构体成员对齐值的问题，现在讨论一下对齐值对结构体整体大小的影响。如果按VC++ 6.0默认的8字节对齐，那么结构体的整体大小要能被8整除，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sruct&#123;</span><br><span class="line">	double dDouble;				&#x2F;&#x2F;所在地址: 0x0012FF00~0x0012FF08之间，占8字节</span><br><span class="line">	int nInt;					&#x2F;&#x2F;所在地址: 0x0012FF08~0x0012FF0C之间，占4字节</span><br><span class="line">	short sShort;				&#x2F;&#x2F;所在地址: 0x0012FF0C-0x0012FF10之间，占2字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中结构体成员的总长度为8+4+2=14，按默认的对齐值设置要求，结构体的整体大小<strong>要能被8整除</strong>，于是编译器在最后一个成员sShort所占内存之后<strong>加入2字节空间填补</strong>到整个结构体中，使总大小为8+4+2+2=16,这样就满足了对齐的要求。</p>
<p>但是，并非设定了默认对齐值就将结构体的对齐值锁定。如果结构体中的数据成员类型，最大值为M，指定的对齐值为N,那么实际对齐值为min(M, N),如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Struct&#123;</span><br><span class="line">	char cChar;					&#x2F;&#x2F;应占1字节内存空间，如所在地址为0x0012FF00</span><br><span class="line">	int nInt;					&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;				&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上结构应该按照4字节的方式对齐，其布局格式如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cChar		所在地址; 0x0012FF00~0x0012FF04之间，占4字节，对齐nInt</span><br><span class="line">nInt		所在地址: 0x0012FF04~0x0012FF08之间，占4字节</span><br><span class="line">sShort		所在地址: 0x0012FF08~0x0012FF0C之间，占2字节，另外填充2字节</span><br></pre></td></tr></table></figure>

<p>既然有默认的对齐值，就可以在定义结构体时进行调整，VC++ 6.0中可使用预编译指令#pragma pack(N)来调整对齐大小。修改以上示例，调整对齐值为1，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line">Struct&#123;</span><br><span class="line">	char cChar;					&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">	int nInt;					&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;				&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    调整对齐值后，根据对齐规则，在分配nInt时无需插入空白数据。对齐值为1, nInt 占4字节大小，很明显，使用pack设定的对齐值更小，因此采用对齐值1的倍数来计算分配内存空间的首地址，nInt 只需紧靠在cChar之后即可。这样cChar只占用1字节内存空间。由于设定的对齐值小于等于结构体中所有数据成员的类型长度，因此结构总长度只要是1的倍数即可。在这个例子中，结构总长度为7。</p>
<p>​    使用pack修改对齐值也<strong>并非一定会生效</strong>， 与默认对齐值一样，都需要参考结构体中的数据成员类型。<strong>当设定的对齐值大于结构体中的数据成员类型大小时，此对齐值同样是无效的</strong>。</p>
<p>当结构体中以数组作为成员时，<strong>将根据数组元素的长度计算对齐值，而不是按数组的整体大小去计算</strong>，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	char cChar;				&#x2F;&#x2F;应占1字节内存空间， 如所在地址为0x0012FF00	</span><br><span class="line">	char cArray[4];			&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;			&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    按照对齐规定，cChar 与cArray的对齐没有缝隙，无需插入空白数据，当cArray与sShort进行对齐时，cChar 与cArray在内存中将会占5字节，此时按照结构中当前的数据类型short进行对齐，插入1字节的数据即可，其结构布局如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cChar						所在地址: 0x0012FF00~0x0012FF01之间，占1字节</span><br><span class="line">cArray[4]					所在地址: 0x0012FF01-0x0012FF06之间，占5字节</span><br><span class="line">sShort						所在地址: 0x0012FF06-0x0012FF08之间，占2字节</span><br></pre></td></tr></table></figure>

<p>​    当结构体中出现结构体类型的数据成员时，不会将嵌套的结构体类型的整体长度参与到对齐值计算中，而是以嵌套定义的结构体所使用的对齐值进行对齐，如以下代码所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct tagOne&#123;</span><br><span class="line">	char cChar;				&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">	char cArray[4];			&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	short sShort;			&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br><span class="line">struct tagTwo&#123;</span><br><span class="line">	int nInt;				&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">	tagOne one;				&#x2F;&#x2F;应占8字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    在以上结构中，虽然tagOne结构占8字节大小，但由于其对齐值为2,因此tagTwo结构体中的最大类型便是int,以4作为对齐值。所以，结构tagTwo的总大小并非以8字节对齐的16字节，而是以4字节对齐的12字节。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>指针访问结构体或类成员的公式：</p>
<p>假设type为某个正确定义的结构体或者类，member是type中可以访问的成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type *p</span><br><span class="line">&#x2F;&#x2F;此处略去p的赋值</span><br><span class="line">&#x2F;&#x2F;以下是整型加法</span><br><span class="line">p-&gt;member的地址 &#x3D; 指针p的地址值 + member在type中的偏移量</span><br></pre></td></tr></table></figure>

<p>举个栗子~如果有以下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">	int m_int;				&#x2F;&#x2F;在结构体内的偏移量为0 </span><br><span class="line">	float m_float;			&#x2F;&#x2F;在结构体内的偏移量为4</span><br><span class="line">&#125;;</span><br><span class="line">struct A a;					&#x2F;&#x2F;假设这个结构体变量a的地址为0x0012ff00</span><br><span class="line">struct A *pA &#x3D; &amp;a;			&#x2F;&#x2F;定义结构体指针，并赋初值</span><br><span class="line">printf(&quot;%p&quot;,&amp;pA-&gt;m_float);	&#x2F;&#x2F;结果</span><br></pre></td></tr></table></figure>

<p>那么pA-&gt;m_float的地址=0x0012ff00 + 4 = 0x0012ff04</p>
<p>ok~，来看一份Debug版的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：类定义以及数据成员的访问</span><br><span class="line">class CTest&#123;</span><br><span class="line">	public:</span><br><span class="line">	void SetNumber(int nNumber)&#123;				&#x2F;&#x2F;公有函数成员</span><br><span class="line">		m_nInt &#x3D; nNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	public:</span><br><span class="line">		int m_nInt;								&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">	CTest Test;</span><br><span class="line">	Test.SetNumber(5);							&#x2F;&#x2F;调用成员函数</span><br><span class="line">	printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);		&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CTest Test;</span><br><span class="line">Test.SetNumber(5);								&#x2F;&#x2F;类对象定义</span><br><span class="line">0040B768 	push	5							;压入参数5</span><br><span class="line">0040B76A	lea		ecx, [ebp-4]				;取出对象Test的首地址存入ecx中</span><br><span class="line">;调用成员函数</span><br><span class="line"></span><br><span class="line">0040B76D	call	@ILT+10 (CTest::SetNumber) (0040100f)</span><br><span class="line">printf (&quot;CTest : %d\r\n&quot;, Test.m_nInt);</span><br><span class="line">;取出对象首地址处4字节的数据m_nInt存入eax中</span><br><span class="line">0040B772	mov		eax, dword ptr [ebp-4]</span><br><span class="line">0040B775	push	eax							;将eax中保存的数据成员m_ nInt向成员函数传参</span><br><span class="line">0040B776	push	offset string &quot;CTest : d\r\n&quot; (0042001c)</span><br><span class="line">0040B77B	call	printf(00401060)</span><br><span class="line">0040B780	add		esp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SetNumber函数讲解</span><br><span class="line">void SetNumber(int nNumber)&#123;					&#x2F;&#x2F; SetNumber成员函数实现</span><br><span class="line">0040B7B0	push	ebp</span><br><span class="line">0040B7B1	mov		ebp,esp</span><br><span class="line">0040B7B3	sub		esp,44h</span><br><span class="line">0040B7B6	push	ebx</span><br><span class="line">0040B7B7	push	esi</span><br><span class="line">0040B7B8	push	edi</span><br><span class="line">0040B7B9	push	ecx							;注意，ecx中保存了对象Test的首地址</span><br><span class="line">0040B7BA	lea		edi,[ebp-44h]</span><br><span class="line">0040B7BD	mov		ecx,11h</span><br><span class="line">0040B7C2	mov		eax,0CCCCCCCCh</span><br><span class="line">0040B7C7	rep stos 	dword ptr [edi]</span><br><span class="line">0040B7C9	pop ecx								;还原ecx</span><br><span class="line">;将ecx中的数据存入ebp-4地址处，该地址处保存着调用对象的首地址，即this指针</span><br><span class="line">0040B7CA	mov		dword ptr [ebp-4],ecx</span><br><span class="line">m_nInt &#x3D; nNumber;</span><br><span class="line">;取出对象的首地址并存入eax</span><br><span class="line">0040B7CD	mov		eax, dword ptr [ebp-4]</span><br><span class="line">;取出参数中的数据并保存到ecx中</span><br><span class="line">0040B7D0	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">;这里是给成员m_ nInt賦值。由于eax是对象的首地址，成员m_ nInt的偏移量为0,如果写成这样可能更容易理解: mov dword ptr [eax+0] ,ecx</span><br><span class="line">0040B7D3	mov		dword ptr [eax] , ecx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用默认的调用约定时，在调用成员函数的过程中，编译器做了一个“小动作”:利用寄存器ecx保存了对象的首地址，并以寄存器传参的方式传递到成员函数中，这便是this指针的由来。这样的默认调用约定称为thiscall。</p>
<p>在VC++的环境下，识别this指针的关键点是在函数的调用过程中使用了ecx作为第一个参数，并且在ecx中保存的数据为对象的首地址，但并非所有的this指针的传递都是如此。thiscall的栈平衡方式与__stdcall相同，都是由被调用方负责平衡。但是，两者在传参的过程中却不一样，声明为thiscall的函数，第一个参数使用寄存器ecx传递，而非通过栈顶传递。而且thiscall并不属于关键字，它是C++中成员函数特有的调用方式，在C语言中是没有这种调用方式的。因此函数无法显式声明为thiscall调用方式，而类的成员函数默认是thiscall调用方式。所以，在分析过程中，如果看到某函数使用ecx传参，且ecx中保留了对象的this指针，以及在函数实现代码内，存在this指针参与的寄存器相对间接访问方式，如[reg+8]，即可怀疑此函数为成员函数。</p>
<p>当使用其他调用方式(如stdcall) 时，this 指针将不再使用ecx传递，而是改用栈传递，举个栗子~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组和局部变量的定义以及初始化</span><br><span class="line">class CTest&#123;</span><br><span class="line">	public:</span><br><span class="line">	void __stcall SetNumber(int nNumber)&#123;				&#x2F;&#x2F;公有函数成员</span><br><span class="line">		m_nInt &#x3D; nNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	public:</span><br><span class="line">		int m_nInt;								&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">	CTest Test;</span><br><span class="line">	Test.SetNumber(5);							&#x2F;&#x2F;调用__stdcall成员函数</span><br><span class="line">	printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);		&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数调用过程</span><br><span class="line">Test.SetNumber(5) ;</span><br><span class="line">0040B808	push	5</span><br><span class="line">0040B80A	lea		eax,[ebp-8]					;荻取对象首地址并存入eax中</span><br><span class="line">0040B80D	push	eax							;将eax作为参数压栈</span><br><span class="line">0040B80E	call	@ILT+15 (CTest::SetNumber) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数SetNumber的实现过程</span><br><span class="line">void __stdcall SetNumber (int nNumber) &#123;</span><br><span class="line">;Debug 初始化过程略</span><br><span class="line">m_nInt &#x3D;  nNumber;</span><br><span class="line">0040B7C8	mov		eax, dword ptr [ebp+8] 		;取出this指针并存入eax中</span><br><span class="line">0040B7CB	mov		ecx, dword ptr [ebp+0Ch]	;取出参数nNumber并存入ecx中</span><br><span class="line">0040B7CE	mov		dword ptr [eax] , ecx		;使用eax取出成员并赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 __ cdecl 调用方式和 __gstdcall 调用方式只是在参数平衡时有所区别，this指针不容易识别。</p>
<p>使用thiscall调用放式的成员函数的要点分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea		ecx,[mem]							;取对象首地址并存入ecx中，要注意观察内存</span><br><span class="line">call	FUN_ADDRESS							;调用成员函数</span><br><span class="line">;在函数调用内，ecx尚未重新赋值之前</span><br><span class="line">mov		XXX,ecx								;发现函数内使用ecx中的数据，说明函数调用前对ecx的赋值</span><br><span class="line">;实际上是在传递参数</span><br><span class="line">;其后ecx中的内容会传递给其他寄存器</span><br><span class="line">mov		[reg+i],XXX 						;发现了寄存器相对间接寻址方式，如果能排除数组访问，那就能说明reg中保存的是结构体或者类对象的首地址</span><br></pre></td></tr></table></figure>

<p>符合以上特点，基本可判定这是调用类的成员函数。通过分析函数代码中访问ecx的方式，并结合内存窗口，以ecx中的值为地址去观察其数据，可以进一-步分析并还原出对象中的各数据成员。</p>
<p>__ stdcall与 __cdecl调用方式的成员函数分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea		reg,[mem]							;取出对象首地址并存入寄存器变量中</span><br><span class="line">push	reg									;将保存对象首地址的寄存器作为参数压栈</span><br><span class="line">call	FUN_ADDRESS							;调用成员函数</span><br><span class="line">;在函数调用内，将第一个函数参数作为指针变量，以寄存器相对间接寻址方式访问</span><br></pre></td></tr></table></figure>

<h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>当类中定义了静态数据成员时，由于静态数据成员和静态变量原理相同(是一个含有作用域的特殊全局变量)，因此该静态数据成员的初值会被<strong>写入编译链接后的执行文件</strong>中。当程序被加载时，操作系统将执行文件中的数据读到对应的内存单元里，静态数据成员便已经存在，而这时类并没有实例对象。所以静态数据成员和对象之间的生命周期不同，并且静态数据成员也不属于某一对象，与对象之间是一对多的关系。静态数据成员仅仅和类相关，和对象无关，多个对象可以共同拥有同一个静态数据成员。</p>
<p>两个对象各自的成员数据在内存中的地址不同，而<strong>静态数据成员的地址却相同</strong>。如图</p>
<p><img src="P3.jpg" alt="普通数据成员和静态数据成员"></p>
<p><strong>在计算类和对象的长度时，静态数据成员不被计算在内。</strong></p>
<p>普通数据成员的地址是一个栈空间地址，而<strong>静态数据成员的是一个常量地址，可通过立即数间接寻址的方式访问</strong>。访问时无需this指针。</p>
<h2 id="对象作为函数参数"><a href="#对象作为函数参数" class="headerlink" title="对象作为函数参数"></a>对象作为函数参数</h2><p>对象作为函数的参数时，其传参过程与数组不同:数组变量的名称代表数组的首地址，而对象的变量名称却不能代表对象的首地址。传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份(复制),将复制的数据作为形参传递到调用函数中使用。</p>
<p>来个栗子~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：参数为对象的函数调用</span><br><span class="line">class CFunTest&#123;</span><br><span class="line">	public:</span><br><span class="line">		int m_nOne;</span><br><span class="line">		int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">	printf(&quot;%d %d\r\n&quot;,FunTest.m_nOne,FunTest.m_nTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	CFunTest FunTest;</span><br><span class="line">	FunTest.m_nOne &#x3D; 1;</span><br><span class="line">	FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">	ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;注意，这里没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">00401098	mov		dword ptr [ebp-8],1				;数据成员m_nOne所在地址为ebp-8</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040109F	mov		dword ptr [ebp-4],2				;数据成员m_nTwo所在地址ebp-4</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">004010A6	mov		eax, dword ptr [ebp-4]</span><br><span class="line">004010A9	push	eax								;传入数据成员m_nTwo</span><br><span class="line">004010AA	mov		ecx, dword ptr [ebp-8] </span><br><span class="line">004010AD	push	ecx								;传入数据成员m_ nOne</span><br><span class="line">004010AE	call	@ILT+10 (ShowFunTest) 0040100f)</span><br><span class="line">004010B3	add		esp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShowFunTest (CFunTest FunTest) &#123;</span><br><span class="line">printf (&quot;%d %d\r\n&quot; , FunTest.m_nOne, FunTest.m_nTwo);</span><br><span class="line">;取出数据成员m_nTwo作为printf函数的第三个参数</span><br><span class="line">00401038	mov		eax, dword ptr [ebp+ 0Ch]</span><br><span class="line">0040103B 	push	eax</span><br><span class="line">;取出数据成员m_nOne作为printf函数的第二个参数</span><br><span class="line">0040103C	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">0040103F	push	ecx</span><br><span class="line">00401040	push	offset string &quot;%d %d\r\n&quot; (0042001c)</span><br><span class="line">00401045	call	printf(00401120)</span><br><span class="line">0040104A	add		esp,0Ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的体积不大，只有两个数据成员，编译器在调用函数传参的过程中分别将对象的两个成员荡产两个int类型数据依次压栈，类对象中的数据成员的传参顺序为:最先定义的数据成员最后压栈，最后定义的数据成员最先压栈。</p>
<p>来看看数组当参数的情况~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明;此代码为修改版，添加了数组成员char m_szName [32]</span><br><span class="line">class CFunTest &#123;</span><br><span class="line">public:</span><br><span class="line">	int m_nOne;</span><br><span class="line">	int m_nTwo;</span><br><span class="line">	char m_szName[32];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">&#x2F;&#x2F;显示对象中各数据成员的信息</span><br><span class="line">printf (&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">	CFunTest FunTest;</span><br><span class="line">	FunTest.m_nOne &#x3D; 1;</span><br><span class="line">	FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">	strcpy(FunTest.m_szName, &quot;Name&quot;);				&#x2F;&#x2F;赋值数据成员数组</span><br><span class="line">	ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">;初始化部分略</span><br><span class="line">printf(&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">00401038	lea		eax,[ebp+10h]					;取成员m_szName的地址</span><br><span class="line">0040103B	push	eax								;将成员m_ szName的地址作为参数压栈</span><br><span class="line">0040103C	mov		ecx,dword ptr [ebp+0Ch]			;取成员m_nTwo中的数据</span><br><span class="line">0040103F	push	ecx								</span><br><span class="line">00401040	mov		edx, dword ptr [ebp+8] 			;取成员m_nOne中的数据</span><br><span class="line">00401043	push	edx	</span><br><span class="line">00401044	push	offset string &quot;%d%d%s\r\n&quot; (0042002c)</span><br><span class="line">00401049	call	printf (00401120)</span><br><span class="line">0040104E	add		esp,10h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对照，main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">0040B7E8	mov		dword ptr [ebp-28h],1 			;数据成员m_nOne所在地址为ebp-28h</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040B7EF	mov		dword ptr [ebp-24h],2 			;数据成员m_nTwo所在地址为ebp-24h</span><br><span class="line">strcpy (FunTest.m_szName, &quot;Name&quot;);</span><br><span class="line">0040B7F1	push	offset string &quot;Name&quot; (0041302c)</span><br><span class="line">0040B7F6	lea		eax,[ebp-20h]					;数组成员m_szName所在地址为ebp-20h</span><br><span class="line">0040B7FE	push	eax</span><br><span class="line">0040B7FF	call	strcpy(00404650)</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">0040B804	add		esp,0FFFFFFEOh					;调整栈顶，抬高32字节</span><br><span class="line">0040B807	mov		ecx,0Ah							;设置循环次数为10</span><br><span class="line">0040B80C	lea		esi,[ebp-28h]					;获取对象的首地址并保存到esi中</span><br><span class="line">0040B80F	mov		edi,esp							;设置edi为当前栈顶</span><br><span class="line">;执行10次4字节内存复制，将esi所指向的数据复制到edi中，类似memcpy的内联方式</span><br><span class="line">0040B811	rep movs 	dword ptr [edi],dword ptr [esi]</span><br><span class="line">0040B813	call	@ILT+10 (ShowFunTest) (0040100f)</span><br><span class="line">0040B818	add		esp,28h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码清单9-6中，在传递类对象的过程中使用了“add esp, 0FFFFFFE0h”来调整栈顶指针esp，0FFFFFEOh 是补码，转换后为-20h,等同于esp-20h。前面讲过，参数变量在传递时，需要向低地址调整栈顶指针esp,此处申请的32字节栈空间，<strong>加上strcpy未平衡的8字节参数空间，都用于存放参数对象FunTest的数据。将对象FunTest中的数据依次复制到申请的栈空间中。</strong></p>
<p>上面两份代码定义的类都没有定义构造函数和析构函数。由于对象作为参数在传递过程中会制作一份对象的复制数据，当向对象分配内存时，如果有构造函数，编译器会再调用一次构造函数，并做一些初始化工作。当代码执行到作用域结束时，局部对象将被销毁，而对象中可能会涉及资源释放的问题，同样，编译器也会再调用一次局部对象的析构函数，从而完成资源数据的释放。</p>
<p>当对象作为函数的参数时，由于重新复制了对象，等同于又定义了一个对象，在某些情况下会调用特殊的构造函数——<strong>拷贝构造函数</strong>。当函数退出时，复制的对象作为函数内的局部变量，将被销毁。当析构函数存在时，则会调用析构函数，这时候会出现问题，来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：涉及资源申请与释放的类的对象</span><br><span class="line">class CMString&#123;</span><br><span class="line">public:</span><br><span class="line">	CMString()&#123;</span><br><span class="line">		m_pString &#x3D; new char[10];			&#x2F;&#x2F;申请堆空间，只要不释放，进程退出前将一直存在</span><br><span class="line">		if(m_pString &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		strcpy(m_pString,&quot;Hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	~CMString()&#123;</span><br><span class="line">		if(m_pString !&#x3D; NULL)&#123;				&#x2F;&#x2F;检查资源</span><br><span class="line">			delete m_pString;				&#x2F;&#x2F;释放空间</span><br><span class="line">			m_pString &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	char *GetString()&#123;</span><br><span class="line">		return m_pString;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char *m_pString;						&#x2F;&#x2F;数据成员定义，保存堆的首地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数CMString类对象的函数</span><br><span class="line">void ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">	printf (MyStringCpy.GetString());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;main函数实现</span><br><span class="line">void main()&#123;								</span><br><span class="line">	CMyString MyString;						&#x2F;&#x2F;类对象定义</span><br><span class="line">	ShowMyString (MyString);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对照，main函数分析</span><br><span class="line">void main()&#123;								</span><br><span class="line">CMyString MyString;	</span><br><span class="line">;获取对象的首地址，放入ecx中作为this指针</span><br><span class="line">0040121D	lea		ecx, [ebp- 10h]</span><br><span class="line">;调用构造函数</span><br><span class="line">00401220	call	@ILT+5 (CMyString::CMyString) (0040100a)</span><br><span class="line">;记录同一作用域内该类的对象个数</span><br><span class="line">00401225	mov		dword ptr [ebp-4],0</span><br><span class="line">ShowMyString (Mystring);</span><br><span class="line">;MyString对象长度为4，一个寄存器单元刚好能存放</span><br><span class="line">;于是eax获取对象首地址处4字节的数据，即数据成员m_pString</span><br><span class="line">0040122C	mov		eax,dword ptr [ebp-10h]	</span><br><span class="line">0040122F	push	eax	</span><br><span class="line">00401230	call	@ILT+15 (ShowMyString) (00401014)</span><br><span class="line">00401235	add		esp,4</span><br><span class="line">&#125;		&#x2F;&#x2F; main函数结束处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">00401238	mov		dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;获取对象首地址，传入ecx作为this指针</span><br><span class="line">0040123F	lea		ecx, [ebp-10h]</span><br><span class="line">;调用析构函数</span><br><span class="line">00401242	call	@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111E    ret</span><br><span class="line">&#x2F;&#x2F;构造函数与析构函数讲解略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ShowMyString函数的实现过程分析</span><br><span class="line">vold ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">004010B0	push	ebp</span><br><span class="line">004010B1	mov		ebp,esp</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;异常链处理过程&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">004010B3	push	0FFh</span><br><span class="line">004010B5	push	offset __ehhandler$?ShowMyString@@YAXVCMyString@@@Z (00410d39)</span><br><span class="line">004010BA	mov		eax,fs:[00000000]	</span><br><span class="line">004010C0	push	eax</span><br><span class="line">004010C1	mov		dword ptr fs:[0],esp</span><br><span class="line">004010C8	sub		esp,40h</span><br><span class="line">004010CB	push	ebx</span><br><span class="line">004010CC	push	esi</span><br><span class="line">004010CD	push	edi</span><br><span class="line">004010CE	lea		edi,[ebp-4Ch]	</span><br><span class="line">004010D1	mov		ecx,10h</span><br><span class="line">004010D6	mov		eax,0CCCCCCCCh</span><br><span class="line">004010DB	rep stos	dword ptr [edi]</span><br><span class="line">004010DD	mov		dword ptr [ebp-4],0 			;作用域内的对象个数</span><br><span class="line">printf(MyStringCpy.GetString());</span><br><span class="line">;取参数1的数据成员m_pString的地址(即对象酋地址)并保存到ecx中作为this指针</span><br><span class="line">;注意，此m_pString地址非main函数中的对象MyString的首地址</span><br><span class="line">004010E4	lea		ecx,[ebp+8]						;取参数1的地址</span><br><span class="line">;调用成员函数GetString, 该方法的讲解略</span><br><span class="line">004010E7	call	@ILT+0 (CMyString::GetString) (00401005)</span><br><span class="line">004010EC	push	eax								;将返回eax中保存的字符串的首地址作为参数压栈</span><br><span class="line">004010ED	call	printf (00401310)</span><br><span class="line">004010F2	add		esp,4</span><br><span class="line">&#125;													&#x2F;&#x2F;ShowMyString函数的结尾处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">004010F5	mov		dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;取参数1的地址，作为this指针调用析构函数</span><br><span class="line">004010FC	lea		ecx,[ebp+8]</span><br><span class="line">004010FF	call	@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111E	ret</span><br></pre></td></tr></table></figure>

<p>在代码中，当对象作为参数被传递时，参数MyStringCpy复制了对象MyString中的数据成员m_pString，产生了两个CMyString类的对象。由于没有编写拷贝构造函数，因此在传参的时候就没有被调用，这个时候编译器以浅拷贝处理，它们的数据成员m_pString都指向了同一个堆地址，如图所示。</p>
<p><img src="P4.jpg" alt="复制对象与原对象对比"></p>
<p>根据图所示，两个对象中的数据成员m_pString指向了相同地址，当函数ShowMyString调用结束后，便会释放对象MyStringCpy，以对象MyStringCpy的首地址作为this指针调用析构函数。在析构函数中，调用delete函数来释放掉对象MyStringCpy的数据成员m_ pString 所保存的堆空间的首地址。但对象MyStringCpy是MyString的复制品，真正的MyString还存在，而数据成员m_pString所保存的堆空间的首地址却被释放，如果出现以下代码便会产生错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMyString MyString;</span><br><span class="line">&#x2F;&#x2F;当该函数调用结束后，对象MyString中的数据成员m_pString所保存的堆空间已经被释放掉，再次使用此对象中的数据成员m_pString便无法得到堆空间的数据</span><br><span class="line">ShowMyString (MyString);</span><br><span class="line">ShowMyString (MyString);					;显示地址中为错误数据</span><br></pre></td></tr></table></figure>

<p>两个方案解决这个问题</p>
<ol>
<li><strong>深拷贝数据</strong>:在复制对象时，编译器会调用一次该类的拷贝构造函数，给编码者一次机会。深拷贝利用这次机会将原对象的数据成员所保存的资源信息也制作一份副本。这样，当销毁复制对象时，销毁的资源是复制对象在拷贝构造函数中制作的副本，而非原对象中保存的资源信息。</li>
<li><strong>设置引用计数</strong>:在进入拷贝构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放掉申请的资源，否则引用计数减1。</li>
</ol>
<h2 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h2><p>对象作为返回值与对象作为参数的处理方式非常类似。对象作为参数时，进入函数前预先将对象使用的栈空间保留出来，并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。</p>
<p>来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：在函数内定义对象并将其作为返回值</span><br><span class="line">class CReturn&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_nNumber;</span><br><span class="line">	int m_nArry[10];</span><br><span class="line">&#125;;</span><br><span class="line">CReturn GetCReturn()&#123;</span><br><span class="line">	CReturn RetObj;</span><br><span class="line">	RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">		RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return RetObj;					&#x2F;&#x2F;返回局部对象</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char* argv[])&#123;</span><br><span class="line">	CReturn objA;</span><br><span class="line">	objA &#x3D; GetCReturn();</span><br><span class="line">	printf(&quot;%d %d %d&quot;,objA.m_nNumber,objA.m_nArry[0],objA.m_nArry[9]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数和析构函数略</span><br><span class="line">&#x2F;&#x2F;main函数代码分析</span><br><span class="line"></span><br><span class="line">void main(int argc, char* argv[]) &#123;</span><br><span class="line">00401290	push	ebp</span><br><span class="line">00401291	mov		ebp,esp</span><br><span class="line">00401293	sub		esp,0C4h				;预留返回对象的栈空间</span><br><span class="line">00401299	push	ebx</span><br><span class="line">0040129A	push	esi</span><br><span class="line">0040129B	push	edi</span><br><span class="line">0040129C	lea		edi,[ebp-0C4h]</span><br><span class="line">004012A2	mov		ecx,31h</span><br><span class="line">004012A7	mov		eax,0CCCCCCCCh</span><br><span class="line">004012AC	rep stos	dword ptr[edi]</span><br><span class="line">CReturn objA;</span><br><span class="line">objA&#x3D; GetCReturn();</span><br><span class="line">004012AE	lea		eax,[ebp- 84h]			;获取返回对象的栈空间首地址</span><br><span class="line">;将返回对象的首地址压入栈中，用于保存返回对象的数据</span><br><span class="line">004012B4	push	eax</span><br><span class="line">;调用函数GetCReturn, 见下文对GetCReturn的实现过程的分析</span><br><span class="line">004012B5	call	@ILT+45 (GetCReturn) (00401032)</span><br><span class="line">004012BA	add		esp,4</span><br><span class="line">;函数调用结束后，eax中保存着地址ebp-84h， 即返回对象的首地址</span><br><span class="line">004012BD	mov		esi,eax 				;将返回对象的首地址存入esi中</span><br><span class="line">004012BF	mov		ecx,0Bh 				;设置循环次数</span><br><span class="line">004012C4	lea		edi,[ebp-58h] 			;获取临时对象的首地址</span><br><span class="line">;每次从返回对象中复制4字节数据到临时对象的地址中，共复制11次</span><br><span class="line">004012C7	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">004012C9	mov		ecx,0Bh 				;重新设置复制次数</span><br><span class="line">004012CE	lea		esi,[ebp-58h] 			;获取临时对象的首地址</span><br><span class="line">004012D1	lea		edi,[ebp-2Ch] 			;获取对象objA的首地址</span><br><span class="line">;将数据复制到对象objA中</span><br><span class="line">004012D4	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;GetCReturn 的实现过程分析</span><br><span class="line">CReturn GetCReturn() &#123;</span><br><span class="line">0040CE90	push	ebp</span><br><span class="line">0040CE91	mov		ebp,esp</span><br><span class="line">0040CE93	sub		esp,70h					;调整栈空间，预留临时返回对象与局部对象的内存空间</span><br><span class="line">0040CE96	push	ebx</span><br><span class="line">0040CE97	push	esi</span><br><span class="line">0040CE98	push	edi</span><br><span class="line">0040CE99	lea		edi,[ebp-70h]</span><br><span class="line">0040CE9C	mov		ecx,1Ch</span><br><span class="line">0040CEA1	mov		eax,0CCCCCCCCh</span><br><span class="line">0040CEA6	rep stos 	dword ptr [edi]</span><br><span class="line">CReturn RetObj;</span><br><span class="line">RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">;为数据成员nNumber賦值0，地址ebp-2Ch便是对象Retobj的酋地址</span><br><span class="line">0040CEA8	mov		dword ptr [ebp-2Ch],0</span><br><span class="line">for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">	RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">0040CED4	jmp		GetCReturn+28h(0040ceb8)	;for循环分析略，直接看退出函数时的处理</span><br><span class="line">return RetObj;</span><br><span class="line">0040CED6	mov		ecx,0Bh					;设置循环次数为11次</span><br><span class="line">0040CEDB	lea		esi,[ebp-2Ch]			;获取局部对象的首地址</span><br><span class="line">0040CEDE	mov		edi,dword ptr [ebp+8] 	;荻取返回对象的首地址</span><br><span class="line">;将局部对象RetObj中的数据复制到返回对象中</span><br><span class="line">0040CEE1	rep movs	dword ptr [edi],dword ptr [esi]</span><br><span class="line">0040CEE3	mov		eax,dword ptr [ebp+8] 	;获取返回对象的首地址并保存到eax中，作为返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码演示了函数返回对象的全过程。在调用GetCReturn前，编译器将在main函数中申请的返回对象的首地址作为参数压栈，在函数GetCReturn调用结束后进行了数据复制，将GetCReturn函数中定义的局部对象RetObj的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象objA，从而达到返回对象的目的。因为在这个示例中不存在函数返回后为对象的引用赋值，所以这里的返回对象是临时存在的，也就是C++中的临时对象，作用域仅限于单条语句。</p>
<p>这个临时对象的产生原因主要是C++程序员可能采用这类写法，如GetCReturn().m_nNumber,这只是针对返回对象的操作，而此时函数已经退出，其栈帧也被关闭。函数退出后去操作局部对象显然不合适，因此只能由函数的调用方准备空间，建立临时对象，然后将函数中的局部对象复制给临时对象，再把这个临时对象交给调用方去操作。本例中的objA = GetCReturn();是个赋值运算，由于赋值时GetCReturn函数已经退出，其栈空间已经关闭，同理objA不能直接和函数内局部对象做赋值运算，因此需要临时对象记录返回值以后再来参与赋值。</p>
<p>虽然使用临时对象进行了数据复制，但是同样存在出错的风险。这与对象作为参数时遇到的情况一样，由于使用了临时对象进行数据复制，当临时对象被销毁时，会执行析构函数。如果析构函数中有对资源释放的处理，就有可能造成同一个资源多次释放的错误。</p>
<p>编译器在处理简单的结构体和类结构的时候，开启O2优化后，难以识别他们与局部变量的区别</p>
<p>来个栗子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct tagUnknow&#123;</span><br><span class="line">	short m_sShort;</span><br><span class="line">	int m_nInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">;int ___cdec1 main(int arge, const char **argv， const char **envp)</span><br><span class="line">sub		esp,8				</span><br><span class="line">lea		eax,[esp+8+var_8]	;获取局部变量的地址并存入eax中</span><br><span class="line">mov		[esp+8+var_8],3		;赋值局部变量1</span><br><span class="line">push	eax					;将局部变量的地址作为参数传递</span><br><span class="line">mov		[esp+0Ch+var_4],2	;腻值局部变量2</span><br><span class="line">call	sub_401000			;调用函数sub_401000</span><br><span class="line">add		esp,0ch</span><br><span class="line">retn</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">sub_401000 proc near</span><br><span class="line">arg_0 &#x3D; dword ptr 4			;有一个参数</span><br><span class="line">mov		eax,[esp+arg_0]		;获取参数并保存到eax中</span><br><span class="line">;从eax保存的地址中取出2字节数据，结合后面一条指令可推断这是对象成员的寻址，因为参数指针指向的数据类型不一致</span><br><span class="line">movsx	ecx,word ptx [eax]	</span><br><span class="line">mov		edx,[eax+4]			;寄存器相对间接寻址方式，这是对象成员的寻址</span><br><span class="line">push	ecx					;将荻取数据作为参数压栈</span><br><span class="line">push	edx</span><br><span class="line">push	offset aDD</span><br><span class="line">call	printf</span><br><span class="line">add		esp,0Ch</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>

<p>在通常情况下，VC++6.0编译的代码默认<strong>以thiscall方式调用成员函数</strong>，因此会使用ecx来保存this 指针，从而进行参数传递，但并非具有ecx传参的函数就一定是成员函数。当使用__fastcall 时，同样可以在反汇编代码中体现出ecx传参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;((struct A*)NULL)-&gt; m_ float 不会崩溃，这时求m_ float 的地址，根据前面提出的结构体寻址公式:</span><br><span class="line">p-&gt;member的地址&#x3D;指针p的地址值+ member在type中的偏移量</span><br><span class="line">代入得:</span><br><span class="line">&amp;((struct A*)NULL)-&gt; m_ float&#x3D;0 +4&#x3D;4，这个表达式实际上是求结构体内成员的偏移量。</span><br><span class="line">可以定义如下宏，用于在不产生对象的情况下取得成员偏移量:</span><br><span class="line">#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)</span><br></pre></td></tr></table></figure>

<p>这个结束了~</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" rel="next" title="C++反汇编与逆向分析技术">
                <i class="fa fa-chevron-left"></i> C++反汇编与逆向分析技术
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/" rel="prev" title="C++反汇编与逆向分析技术(二)">
                C++反汇编与逆向分析技术(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/06/19/C-反汇编与逆向分析技术-四/"
           data-title="C++反汇编与逆向分析技术(四)" data-url="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kittener</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kittener" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="mail">
                      
                        <i class="fa fa-fw fa-globe"></i>mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/kittener" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#变量在内存中的位置和访问方式"><span class="nav-number">1.</span> <span class="nav-text">变量在内存中的位置和访问方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量和局部变量的区别"><span class="nav-number">1.1.</span> <span class="nav-text">全局变量和局部变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部静态变量的工作方式"><span class="nav-number">1.2.</span> <span class="nav-text">局部静态变量的工作方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆变量"><span class="nav-number">1.3.</span> <span class="nav-text">堆变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组和指针的寻址"><span class="nav-number">2.</span> <span class="nav-text">数组和指针的寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组在函数内"><span class="nav-number">2.1.</span> <span class="nav-text">数组在函数内</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组作为参数"><span class="nav-number">2.2.</span> <span class="nav-text">数组作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组作为返回值"><span class="nav-number">2.3.</span> <span class="nav-text">数组作为返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下标寻址和指针寻址"><span class="nav-number">2.4.</span> <span class="nav-text">下标寻址和指针寻址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组"><span class="nav-number">2.5.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存放指针类型数据的数组"><span class="nav-number">2.6.</span> <span class="nav-text">存放指针类型数据的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指向数组的指针变量"><span class="nav-number">2.7.</span> <span class="nav-text">指向数组的指针变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数指针"><span class="nav-number">2.8.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体和类"><span class="nav-number">3.</span> <span class="nav-text">结构体和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">3.1.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针"><span class="nav-number">3.2.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态数据成员"><span class="nav-number">3.3.</span> <span class="nav-text">静态数据成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象作为函数参数"><span class="nav-number">3.4.</span> <span class="nav-text">对象作为函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象作为返回值"><span class="nav-number">3.5.</span> <span class="nav-text">对象作为返回值</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kittener</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FSYBzoLmcoINlfmLJmsXaDA8-gzGzoHsz',
        appKey: 'aYNlN8CfvruV4yvdvxARsbD5',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  
 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
 <script type="text/javascript" src="/js/src/fireworks.js"></script>
 </pre>
</body>
</html>
