<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="RUQLkWDKqj" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记," />




  


  <link rel="alternate" href="/atom.xml" title="Kittener's blog" type="application/atom+xml" />






<meta name="description" content="记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Kittener&#39;s blog">
<meta property="og:description" content="记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE1.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE2.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE5-2.png">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE5-3.png">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE5-4.png">
<meta property="og:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE5-5.png">
<meta property="article:published_time" content="2020-05-19T13:49:04.000Z">
<meta property="article:modified_time" content="2020-06-09T15:19:21.538Z">
<meta property="article:author" content="Kittener">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.kittener.top/2020/05/19/操作系统/"/>





  <title>操作系统 | Kittener's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kittener's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kittener">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kittener's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-19T21:49:04+08:00">
                2020-05-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-06-09T23:19:21+08:00">
                2020-06-09
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/19/操作系统/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完</p>
<a id="more"></a>
<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol>
<li>方便性  </li>
<li>有效性<br>有效性的第一层含义是提高系统资源的利用率。另一层含义是，提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。  </li>
<li>可扩充性<br>OS从早期的无结构发展称模块化结构，进而发展成层次化结构，近年来广泛采用了微内核结构，具有良好的可扩充性。  </li>
<li>开放性<br>指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。  </li>
</ol>
<h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ol>
<li>OS作为用户与计算机硬件系统之间的接口<br>用户通过命令方式、系统调用方式和图标——窗口方式来实现与操作系统的通信  </li>
<li>OS作为计算机系统资源的管理者<br>OS中的资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）  </li>
<li>OS实现了对计算机资源的抽象<br>OS是铺设在计算机硬件上的多层软件的集合，不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。  </li>
</ol>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol>
<li>处理过程<br>简单来说就是将作业装在磁带上，一个一个单个处理，如图：<br><img src="%E5%9B%BE1.jpg" alt="单道批处理系统">  </li>
<li>缺点<br>资源得不到充分利用，如图：<br><img src="%E5%9B%BE2.jpg" alt="运行情况">  </li>
</ol>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol>
<li>处理过程<br>用户所提交的作业先放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。  </li>
<li>优缺点<br>（1）资源利用率高<br>（2）系统吞吐量大<br>（3）平均周转时间长<br>（4）无交互能力  </li>
</ol>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol>
<li>运行方式  </li>
</ol>
<ul>
<li>作业直接进入内存  </li>
<li>采用轮转运行方式（加入时间片）  </li>
</ul>
<ol start="2">
<li>特征  </li>
</ol>
<ul>
<li>多路性：系统允许将多台终端同时链接到一台主机上  </li>
<li>独立性：系统提供了这样的用户各自独立环境  </li>
<li>及时性：用户的请求很短时间内能得到相应  </li>
<li>交互性：用户可通过终端进行人机对话  </li>
</ul>
<h2 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h2><ul>
<li>单用户单任务操作系统  </li>
<li>单用户多任务操作系统  </li>
<li>多用户多任务操作系统  </li>
</ul>
<h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol>
<li>并行与并发  </li>
</ol>
<ul>
<li>并行性是指两个或多个事件在同一时刻发生  </li>
<li>并发性是指两个或多个事件在统一时间间隔内发生  </li>
</ul>
<ol start="2">
<li>引入进程  </li>
</ol>
<ul>
<li>进程是指：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。  </li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ol>
<li>互斥共享方式<br>一个进程访问完资源后，资源才能被另一个进程访问。资源叫做<strong>临界资源</strong>    </li>
<li>同时访问方式  </li>
</ol>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在os中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为<strong>虚拟</strong>。  </p>
<ol>
<li>时分复用技术（时间）  </li>
<li>空分复用技术（空间）  </li>
</ol>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ol>
<li>进程控制：为作业创建进程、撤销（终止）已结束的进程，以及控制进程在运行过程中的状态转换。  </li>
<li>进程同步：  </li>
</ol>
<ul>
<li>进程互斥方式：指诸进程在对临界资源进行访问时，应采用互斥方式  </li>
<li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。  </li>
</ul>
<ol start="3">
<li>进程通信：通常采用直接通信方式，由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接受命令从其消息队列中取出消息  </li>
<li>调度  </li>
</ol>
<ul>
<li>作业调度：从后备队列中按一定算法取出若干队列。为其分配运行所需资源。</li>
<li>进程调度：从就绪队列中按照一定的算法选出一个进程，执行。</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ol>
<li>内存分配  </li>
</ol>
<ul>
<li>静态分配方式：每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间。</li>
<li>动态分配方式：允许申请新的空间。  </li>
</ul>
<ol start="2">
<li>内存保护：每个程序互不打扰，操作系统的程序和数据不允许访问。</li>
<li>地址映射  </li>
<li>内存扩充  </li>
</ol>
<ul>
<li>请求调入功能：将程序所需部分从存储器中调入内存</li>
<li>置换功能：将内存和磁盘的数据进行置换  </li>
</ul>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol>
<li>共享存储器系统  </li>
</ol>
<ul>
<li>基于共享数据结构的通信方式。</li>
</ul>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol>
<li>高级调度<br>调度对象是作业，其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为其创建进程、分配资源，放入就绪队列，主要应用于多道批处理系统  </li>
<li>低级调度<br>又称为进程调度或短程调度，其调度对象是进程(或内核级线程)。其主要功能是根据某种算法决定就绪队列中的哪个进程应获得处理机。</li>
<li>中级调度<br>提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存，把能运行的调至内存。  </li>
</ol>
<h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol>
<li>处理机调度算法的共同目标<br>(1)<strong>资源利用率</strong> CPU的利用率 = CPU的有效工作时间/(CPU的有效工作时间+CPU的空闲等待时间)<br>(2)<strong>公平性</strong> 每个进程都应该获得合理的CPU时间<br>(3)<strong>平衡性</strong> 尽可能保持系统资源使用的平衡性<br>(4)<strong>策略强制执行</strong> 对所制订的策略，保证其准确执行  </li>
<li>批处理系统的目标<br>(1)<strong>平均周转时间短</strong><br>(2)<strong>系统吞吐量高</strong><br>(3)<strong>处理机利用率高</strong>  </li>
<li>分时系统的目标<br>(1)<strong>响应时间快</strong><br>(2)<strong>均衡性</strong>  </li>
<li>实时系统的目标<br>(1)<strong>截止时间的保证</strong><br>(2)<strong>可预测性</strong>  </li>
</ol>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ol>
<li>作业与作业步<br>(1)作业。不仅包含通常的程序和数据，还包括一份作业说明书，再批处理系统中，作业为基本单位从外存调入内存<br>(2)作业步。每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。每个步骤叫做一个作业步。  </li>
<li>作业的三种状态和三个阶段  </li>
</ol>
<ul>
<li>收容阶段，操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。(后备状态)</li>
<li>运行阶段(运行阶段)  </li>
<li>完成阶段(完成阶段)  </li>
</ul>
<ol start="3">
<li>先来先服务和短作业优先调度算法  </li>
</ol>
<ul>
<li>先来先服务调度算法(FCFS)  </li>
<li>短作业优先调度算法(SJF):作业越短优先级越高  </li>
<li>优先级调度算法(PSA):外部赋予作业优先级  </li>
<li>高响应比优先调度算法(HRRN):优先权 = (等待时间+要求服务时间)/要求服务时间  </li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol>
<li>非抢占方式<br>一旦处理机分配给某进程后，就一直让它运行下去，不会因为时钟中断而被抢占。<br>可能引起进程调度的因素：  </li>
</ol>
<ul>
<li>程序执行完毕，或发生某种事件使程序无法执行  </li>
<li>I/O请求  </li>
<li>原语操作如Block<br>不适用于分时系统和大多数实时系统  </li>
</ul>
<ol start="2">
<li>抢占方式<br>允许调度程序根据某一原则暂停执行中的程序，分配处理机给新的进程<br>原则：  </li>
</ol>
<ul>
<li>优先权原则：高优先级先运行  </li>
<li>短进程优先原则</li>
<li>时间片原则：时间片用完就暂停执行  <h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3>就绪队列上的每个进程每次仅运行一个时间片。  </li>
</ul>
<ol>
<li><strong>原理</strong><br>系统将所有的就绪进程按FCFS策略排成一个就绪队列。  </li>
<li><strong>进程切换时机</strong>  </li>
</ol>
<ul>
<li>执行完成</li>
<li>时间片用完，计时器中断处理程序被激活  </li>
</ul>
<ol start="3">
<li><strong>时间片大小的确定</strong><br>略大于典型交互时间  <h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3></li>
<li><strong>类型</strong>  </li>
</ol>
<ul>
<li>非抢占式优先级调度算法：一旦处理机分配给了优先级最高的进程，则一直执行下去直至完成。</li>
<li>抢占式优先级调度算法：出现了更高优先级的进程，中断当前执行进程，转而去执行更高优先级的进程。  </li>
</ul>
<ol start="2">
<li>优先级的类型  </li>
</ol>
<ul>
<li>静态优先级：进程运行过程中优先级保持不变  </li>
<li>动态优先级：随着时间增加而改变  <h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3>将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的算法。<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3></li>
</ul>
<ol>
<li>调度机制  </li>
</ol>
<ul>
<li>设置多个就绪队列，每个队列不同的优先级不同的时间片大小，在优先级愈高的队列中，其时间片就越小。  </li>
<li>每个队列采用FCFS算法。</li>
<li>按队列优先级调度。 <h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3></li>
</ul>
<ol>
<li>保证调度算法<br>这里的保证并不是优先运行，而是性能保证。</li>
</ol>
<ul>
<li>跟踪计算每个进程自创建以来已经执行的处理时间</li>
<li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n  </li>
<li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比  </li>
<li>比较各进程获得处理机时间的比率</li>
<li>选择比率最小的进程将处理机分配给它，知道超过最接近它的进程比率</li>
</ul>
<ol start="2">
<li>公平分享调度方法<br>对用户公平  </li>
</ol>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol>
<li>提供必要的信息<br>(1)就绪时间<br>(2)开始截止时间和完成截止时间<br>(3)处理时间<br>(4)资源要求<br>(5)优先级  </li>
<li>系统处理能力强  </li>
<li>采用抢占式调度机制  </li>
<li>具有快速切换机制<br>(1)对中断的快速响应能力<br>(2)快速的任务分派能力  <h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li>
<li>非抢占式调度算法</li>
</ol>
<ul>
<li>非抢占式轮转调度算法  </li>
<li>非抢占式优先调度算法  </li>
</ul>
<ol start="2">
<li>抢占式调度算法  </li>
</ol>
<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法  </li>
</ul>
<h3 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h3><p>任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。  </p>
<h3 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h3><p>松弛度 = 必须完成的时间 - 其本身的运行时间 - 当前时间<br>松弛度低的先运行  </p>
<h3 id="优先级倒置-priority-inversion-problem"><a href="#优先级倒置-priority-inversion-problem" class="headerlink" title="优先级倒置(priority inversion problem)"></a>优先级倒置(priority inversion problem)</h3><p>低优先级和高优先级的共享一临界资源，就会导致如果低优先级的<strong>先执行</strong>，高优先级在得到处理机后，因为临界资源被<strong>占用</strong>而被<strong>堵塞</strong>，导致低优先级的先执行  </p>
<ul>
<li>解决方法：<br>1 低优先级在进入临界区后不允许被抢占<br>2 低优先级继承高优先级的优先级，率先执行完  </li>
</ul>
<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ol>
<li>可重用资源和消耗性资源  </li>
</ol>
<ul>
<li>可重用资源：一种可供用户重复使用多次的资源，有如下性质：<br>(1)每一个可重用资源中的单元只能分配给一个进程使用，不能共享<br>(2)进程在使用可重用性资源时，必须先请求再使用<br>(3)数目固定，进程在运行期间既不能创建也不能删除  </li>
<li>可消耗资源：在进程运行期间，由进程动态创建和消耗  </li>
</ul>
<ol start="2">
<li>可抢占性资源和不可抢占资源  </li>
</ol>
<h3 id="计算机中的死锁"><a href="#计算机中的死锁" class="headerlink" title="计算机中的死锁"></a>计算机中的死锁</h3><ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁  </li>
</ul>
<h3 id="死锁的定义、必要条件和处理方法"><a href="#死锁的定义、必要条件和处理方法" class="headerlink" title="死锁的定义、必要条件和处理方法"></a>死锁的定义、必要条件和处理方法</h3><ol>
<li>定义：如果一组进程中的每一个进程都在等待仅有该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件<br>(1)互斥条件。进程对所分配道德资源进行排他性使用<br>(2)请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有<br>(3)不可抢占条件<br>(4)循环等待条件  </li>
<li>处理死锁的方法<br>(1)预防死锁：通过设置某些限制条件，去破坏一个进程<br>(2)避免死锁：用某种方法防止系统进入不安全状态，从而可以避免发生死锁<br>(3)检测死锁：通过检测机构及时检测出死锁发生，采取适当措施<br>(4)解除死锁：撤销进程，回收资源  </li>
</ol>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><ol>
<li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需地全部资源。这样就避免了资源”请求”条件。</li>
<li>第二种协议：允许一个进程只获得运行储器所需资源后，便开始运行。进程运行过程中在逐步释放已分给自己的、且已用毕地全部资源，然后再请求新的所需资源  <h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3>当一个已经保持了某些不可被抢占资源地进程，提出新的资源请求而得不到满足时，它必须释放已经保持地所有资源，待以后需要时再重新申请  <h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3>对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增地顺序请求资源。一个进程在开始时可以请求Ri的资源，以后当且仅当F(Rj)&gt;F(Ri)的时候才可以请求Rj的资源  </li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul>
<li>安全状态<br>所谓的安全状态是指系统能按某种进程推进顺序(P1,P2,···,Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成  <h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><a href="https://blog.csdn.net/qq_36260974/article/details/84404369" target="_blank" rel="noopener">银行家算法</a>  </li>
</ul>
<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储器结构"><a href="#多层结构的存储器结构" class="headerlink" title="多层结构的存储器结构"></a>多层结构的存储器结构</h3><p>可执行存储器：寄存器和主存储器<br>主存储器：内存或主存，用于保存进程运行时的程序和数据<br>寄存器：具有与处理机相同的速度  </p>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序，需经过如下步骤：</p>
<ul>
<li>编译，有编译程序对用户源程序进行编译，形成若干个目标模块  </li>
<li>链接，由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块  </li>
<li>装入，由装入程序将装入模块装入内存  <h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3>有三种装入方式：  </li>
</ul>
<ol>
<li>绝对装入方式  </li>
<li>可重定位装入方式  </li>
<li>动态运行时的装入方式<br>装入程序把装入模块装入后，并不立即把装入模块中的逻辑地址转换为物理地址，而是等到运行时才进行  </li>
</ol>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ol>
<li>静态链接方式<br>在程序运行之前，先将各目标模块及他们所需的库函数链接成一个完整的装配模块，以后不在拆开。<br>(1)对相对地址进行修改。在编译程序所产生的所有目标模块中，使用的都是相对地址。<br>(2)变换外部调用符号  </li>
<li>装入时动态链接方式<br>指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。<br>有以下优点：<br>(1)便于修改和更新<br>(2)便于实现对目标模块的共享  </li>
<li>运行时动态链接<br>对某些模块的链接推迟到程序执行时才进行  <h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2>为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻  <h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3>把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常时放在内存的低址部分。而在用户区中，仅装有一道用户程序  <h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3>将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业  </li>
<li>划分分区的方法<br>(1)分区大小相等<br>(2)分区大小不等  </li>
<li>内存分配<br>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态  </li>
</ol>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol>
<li>动态分区分配中的数据结构  </li>
</ol>
<ul>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等数据项  </li>
<li>空闲分区链：每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针  </li>
</ul>
<ol start="2">
<li>分区分配操作  </li>
</ol>
<ul>
<li>分配内存</li>
<li>回收内存  </li>
</ul>
<h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><ol>
<li>首次适应算法(FF)<br>FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按作业大小，从该分区划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中<br>该算法倾向于优先利用内存中的低址部分的空闲分区，从而保留高址部分的大空闲区  </li>
<li>循环首次适应算法(NF)<br>为了避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找  </li>
<li>最佳适应算法(BF)<br>将所有空闲分区按其容量以从小到大的顺序形成一空闲分区链  </li>
<li>最坏适应算法(WF)<br>将所有空闲分区按其容量以从大到小顺序形成一空闲分区链，每次挑选最大的从中分割一部分给作业使用  </li>
</ol>
<h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><ol>
<li>快速适应算法(QF)<br>分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针<br>搜索时分为两步：(1)根据进程长度，从索引表中寻找能容纳它的最小空闲区链表;(2)从链表中取下第一块进行分配即可<br>缺点是在分区归还主存时算法复杂，一个分区只给一个进程容易浪费  </li>
<li>伙伴系统(buddy system)<br>无论已分配分区或空闲分区，其大小均为2的k次幂。分配时找2的i次方，合并时一样  </li>
<li>哈希算法<br>利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张一空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针  </li>
</ol>
<h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol>
<li>动态重定位<br>程序在执行时，真正访问的内存地址时相对地址与重定位寄存器中的低址相加而形成的，动态重定位分区与动态分区算法除了增加了”紧凑”功能外基本上相同  </li>
</ol>
<h2 id="对换-Swapping"><a href="#对换-Swapping" class="headerlink" title="对换(Swapping)"></a>对换(Swapping)</h2><h3 id="多道程序环境下的对换技术"><a href="#多道程序环境下的对换技术" class="headerlink" title="多道程序环境下的对换技术"></a>多道程序环境下的对换技术</h3><ol>
<li>对换技术：<br>在系统中设置一个对换进程，由它将内存中暂时不能运行的进程调出到磁盘的对换区;同样也由该进程将磁盘上已具备运行条件的进程调入内存  </li>
<li>对换的类型：  </li>
</ol>
<ul>
<li>整体对换:以整个进程为单位对换  </li>
<li>页面(分段)对换:以一个”页面”或”分段”为单位进行对换  <h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3></li>
</ul>
<ol>
<li>对换空间管理的主要目标<br>(1)对文件区管理的主要目标<br>提高文件存储空间的利用率，然后提高对分及的访问速度，因此，对文件区空间的管理采取离散分配方式<br>(2)对对换空间管理的主要目标<br>提高进程换入和换出速度，然后提高文件存储空间的利用率，因此对对换空间的管理采取连续分配方式  </li>
<li>对换区空闲盘块管理中的数据结构<br>可以用空闲分区表或空闲分区链，每个表目中包含两项:对换区的首地址及其大小，分别用盘块号和盘块数表示  </li>
<li>对换空间的分配与回收<br>与动态分区一样  <h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3></li>
<li>进程的换出<br>(1)选择被换出的进程<br>(2)进程换出过程  </li>
<li>进程的换入<br>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出”就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程  </li>
</ol>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><ol>
<li><p>页面与物理块<br>(1)页面<br>分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号，内存的物理低址空间分为若干块，同样也为它们加以编号。为进程分配内存时，以块为单位，将进程中的若干个页分别装入到若干个可以不相邻接的物理块中。<br>(2)页面大小  </p>
</li>
<li><p>地址结构<br>分页地址包含两部分内容：前一部分为页号P，后一部分为位(偏)移量W，即页内地址  </p>
</li>
<li><p>页表<br>分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表  </p>
</li>
</ol>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号  </p>
<ol>
<li>基本的地址变换机构<br>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，若未出现错误，则将页表始址与页号和页表项长度的成绩相加，则得到该表项在页表中的位置  </li>
<li>具有快表的地址变换机构<br>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”<br>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中  </li>
</ol>
<h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经给地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间(EAT)  </p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>32位系统中页表可能会很大，所以有两个方法解决问题:<br>(1)对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题<br>(2)只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入  </p>
<ol>
<li>两级页表<br>将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中<br>为离散分配的页表再建立一张页表，称为<strong>外层页表</strong>，在每个页表项中记录了页表页面的物理块号  </li>
<li>多级页表  </li>
</ol>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>为每一个物理块设置一个页表项，并将它们按物理块的序号排序，其中的内容则是页号和其所隶属进程的标识符<br>在利用反置页表进行地址变换时，是根据进程标识符和页号，取检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器  </p>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul>
<li>方便编程  </li>
<li>信息共享  </li>
<li>信息保护  </li>
<li>动态增长  </li>
<li>动态链接  <h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3></li>
</ul>
<ol>
<li>分段<br>在分段存储管理方式中，作业的地址空间被划分为若干段，每个段定义了一组逻辑信息，即每个段既包含了一部分地址空间，又标识了逻辑关系，其逻辑地址由段号和段内地址所组成  </li>
<li>段表<br>在分段式存储管理系统中，为每个分段分配一个连续的分区，进程中的各个段，可以离散地装入内存中不同的分区中，然后建立一个段映射表，<em>段表</em>  </li>
<li>地址变换机构<br>段表寄存器和联想寄存器  </li>
<li>分页和分段的区别  </li>
</ol>
<ul>
<li>页是信息的物理单位  </li>
<li>页的大小固定且由系统决定  </li>
<li>分页的用户程序地址空间是一维的  </li>
</ul>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol>
<li>基本原理<br>先将程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名，系统中需要同时配置段表和页表，段表的内容与分段系统略有不同，是页表始址和页表长度  </li>
<li>地址变换过程<br>首先利用段号S，将它与段长TL进行比较。若S &lt; TL, 表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址  </li>
</ol>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>因为实际运行作业的时候可能会出现:  </p>
<ol>
<li>有的作业很大  </li>
<li>有大量作业要求运行<br>出现上述情况的原因都是内存容量不够大，所以从逻辑上扩充内存容量  <h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><h3 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h3></li>
<li>常规存储器管理方式的特征  </li>
</ol>
<ul>
<li>一次性，是指作业必须一次性地全部装入内存后方能开始运行  </li>
<li>驻留性，是指作业被装入内存后，整个作业都一直驻留再内存中，其中任何部分都不会被换出，直至作业运行结束  </li>
</ul>
<ol start="2">
<li>局部性原理<br>程序在执行时将呈现出局部性规律，即在一较短地时间内，程序的执行仅局限于某个部分，相应地，它访问的存储空间也局限于某个区域  <h3 id="虚拟存储器地定义和特征"><a href="#虚拟存储器地定义和特征" class="headerlink" title="虚拟存储器地定义和特征"></a>虚拟存储器地定义和特征</h3></li>
<li>定义<br>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充地一种存储器系统  </li>
<li>虚拟存储器的特征  </li>
</ol>
<ul>
<li>多次性：指一个作业中的程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行  </li>
<li>对换性：指一个作业中地数据和程序，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出  </li>
<li>虚拟性：指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量  <h3 id="虚拟存储器地实现方法"><a href="#虚拟存储器地实现方法" class="headerlink" title="虚拟存储器地实现方法"></a>虚拟存储器地实现方法</h3></li>
</ul>
<ol>
<li>分页请求系统<br>是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统<br>(1)硬件支持：请求分页的页表机制、缺页中断机制、地址变换机构<br>(2)实现分页请求的软件：包括有用于实现请求调页的软件和实现页面置换的软件  </li>
<li>请求分段系统<br>是在分段系统的基础上，增加了请求调段及分段置换后所形成的段式虚拟存储系统  <h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3></li>
<li>请求页表机制<br>每个页表应该包含页号、物理块号、状态位、访问字段A、修改位M、外存地址  </li>
</ol>
<ul>
<li>状态位P:用于指示该页是否已经调入内存  </li>
<li>访问字段A:用于记录本页在一段时间内被访问的次数  </li>
<li>修改位M:标识该页在调入内存后是否被修改过  </li>
<li>外存地址:用于指出该页在外存上的地址  </li>
</ul>
<ol start="2">
<li>缺页中断机构<br>每当要访问的页面不存在时，便产生一缺页中断，请求OS将所缺之页调入内存，有两个特点:<br>(1)在指令执行期间产生和处理中断信号<br>(2)一条指令在执行期间可能产生多次缺页中断  </li>
<li>地址变换机构<br><img src="%E5%9B%BE5-2.png" alt="地址变换过程">  </li>
</ol>
<h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ol>
<li>最小的物理块数的确定<br>指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行  </li>
<li>内存分配策略  </li>
</ol>
<ul>
<li>固定分配局部置换:为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，如何再调入一页，然后再调入一夜，以保证分配给该进程的内存空间不变  </li>
<li>可变分配全局置换:指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地增加或减少。如果在进程运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块中选出一块换出  </li>
<li>可变分配局部置换:只允许在该进程的内存页面选择一页换出，若频繁缺页，则增加进程页面  </li>
</ul>
<ol start="3">
<li>物理块分配算法  </li>
</ol>
<ul>
<li>平均分配</li>
<li>按比例分配  </li>
<li>优先权分配  <h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3></li>
</ul>
<ol>
<li>何时调入页面  </li>
</ol>
<ul>
<li>预调页策略</li>
<li>请求调页策略  </li>
</ul>
<ol start="2">
<li>从何处调入页面<br>外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区<br>对换区一般采用连续分配方式，文件区一般采用离散分配方式<br>(1)系统拥有足够的对换区空间:<br>这时可以全部从对换区调入所需页面<br>(2)系统缺少足够的对换区空间:<br>不会被修改的文件，直接从文件区调入，会被修改的，须先调到对换区<br>(3)UNIX方式:<br>未运行过的页面，都从文件区调入，对于曾经运行过但又被换出的页面，从对换区调入  </li>
<li>调入过程<br>先找物理块位置，如果内存未满，调入；已满，置换。被置换的若被修改过，重写进磁盘  </li>
<li>缺页率<br>访问失败次数/总访问次数  <h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><a href="https://www.cnblogs.com/Leophen/p/11397699.html" target="_blank" rel="noopener">置换算法</a><h3 id="访问内存的有效时间-1"><a href="#访问内存的有效时间-1" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3>(1)被访问页在内存中，且其对应的页表项在快表中<br>EAT = 查找快表的时间+访问实际物理地址的时间<br>(2)被访问页在内存中，且其对应的页表项不在快表中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间<br>(3)被访问页不在内存中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间+处理断页中断的时间+更新快表的时间+访问实际物理地址的时间  <h2 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h2><h3 id="多道程序度和”抖动”"><a href="#多道程序度和”抖动”" class="headerlink" title="多道程序度和”抖动”"></a>多道程序度和”抖动”</h3></li>
<li>多道程序度和处理机的利用率<br>处理机的实际利用率随着进程数的增加而提高，但达到一定数目时开始下降  </li>
<li>抖动<br>在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求  <h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3>工作集是指，在某段时间间隔里，进程实际所要访问页面的集合  <h3 id="“抖动”的预防办法"><a href="#“抖动”的预防办法" class="headerlink" title="“抖动”的预防办法"></a>“抖动”的预防办法</h3></li>
<li>采用局部置换策略  </li>
<li>把工作集算法融入到处理机调度中  </li>
<li>利用”L=S”准则调节缺页率<br>L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面的时间  </li>
</ol>
<ul>
<li>L &gt;&gt; S，说明很少缺页，磁盘未充分利用  </li>
<li>L &lt;&lt; S,说明频繁缺页</li>
<li>L = S，完美  </li>
</ul>
<ol start="4">
<li>选择暂停的进程  <h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><img src="%E5%9B%BE5-3.png" alt="段表结构">  </li>
</ol>
<ul>
<li>缺段中断机构<br>一条指令不可能被分割在两个分段中<br><img src="%E5%9B%BE5-4.png" alt="中断处理"></li>
<li>地址变换机构<br><img src="%E5%9B%BE5-5.png" alt="地址变换">  <h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3></li>
</ul>
<ol>
<li>共享段表<br>配置一张共享段表，所有各共享段表中占有一表项。在表项上面记录了共享段的段号、段长、内存始址、状态(存在)位、外存始址以及共享计数等信息  </li>
</ol>
<ul>
<li>共享进程数:显示当前共享该分段的进程数  </li>
<li>存取控制字段:赋予不同进程不同权限  </li>
<li>段号:不同的进程有不同的段号  </li>
</ul>
<ol start="2">
<li>共享段的分配与回收<br>(1)共享段的分配<br>对第一个请求使用该共享段的进程，系统为该共享段分配一物理区，再把共享段调入该区。同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中添加一表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1，之后的count+1，再添加表项<br>(2)共享段的回收<br>撤销进程段表中共享段所对应的表项,count-1  </li>
<li>分段保护  </li>
</ol>
<ul>
<li>越界检查  </li>
<li>存取控制检测  </li>
<li>环保护机构  <h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h3></li>
</ul>
<ol>
<li>中断和陷入  </li>
</ol>
<ul>
<li>中断是指CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，叫做外中断  </li>
<li>陷入是CPU内部事件引发的中断，如运算溢出，程序出错，称为内中断  </li>
</ul>
<ol start="2">
<li>中断向量表和中断优先级  </li>
</ol>
<ul>
<li>中断向量表是为每种设备配以中断的不同类，处理的时候直接查表找处理程序</li>
<li>中断优先级，为每个中断规定不同的优先级  </li>
</ul>
<ol start="3">
<li>多中断源的处理方式</li>
</ol>
<ul>
<li>屏蔽中断<br>当处理机在处理一个中断时，将屏蔽其他所有中断  </li>
<li>嵌套中断<br>(1)当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求<br>(2)高优先级的中断请求可以抢占正在运行的低优先级中断的处理机  <h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3></li>
<li>测定是否有未响应的中断信号  </li>
<li>保护被中断进程的CPU环境  </li>
<li>转入相应的设备处理程序  </li>
<li>中断处理  </li>
<li>恢复CPU的现场并退出中断：<br>是否会返回到被中断的进程取决于哪个阶段：</li>
<li>是否采用屏蔽中断方式，若采用则返回  </li>
<li>采用的是中断嵌套方式，若没有更高优先级的中断，仍被返回被中断进程  <h3 id="对I-O设备的控制方式"><a href="#对I-O设备的控制方式" class="headerlink" title="对I/O设备的控制方式"></a>对I/O设备的控制方式</h3></li>
</ul>
<ol>
<li>采用轮询的可编程I/O方式<br>设置busy标志，输入未完成时为1，完成时为0  </li>
<li>使用中断的可编程I/O方式<br>CPU和I/O设备可以并行操作  </li>
<li>直接存储器访问方式  </li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/" rel="next" title="Android逆向学习">
                <i class="fa fa-chevron-left"></i> Android逆向学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" rel="prev" title="C++反汇编与逆向分析技术">
                C++反汇编与逆向分析技术 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/05/19/操作系统/"
           data-title="操作系统" data-url="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kittener</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kittener" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="mail">
                      
                        <i class="fa fa-fw fa-globe"></i>mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/kittener" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引论"><span class="nav-number">1.</span> <span class="nav-text">引论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的目标"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统的目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单道批处理系统"><span class="nav-number">1.3.</span> <span class="nav-text">单道批处理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多道批处理系统"><span class="nav-number">1.4.</span> <span class="nav-text">多道批处理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分时系统"><span class="nav-number">1.5.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的种类"><span class="nav-number">1.6.</span> <span class="nav-text">操作系统的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本特性"><span class="nav-number">1.7.</span> <span class="nav-text">基本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">1.7.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享"><span class="nav-number">1.7.2.</span> <span class="nav-text">共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟"><span class="nav-number">1.7.3.</span> <span class="nav-text">虚拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的功能"><span class="nav-number">1.8.</span> <span class="nav-text">操作系统的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理机管理功能"><span class="nav-number">1.8.1.</span> <span class="nav-text">处理机管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器管理功能"><span class="nav-number">1.8.2.</span> <span class="nav-text">存储器管理功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程的描述与控制"><span class="nav-number">2.</span> <span class="nav-text">进程的描述与控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">2.1.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信的类型"><span class="nav-number">2.1.1.</span> <span class="nav-text">进程通信的类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理机调度与死锁"><span class="nav-number">3.</span> <span class="nav-text">处理机调度与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理机调度的层次和调度算法的目标"><span class="nav-number">3.1.</span> <span class="nav-text">处理机调度的层次和调度算法的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理机调度的层次"><span class="nav-number">3.1.1.</span> <span class="nav-text">处理机调度的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理机调度算法的目标"><span class="nav-number">3.1.2.</span> <span class="nav-text">处理机调度算法的目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作业与作业调度"><span class="nav-number">3.2.</span> <span class="nav-text">作业与作业调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度"><span class="nav-number">3.3.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度方式"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程调度方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮转调度算法"><span class="nav-number">3.3.2.</span> <span class="nav-text">轮转调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级调度算法"><span class="nav-number">3.3.3.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多队列调度算法"><span class="nav-number">3.3.4.</span> <span class="nav-text">多队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">3.3.5.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于公平原则的调度算法"><span class="nav-number">3.3.6.</span> <span class="nav-text">基于公平原则的调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实时调度"><span class="nav-number">3.4.</span> <span class="nav-text">实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现实时调度的基本条件"><span class="nav-number">3.4.1.</span> <span class="nav-text">实现实时调度的基本条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时调度算法的分类"><span class="nav-number">3.4.2.</span> <span class="nav-text">实时调度算法的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最早截止时间优先算法-EDF"><span class="nav-number">3.4.3.</span> <span class="nav-text">最早截止时间优先算法(EDF)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最低松弛度优先算法-LLF"><span class="nav-number">3.4.4.</span> <span class="nav-text">最低松弛度优先算法(LLF)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级倒置-priority-inversion-problem"><span class="nav-number">3.4.5.</span> <span class="nav-text">优先级倒置(priority inversion problem)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁概述"><span class="nav-number">3.5.</span> <span class="nav-text">死锁概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#资源问题"><span class="nav-number">3.5.1.</span> <span class="nav-text">资源问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机中的死锁"><span class="nav-number">3.5.2.</span> <span class="nav-text">计算机中的死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的定义、必要条件和处理方法"><span class="nav-number">3.5.3.</span> <span class="nav-text">死锁的定义、必要条件和处理方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预防死锁"><span class="nav-number">3.6.</span> <span class="nav-text">预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“请求和保持”条件"><span class="nav-number">3.6.1.</span> <span class="nav-text">破坏“请求和保持”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“不可抢占”条件"><span class="nav-number">3.6.2.</span> <span class="nav-text">破坏“不可抢占”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“循环等待”条件"><span class="nav-number">3.6.3.</span> <span class="nav-text">破坏“循环等待”条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免死锁"><span class="nav-number">3.7.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统安全状态"><span class="nav-number">3.7.1.</span> <span class="nav-text">系统安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#银行家算法"><span class="nav-number">3.7.2.</span> <span class="nav-text">银行家算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储器管理"><span class="nav-number">4.</span> <span class="nav-text">存储器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器的层次结构"><span class="nav-number">4.1.</span> <span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多层结构的存储器结构"><span class="nav-number">4.1.1.</span> <span class="nav-text">多层结构的存储器结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序的装入和链接"><span class="nav-number">4.2.</span> <span class="nav-text">程序的装入和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的装入"><span class="nav-number">4.2.1.</span> <span class="nav-text">程序的装入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的链接"><span class="nav-number">4.2.2.</span> <span class="nav-text">程序的链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续分配存储管理方式"><span class="nav-number">4.3.</span> <span class="nav-text">连续分配存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一连续分配"><span class="nav-number">4.3.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区分配"><span class="nav-number">4.3.2.</span> <span class="nav-text">固定分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区分配"><span class="nav-number">4.3.3.</span> <span class="nav-text">动态分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于顺序搜索的动态分区分配算法"><span class="nav-number">4.3.4.</span> <span class="nav-text">基于顺序搜索的动态分区分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于索引搜索的动态分区分配算法"><span class="nav-number">4.3.5.</span> <span class="nav-text">基于索引搜索的动态分区分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态可重定位分区分配"><span class="nav-number">4.3.6.</span> <span class="nav-text">动态可重定位分区分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对换-Swapping"><span class="nav-number">4.4.</span> <span class="nav-text">对换(Swapping)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序环境下的对换技术"><span class="nav-number">4.4.1.</span> <span class="nav-text">多道程序环境下的对换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对换空间的管理"><span class="nav-number">4.4.2.</span> <span class="nav-text">对换空间的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的换出与换入"><span class="nav-number">4.4.3.</span> <span class="nav-text">进程的换出与换入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页存储管理方式"><span class="nav-number">4.5.</span> <span class="nav-text">分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分页存储管理的基本方法"><span class="nav-number">4.5.1.</span> <span class="nav-text">分页存储管理的基本方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址变换机构"><span class="nav-number">4.5.2.</span> <span class="nav-text">地址变换机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问内存的有效时间"><span class="nav-number">4.5.3.</span> <span class="nav-text">访问内存的有效时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级和多级页表"><span class="nav-number">4.5.4.</span> <span class="nav-text">两级和多级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反置页表"><span class="nav-number">4.5.5.</span> <span class="nav-text">反置页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分段存储管理方式"><span class="nav-number">4.6.</span> <span class="nav-text">分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分段存储管理方式的引入"><span class="nav-number">4.6.1.</span> <span class="nav-text">分段存储管理方式的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段系统的基本原理"><span class="nav-number">4.6.2.</span> <span class="nav-text">分段系统的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式存储管理方式"><span class="nav-number">4.6.3.</span> <span class="nav-text">段页式存储管理方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟存储器"><span class="nav-number">5.</span> <span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟存储器概述"><span class="nav-number">5.1.</span> <span class="nav-text">虚拟存储器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常规存储管理方式的特征和局部性原理"><span class="nav-number">5.1.1.</span> <span class="nav-text">常规存储管理方式的特征和局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器地定义和特征"><span class="nav-number">5.1.2.</span> <span class="nav-text">虚拟存储器地定义和特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器地实现方法"><span class="nav-number">5.1.3.</span> <span class="nav-text">虚拟存储器地实现方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分页存储管理方式"><span class="nav-number">5.2.</span> <span class="nav-text">请求分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求分页中的硬件支持"><span class="nav-number">5.2.1.</span> <span class="nav-text">请求分页中的硬件支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求分页中的内存分配"><span class="nav-number">5.2.2.</span> <span class="nav-text">请求分页中的内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面调入策略"><span class="nav-number">5.2.3.</span> <span class="nav-text">页面调入策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面置换算法"><span class="nav-number">5.3.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#访问内存的有效时间-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">访问内存的有效时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“抖动”与工作集"><span class="nav-number">5.4.</span> <span class="nav-text">“抖动”与工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序度和”抖动”"><span class="nav-number">5.4.1.</span> <span class="nav-text">多道程序度和”抖动”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作集"><span class="nav-number">5.4.2.</span> <span class="nav-text">工作集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“抖动”的预防办法"><span class="nav-number">5.4.3.</span> <span class="nav-text">“抖动”的预防办法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分段存储管理方式"><span class="nav-number">5.5.</span> <span class="nav-text">请求分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分段的共享与保护"><span class="nav-number">5.5.1.</span> <span class="nav-text">分段的共享与保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输入输出系统"><span class="nav-number">6.</span> <span class="nav-text">输入输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#中断机构和中断处理程序"><span class="nav-number">6.1.</span> <span class="nav-text">中断机构和中断处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断简介"><span class="nav-number">6.1.1.</span> <span class="nav-text">中断简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理程序"><span class="nav-number">6.1.2.</span> <span class="nav-text">中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对I-O设备的控制方式"><span class="nav-number">6.1.3.</span> <span class="nav-text">对I&#x2F;O设备的控制方式</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kittener</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FSYBzoLmcoINlfmLJmsXaDA8-gzGzoHsz',
        appKey: 'aYNlN8CfvruV4yvdvxARsbD5',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  
 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
 <script type="text/javascript" src="/js/src/fireworks.js"></script>
 </pre>
</body>
</html>
