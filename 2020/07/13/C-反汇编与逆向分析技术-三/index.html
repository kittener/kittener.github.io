<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="RUQLkWDKqj" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记," />




  


  <link rel="alternate" href="/atom.xml" title="Kittener's blog" type="application/atom+xml" />






<meta name="description" content="记录一下《C++反汇编与逆向分析技术》(三)">
<meta property="og:type" content="article">
<meta property="og:title" content="C++反汇编与逆向分析技术(三)">
<meta property="og:url" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/index.html">
<meta property="og:site_name" content="Kittener&#39;s blog">
<meta property="og:description" content="记录一下《C++反汇编与逆向分析技术》(三)">
<meta property="og:image" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/P1.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/P2.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/P3.jpg">
<meta property="og:image" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/P4.jpg">
<meta property="article:published_time" content="2020-07-13T04:42:35.000Z">
<meta property="article:modified_time" content="2020-07-23T03:18:58.189Z">
<meta property="article:author" content="Kittener">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/P1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.kittener.top/2020/07/13/C-反汇编与逆向分析技术-三/"/>





  <title>C++反汇编与逆向分析技术(三) | Kittener's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kittener's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kittener">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kittener's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++反汇编与逆向分析技术(三)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-13T12:42:35+08:00">
                2020-07-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-07-23T11:18:58+08:00">
                2020-07-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/13/C-反汇编与逆向分析技术-三/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录一下《C++反汇编与逆向分析技术》(三)  </p>
<a id="more"></a>  

<h1 id="流程控制语句的识别"><a href="#流程控制语句的识别" class="headerlink" title="流程控制语句的识别"></a>流程控制语句的识别</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句只能判断两种情况:“0”为假值，“非0”为真值。如果为真值，则进人语句块内执行语句;如果为假值，则跳过if语句块，继续运行程序的其他语句。要注意的是，if语句转换的条件跳转指令与if语句的判断结果是相反的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：if语句结构组成</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">	printf(&quot;%d \r\n&quot;, argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;如果argc &#x3D; 0的情况，为真</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F;使用cmp指令，将ebp+8地址的4字节和0相减</span><br><span class="line">&#x2F;&#x2F;结果argc不改变，淡水会改变CF,ZF,OF,AF和PF</span><br><span class="line">00401028	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;JNE看ZF，如果等于0跳转，表示现在的argc不等于0</span><br><span class="line">&#x2F;&#x2F;跳转到0x40103F</span><br><span class="line">&#x2F;&#x2F;这个地址为if的结束地址，之后跳转出if</span><br><span class="line">0040102C	jne	main+2F(0040103f)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;函数返回</span><br><span class="line">return 0;</span><br><span class="line">0040103F	xor	eax,eax</span><br></pre></td></tr></table></figure>

<p>出现这种情况是因为汇编语言的条件跳转是满足某条件则跳转，绕过某些代码块，这一点是与C语言<strong>相反</strong>的，而C语言编译器不将else语句块提到if语句块前面是因为C语言是根据<strong>代码行的位置来决定编译后的二进制代码的地址高低的</strong>，也就是说，低行数对应低地址，高行数对应高地址</p>
<p>根据这一特性，如果将if语句中的比较条件 “argc==0” 修改为 “if(argc &gt; 0)”，则其对应的汇编语言所使用的条件跳转指令会是“小于等于0”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if语句大于0比较</span><br><span class="line">if( argc &gt; 0 )&#123;</span><br><span class="line">	printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码</span><br><span class="line">&#x2F;&#x2F;C++源码对比，如果参数argc大于0，结果为真，进入执行语句</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">&#x2F;&#x2F;使用cmp，将ebp+8地址的4字节数据和0进行减法</span><br><span class="line">0040103F	cmp dword ptr [ebp+8],0</span><br><span class="line">00401043	jle	MyIf + 42h (00401052)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">00401052	pop edi</span><br></pre></td></tr></table></figure>

<p>在分析过程中，表达式短路(上一篇blog的内容)和if语句这两种分支结构的实现结构都是一样的，蛮难区分的</p>
<p><strong>总结：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">；先执行各类影响标志位的指令</span><br><span class="line">；其后是各种条件跳转指令</span><br><span class="line">jxx		xxxx</span><br></pre></td></tr></table></figure>

<p>如果遇上以上指令序列，大概率是一个if语句组成的单分支结构</p>
<h2 id="if···else···语句"><a href="#if···else···语句" class="headerlink" title="if···else···语句"></a>if···else···语句</h2><p>if和if···else···的流程对比</p>
<p><img src="P1.jpg" alt="结构对比"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if  else</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	printf(&quot;argc &#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	printf(&quot;argc !&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">004010B8	cmp	dword ptr [ebp+8],0 &#x2F;&#x2F;相减</span><br><span class="line">004010BC	jne	IfElse+2Dh	(004010cd)&#123;</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">&#125;</span><br><span class="line">004010CB	jmp	IfElse+3Ah (004010da)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;进入else</span><br><span class="line">004010CD	push offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">004010D2	call printf (00401150)</span><br><span class="line">004010D7	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结束</span><br><span class="line">004010DA	pop edi</span><br></pre></td></tr></table></figure>

<p>将上述代码稍作改动，改为符合条件表达式转换方式1的形式，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，if...else..模拟条件表达式转换方式</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	argc &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	argc &#x3D; 6;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc); &#x2F;&#x2F;防止argc被优化处理</span><br><span class="line">&#x2F;&#x2F;对应汇编，debug版，无优化</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">00401098	cmp	dword ptr [ebp+8],0</span><br><span class="line">0040109c	jne	main+27h(004010a7)</span><br><span class="line">argc &#x3D; 5;</span><br><span class="line">0040109E	mov	dword ptr [ebp+8],5</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">004010A5	jmp	main+2Eh(004010ae)</span><br><span class="line">argc &#x3D; 6;</span><br><span class="line">004010A7	mov dword ptr [ebp+8],6</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#x2F;&#x2F;略</span><br><span class="line">004010AE	...</span><br></pre></td></tr></table></figure>

<p>还是挺简单的，总结一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">总结结构：</span><br><span class="line">&#x2F;&#x2F;产生修改标志位的指令</span><br><span class="line">jxx else_begin</span><br><span class="line">if begin:</span><br><span class="line">&#x2F;&#x2F;执行if中的内容</span><br><span class="line">if end:</span><br><span class="line">jmp else end</span><br><span class="line">else begin:</span><br><span class="line">&#x2F;&#x2F;执行else的内容</span><br><span class="line">else end</span><br></pre></td></tr></table></figure>

<p>这两个跳转指令就是辨识的关键，不过和条件表达式差不多，所以反推的时候看个人习惯</p>
<p>上面那份代码是debug版，下面给个O2优化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取到的参数数据放在edx中</span><br><span class="line">mov	edx,[esp+argc_0]</span><br><span class="line">&#x2F;&#x2F;将eax清0</span><br><span class="line">xor	eax,eax</span><br><span class="line">&#x2F;&#x2F;对edx和edx进行想与的操作，结果不影响edx</span><br><span class="line">test edx,edx</span><br><span class="line">&#x2F;&#x2F;检查ZF的标记位，edx不等于0的时候，我们的al &#x3D; 1，等于0 我们的al &#x3D; 0</span><br><span class="line">setnz al</span><br><span class="line">add eax,5 &#x2F;&#x2F;这里可能是5&#x2F;6，看al了，我们不等于0，那么就是6，我们等于0，那么就是5</span><br><span class="line">push eax</span><br><span class="line">push offset Format ; &quot;%d \r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">add	esp,8</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>可以看到优化了很多，做了一个流水线优化，还是蛮难还原回去的</p>
<h2 id="用if构成的多分支流程"><a href="#用if构成的多分支流程" class="headerlink" title="用if构成的多分支流程"></a>用if构成的多分支流程</h2><p>多分支结构就是if···else if···else if···else···这种结构，直接看代码吧，这是debug版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，多分支结构</span><br><span class="line">void IfElseIf(int argc)&#123;</span><br><span class="line">if (argc &gt; 0)&#123;</span><br><span class="line">	printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">	printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	printf(&quot;argc &lt;&#x3D; 0&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">00401108	cmp	dword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;相减 argc-0 之后使用小于等于跳转的条件,jle</span><br><span class="line">0040110C	jle	IfElseIf+2Dh(0040111d) &#x2F;&#x2F;到else位置，目测那边是一个cmp 一个jne&#123;</span><br><span class="line">printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">0040110E	push offset string &quot;argc &gt; 0&quot;(00420f9c)</span><br><span class="line">00401113	call printf(00401150)</span><br><span class="line">00401118	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">else if ( argc &#x3D;&#x3D; 0 )</span><br><span class="line">0040111B	jmp	IfElseIf+4Fh(0040113f)</span><br><span class="line">&#x2F;&#x2F;if比较转换，和我上面目测的差不多一个cmp，一个jne</span><br><span class="line">0040111D	cmp	dword ptr [ebp+8],0</span><br><span class="line">00401121	jne	IfElseIf+42h(00401132) &#x2F;&#x2F;到下一个else的位置，直接就是执行了</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">00401123	push offset string &quot;argc &#x3D;&#x3D; 0&quot;(0042003c)</span><br><span class="line">00401128	call printf(00401150)</span><br><span class="line">0040112D	add esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳转到多分支结构结束地址</span><br><span class="line">00401130	jmp	IfElseIf+4Fh(0040113f)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &lt; &#x3D; 0&quot;);&#x2F;&#x2F;上面都不满足，无条件执行</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">00401132	push offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">00401137	call printf (00401150)</span><br><span class="line">0040113C	add	esp,4</span><br><span class="line">&#125;</span><br><span class="line">0040113F	pop	edi</span><br></pre></td></tr></table></figure>

<p>debug版的代码看着还是舒适，就是一个很简单的cmp+跳转指令，来个总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else if begin</span><br><span class="line">if begin:</span><br><span class="line">...</span><br><span class="line">if end:</span><br><span class="line">jmp end</span><br><span class="line">else if begin:</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else begin</span><br><span class="line">...</span><br><span class="line">else if end:</span><br><span class="line">jmp end</span><br><span class="line">else begin</span><br><span class="line">...</span><br><span class="line">end:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在编译期间，永远不可抵达的分支将被优化掉而不参与编译处理，在写代码的时候，可以在每个else if的代码块里加个return，这样就可以减少分支比较。</p>
<p>看一下开启O2优化的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 sub_401000	proc near ; CODE XREF: _main+5p</span><br><span class="line">&#x2F;&#x2F;arg_0为函数参数</span><br><span class="line">.text:00401000 arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取出参数数据，放入eax，进行第一次if比较</span><br><span class="line">.text:00401000	mov eax,[esp+arg_0]</span><br><span class="line">.text:00401004	test eax,eax</span><br><span class="line">&#x2F;&#x2F;比较后进行转移，目测jle</span><br><span class="line">.text:00401006	jle	short loc_401016</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">.text:00401008	push offset Format ; &quot;argc &gt; 0&quot;</span><br><span class="line">.text:0040100D	call _printf</span><br><span class="line">.text:00401012	add esp,4</span><br><span class="line">&#x2F;&#x2F;使用retn指令返回，结束函数调用</span><br><span class="line">.text:00401015	retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代表此处代码被符号sub_401000地址加6的地方引用</span><br><span class="line">.text:00401016 loc_401006:	 ;CODE XREF: sub_401000+6j</span><br><span class="line">&#x2F;&#x2F;这里目测因为有test的问题 直接jne就可以</span><br><span class="line">.text:00401018	push offset aArgc0_0 ; &quot;argc &#x3D;&#x3D; 0&quot;</span><br><span class="line">.text:0040101D	call _printf</span><br><span class="line">.text:00401022	add esp,4</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">.text:00401025	retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前两次失败没返回直接执行此处</span><br><span class="line">.text:00401026	loc_401026: ; CODE XREF: sub_401000:loc_401016j</span><br><span class="line">.text:00401026	push offset aArgc0_1; &quot;argc &lt;&#x3D; 0&quot;</span><br><span class="line">.text:0040102B	call _printf</span><br><span class="line">.text:00401030	pop ecx</span><br><span class="line">.text:00401031	retn</span><br><span class="line">.text:00401031	sub_401000	endp</span><br></pre></td></tr></table></figure>

<p>有内味了，看来现在的出题人都喜欢开O2优化</p>
<h2 id="switch的真相"><a href="#switch的真相" class="headerlink" title="switch的真相"></a>switch的真相</h2><p>看一下3条case语句的switch跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">switch (nIndex&#125; &#123;				&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF00	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">;取出变量nIndex的值并放到ecx中，再将ecx放入临时变量ebp - 8中</span><br><span class="line">0040DF03	mov		dword ptr [ebp-8] , ecx</span><br><span class="line">;将临时变量和1进行比较</span><br><span class="line">0040DF06	cmp		dword ptr [ebp-8] ,1</span><br><span class="line">;条件跳转比较，等于1则跳转到地址0x0040DF1A处</span><br><span class="line">0040DF0A 	je		SwitchIf+4Ah (0040df1a)</span><br><span class="line">;将临时变量和3比较</span><br><span class="line">0040DFOC	cmp		dword ptr [ebp-8] ,3</span><br><span class="line">;条件跳转比较，等于3则跳转到地址0x0040DF29处</span><br><span class="line">0040DF10	je		SwitchIf+59h (0040df29)</span><br><span class="line">;将临时变量和100比较</span><br><span class="line">0040DF12	cmp		dword ptr [ebp-8] , 64h</span><br><span class="line">;条件跳转比较，等于100则跳转到地址0x0040DF38处</span><br><span class="line">0040DF16	je		SwitchIf+68h (0040df38)</span><br><span class="line">0040DF18	jmp		SwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 1:    	&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;  &#x2F;&#x2F;源码对比</span><br><span class="line">0040DF1A	push	offset string &quot;nIndex &#x3D;&#x3D; 1&quot; (00421024)</span><br><span class="line">0040DF1F	call	printf (004014b0)</span><br><span class="line">0040DF24	add		esp,4</span><br><span class="line">break;		&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF27	jmp		SwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 3:		&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;		&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF29	push	offset string &quot;nIndex &#x3D;&#x3D; 3&quot; (004210d8)</span><br><span class="line">0040DF2E	call	printf (004014b0)</span><br><span class="line">0040DF33	add		esp,4</span><br><span class="line"></span><br><span class="line">case 100:		&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 100&quot;); 		&#x2F;&#x2F; 源码对比</span><br><span class="line">0040DF38	push	offset string &quot;nIndex &#x3D;&#x3D; 100&quot; (0042004c)</span><br><span class="line">0040DF3D	call	printf (004014b0)</span><br><span class="line">0040DF42	add		esp,4</span><br><span class="line">break;</span><br><span class="line">&#125;&#125;				&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF45	pop		edi</span><br></pre></td></tr></table></figure>

<p>可以看到与if···else差距还是挺大的，if···else是跳转后跟着语句块，而switch结构则将所有的条件跳转都放在了一起。这样就实现了C语法的要求，在case语句块中没有break语句时，可以顺续执行后续case语句块</p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov		reg, mem		;取出switch中考察的变量</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx			; 跳转到对应case语句块的首地址</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxx		xxxx</span><br><span class="line">jmp		END				; 跳转到switch的结尾地址处</span><br><span class="line">......					; case语句块的首地址</span><br><span class="line">jmp		END				; case语句块结束，有break则产生这个jmp</span><br><span class="line">&#x2F;&#x2F;下同</span><br><span class="line">END:					; switch结尾</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这是switch分支数小于4的情况下，VC++ 6.0采用的策略，当分支数大于3时，并且case的判定值存在明显线性关系组合时，switch的优化特性便可以凸显出来，如代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++示例代码</span><br><span class="line">int nIndex &#x3D; 0;</span><br><span class="line">scanf (&quot;%d&quot;, &amp; nIndex) ;</span><br><span class="line">switch (nIndex) &#123;</span><br><span class="line">	case 1: printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;break;</span><br><span class="line">	case 2: printf (&quot;nIndex &#x3D;&#x3D; 2&quot;) ;break;</span><br><span class="line">	case 3: printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;break;</span><br><span class="line">	case 5: printf (&quot;nIndex &#x3D;&#x3D; 5&quot;) ;break;</span><br><span class="line">	case 6: printf (&quot;nIndex &#x3D;&#x3D; 6&quot;) ;break;</span><br><span class="line">	case 7: printf (&quot;nIndex &#x3D;&#x3D; 7&quot;) ;break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;debug版</span><br><span class="line">switch (nIndex)&#123;		&#x2F;&#x2F;源码对比</span><br><span class="line">;将变量nIndex内容放入ecx中</span><br><span class="line">00401110	mov		ecx, dword ptr [ebp-4]</span><br><span class="line">;取出ecx的值并放入临时变量ebp-8中</span><br><span class="line">00401113	mov		dword ptr [ebp-8] , ecx </span><br><span class="line">;取临时变量的值放入edx中，这几句代码的功能看似没有区别</span><br><span class="line">;只有在Debug版下才会出现</span><br><span class="line">00401116	mov		edx, dword ptr [ebp-8]</span><br><span class="line">;对edx减1,进行下标平衡</span><br><span class="line">00401119	sub		edx, 1</span><br><span class="line">;将减1后的临时变量放回</span><br><span class="line">0040111C 	mov		dword ptr [ebp-8] , edx</span><br><span class="line">;判断临时变量是否大于6</span><br><span class="line">0040111F	cmp		dword ptr [ebp-8] ,6</span><br><span class="line">;大于6跳转到0x00401187处</span><br><span class="line">00401123 	ja		$L556+0Dh (00401187)</span><br><span class="line">;取出临时变量的值放到eax中</span><br><span class="line">00401125	mov		eax, dword ptr [ebp-8] </span><br><span class="line">;以eax为下标，0x00401198为基址进行寻址，跳转到该地址处</span><br><span class="line">;注意:地址0x00401198就是case地址数组</span><br><span class="line">00401128	jmp		dword ptr [eax*4+401198h]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将case语句块的首地址保存在一个数组中，并且数组下标以0为起始，在进入switch后会先进行一次比较，检查输入的值是否大于case的最大值。case地址数组如下：</p>
<p><img src="P2.jpg" alt="有序线性case地址表"></p>
<p>如果每两个case值之间的差值小于等于6，并且case语句数大于等于4,编译器中就会形成这种线性结构。在编写代码的过程中无需有序排列case值，编译器会在编译过程中对case线性地址表进行排序，如case的顺序为3、2、1、 4、5，在case线性地址表中，会将它们的语句块的首地址进行排序，将case 1语句块的首地址放在case线性地址表的第0项上,case 2语句块首地址放在表中第1项，以此类推，将首地址变为一个有序的表格进行存放，如图</p>
<p><img src="P3.jpg" alt="模拟图"></p>
<p>给出release版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;取出switch语句的参数值并放入ecx中</span><br><span class="line">00401018	mov		ecx, dword ptr [esp+8]</span><br><span class="line">0040101C	add		esp, 8		;平衡scanf函数的参数</span><br><span class="line"></span><br><span class="line">;将ecx减1后放入eax中，因为最小的case 1存放在case地址表中下标为0处，需要调整对齐到0下标，便于直接查表</span><br><span class="line">0040101F	lea		eax, [ecx-1]</span><br><span class="line">;与6进行比较，有了这两步操作可以初步假设这里的代码是一个switch结构</span><br><span class="line">;无符号比较，大于6时跳转到地址0x00401086处</span><br><span class="line">00401022	cmp		eax,6</span><br><span class="line">00401025	ja		00401086</span><br><span class="line"></span><br><span class="line">;下面的指令体现了switch的第二个特性;查表(case地址表)</span><br><span class="line">;可以确认这是一个switch结构</span><br><span class="line">;上一步的跳转地址00401086就是switch结尾或者是default语句块的首地址</span><br><span class="line">;下面指令中的地址0x00401088便是case线性地址表的首地址</span><br><span class="line">00401027	jmp		dword ptr [eax* 4+401088h]</span><br><span class="line">;地址0x0040706C为字符串&quot;nIndex &#x3D;&#x3D; 1&quot;的首地址</span><br><span class="line">;此处为第一个case语句块的地址</span><br><span class="line">0040102E	push	40706Ch</span><br><span class="line">&#x2F;&#x2F;调用printf函数</span><br><span class="line">00401033	call	004012F0</span><br><span class="line">;平衡printf函数破坏的栈空间</span><br><span class="line">00401038	add		esp,4</span><br><span class="line">;还原esp</span><br><span class="line">0040103B	pop		ecx</span><br><span class="line">;返回，在Release版中，煸译器发现switch后什么也没做就直接返回，所以</span><br><span class="line">;将每句break优化为了return</span><br><span class="line">;到此处，第一-个case语句块结束，顺序向下为第二个case语句块</span><br><span class="line">0040103C	ret</span><br><span class="line"></span><br><span class="line">;第二个case语句块</span><br><span class="line">;地址0x00407060为字符串&quot;nIndex m&#x3D; 2&quot;的首地址</span><br><span class="line">0040103D	push	407060h</span><br><span class="line">00401042	call	004012F0</span><br><span class="line">00401047	add		esp,4</span><br><span class="line">0040104A	pop		ecx</span><br><span class="line">0040104B	ret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面代码类似，不写了</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov		reg,mem			;取变量</span><br><span class="line">;对变量进行运算，对齐case地址表的0下标，非必要</span><br><span class="line">;上例中的eax也可用其他寄存器替换，这里也可以是其他类型的运算</span><br><span class="line">lea		eax,[reg+xxxx]</span><br><span class="line"></span><br><span class="line">;影响标志位的指令，迸行范围检查</span><br><span class="line">jxx		DEFAULT_ADDR</span><br><span class="line">jmp		dword ptr [eax*4+xxxx]; 地址xxxx为case地址表的首地址</span><br></pre></td></tr></table></figure>

<p>当遇到这样的代码块时，可获取某一变量的信息并对其进行范围检查，如果超过case的最大值，则跳转条件成立，跳转目标指明了switch语句块的末尾或者是default块的首地址。条件跳转后紧跟jmp指令，并且是相对比例因子寻址方式，且基址为地址表的首地址，说明此处是线性关系的switch分支结构</p>
<h2 id="难以构成跳转表的switch"><a href="#难以构成跳转表的switch" class="headerlink" title="难以构成跳转表的switch"></a>难以构成跳转表的switch</h2><p>对于两个case值间隔较大时，编译器用索引表来优化，索引表优化需要两张表：一张为case语句块地址表，另一张为case语句块索引表。</p>
<p>地址表中的每一项保存一个case语句块的首地址，有几个case语句块就有几项。default语句块也在其中，如果没有则保存一个switch结束地址。这个结束地址在地址表中只会保存一份，不会像有序线性地址表那样，重复保存switch的结束地址。</p>
<p>索引表中保存地址表的编号，它的大小等于最大case值和最小case值的差。当差值大于255时，这种优化方案也会浪费空间，可通过树方式优化，这里就只讨论差值小于或等于255的情况。表中的每- -项为- 一个字节大小，保存的数据为case语句块地址表中的索引编号。</p>
<p>首先将所有case语句块的首地址保存在-一个地址表中，<strong>地址表</strong>中的表项个数会根据程序中case分支来决定。有多少个case分支，地址表就会有多少项。<strong>索引表</strong>，中保存了地址表中的下标值。索引表中最多可以存储256项，每- -项的大小为 1字节，这决定了case值不可以超过1字节的最大表示范围(0~255)， 因此索引表也只能存储256项索引编号。</p>
<p><img src="P4.jpg" alt="索引表结构模拟图"></p>
<p>具体的参考这个<a href="https://www.cnblogs.com/ye-ming/articles/7942472.html" target="_blank" rel="noopener">blog</a>吧，写的很好</p>
<h2 id="do-while-for的比较"><a href="#do-while-for的比较" class="headerlink" title="do/while/for的比较"></a>do/while/for的比较</h2><p>do循环是向上跳转例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DO_BEGIN</span><br><span class="line">······			；循环语句块</span><br><span class="line">cmp xxxx&#x2F;test xxxx&#x2F;sub xxxx&#x2F;·····；影响标记位的指令</span><br><span class="line">jxx DO_BEGIN   	; 向上跳转</span><br></pre></td></tr></table></figure>

<p>while循环是先进行判断，向下跳转，到单次循环结束时，向上跳转，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE_BEGIN:</span><br><span class="line">; 影响标记位的指令</span><br><span class="line">jxx		WHILE_END			; 条件成立跳转到循环语句块结尾处</span><br><span class="line">······						; 循环语句块</span><br><span class="line">jmp		WHILE_BEGIN			; 跳转到取出条件比较数据处</span><br><span class="line">WHILE_END;</span><br></pre></td></tr></table></figure>

<p>for循环由赋初值、设置循环条件、设置循环步长这三条语句组成</p>
<p>for循环比较复杂，看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int LoopFor (int nCount&#125; &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;初始计数器变量、设置循环条件、设置循环步长</span><br><span class="line">	for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount; nIndex++) &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">	&#125;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇煸代码讲解</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">0040B818	mov		dword ptr [ebp-4] ,0</span><br><span class="line">&#x2F;&#x2F; C++源码对比，for语句</span><br><span class="line">for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount;nIndex++)</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 初始化计数器变量--nIndex									1.赋初值部分</span><br><span class="line">0040B81F	mov		dword ptr [ebp-8] ,0</span><br><span class="line">; 跳转到地址0x0040B831处，跳过步长操作</span><br><span class="line">00408826	jmp		LoopFor+31h (0040b831)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 取出计数器变量，用于循环步长								2.步长计算部分</span><br><span class="line">0040B828	mov		eax, dword ptr [ebp-8]</span><br><span class="line">; 对计数器变量执行加1操作，步长值为1							</span><br><span class="line">0040B82B	add		eax,1</span><br><span class="line">;将加1后的步长值放回计数器变量一nIndex</span><br><span class="line">0040B82E	mov		dword ptr [ebp-8] ，eax</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;取出计数器变量nIndex放入ecx									3.条件比较部分</span><br><span class="line">0040B831	mov		ecx, dword ptr [ebp-8]</span><br><span class="line">; ebp+8地址处存放数据为参数nCount, 见C++源码说明</span><br><span class="line">0040B834	cmp		ecx, dword ptr [ebp+8]</span><br><span class="line">; 比较nIndex与nCount, 大于则跳转到地址0x0040B844处，结柬循环</span><br><span class="line">0040B837	jd		LoopFor+44h (0040b844)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; for循环内执行语句块									4.循环体代码</span><br><span class="line">	nSum +&#x3D; nIndex;</span><br><span class="line">	mov		edx, dword ptr [ebp-4]</span><br><span class="line">	0040B83C	add		edx, dword ptr [ebp-8]</span><br><span class="line">	0040B83F	mov		dword ptr [ebp-4] , edx</span><br><span class="line">&#125;</span><br><span class="line">;跳转到地址0x0040B828处，这是一个向上跳</span><br><span class="line">0040B842	jmp		LoopFor+28h (0040b828)</span><br><span class="line">return nSum;</span><br><span class="line">&#x2F;&#x2F;设置返回值eax为ebp-4， 即nSum</span><br><span class="line">0040B844	mov		eax, dword ptr [ebp-4]</span><br></pre></td></tr></table></figure>

<p>以上，可以看到代码分为四个部分，总结一下就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov		mem&#x2F; reg, xxx						;賦初值</span><br><span class="line">jmp		FOR_CMP								;跳到循环条件判定部分</span><br><span class="line">FOR_STEP:									;步长计算部分</span><br><span class="line">;修改循环变量Step</span><br><span class="line">mov		reg,Step</span><br><span class="line">add		reg,xxxx				 ;修改循环变量的计算过程，在实际分析中，视算法不同而不同</span><br><span class="line">mov		Step,eax</span><br><span class="line">FOR_CMP:									;循环条件判定部分</span><br><span class="line">mov		ecx, dword ptr Step</span><br><span class="line">;判定循环变量和循环终止条件StepEnd 的关系，满足条件则逞出for循环</span><br><span class="line">cmp		ecx,StepEnd</span><br><span class="line">jxx		FOR_END								;条件成立则结柬循环</span><br><span class="line">·····</span><br><span class="line">jmp		FOR_STEP							;向上跳转，修改流程回到步长计算部分</span><br><span class="line">FOR_END;</span><br></pre></td></tr></table></figure>

<p>这种结构是for循环独有的，在计数器变量被赋初值后，利用jmp跳过第一次步长计算。然后，可以通过三个跳转指令还原for循环的各个组成部分:第一个jmp指令之前的代码为初始化部分;从第一个jmp指令到循环条件比较处( 也就是上面代码中FOR_ _CMP 标号的位置)之间的代码为步长计算部分;在条件跳转指令jxx之后寻找一个jmp指令，这jmp指令必须是向上跳转的，且其目标是到步长计算的位置，在jxx和这个jmp(也就是上面代码中省略号所在的位置)之间的代码即为循环语句块。</p>
<h2 id="编译器对循环结构的优化"><a href="#编译器对循环结构的优化" class="headerlink" title="编译器对循环结构的优化"></a>编译器对循环结构的优化</h2><p>while和for循环在O2优化中，都会被优化成do的形式，而结构被优化后，细节上还能被再次优化</p>
<ol>
<li><p>代码外提</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	int nIndex &#x3D; 0;</span><br><span class="line">	do &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">		nIndex++ ;</span><br><span class="line">		&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">		&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">	&#125; while (nIndex &lt; nCount - 1) ;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;经过优化后的反汇编代码</span><br><span class="line">. text : 00401000 sub_ 401000	proc near; CODE XREF:_ main+21↑p</span><br><span class="line">. text :00401000 arg_ 0		&#x3D; dword ptr 4</span><br><span class="line">;荻取参数到edx中</span><br><span class="line">. text : 00401000	mov		edx，[esp+arg_0]</span><br><span class="line">. text : 00401004	xor		eax,eax</span><br><span class="line">. text : 00401006	xor		ecx,ecx</span><br><span class="line">;代码外提，对edx执行自减1操作</span><br><span class="line">. text : 00401008	dec		edx</span><br><span class="line">;进入循环体，在循环体内直接对保存参数的edx进行比较，没有任何减1操作</span><br><span class="line">. text : 00401009 loc 401009:	: CODE XREF: sub_ 401000+E↑j</span><br><span class="line">. text : 00401009	add		eax, ecx </span><br><span class="line">. text : 0040100B	inc		ecx</span><br><span class="line">. text : 0040100C 	cmp		ecx,edx</span><br><span class="line">. text : 0040100E   jl		short loc_401009</span><br><span class="line">. text : 00401010	retn</span><br><span class="line">. text : 00401010 sub_401000	endp</span><br><span class="line"></span><br><span class="line">也就是被优化成了</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">	int nSum &#x3D; 0;</span><br><span class="line">	int nIndex &#x3D; 0;</span><br><span class="line">	nCount -&#x3D; 1;</span><br><span class="line">	do &#123;</span><br><span class="line">		nSum +&#x3D; nIndex;</span><br><span class="line">		nIndex++ ;</span><br><span class="line">		&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">		&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">	&#125; while (nIndex &lt; nCount) ;</span><br><span class="line">	return nSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.强度削弱</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:强度削弱</span><br><span class="line">int main(int argc) &#123;</span><br><span class="line">	int t&#x3D;0;</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	while (t &lt; argc) &#123;</span><br><span class="line">		t &#x3D; i * 99; &#x2F;&#x2F;强度削弱后，这里将不会使用乘法运算</span><br><span class="line">		i++;		&#x2F;&#x2F;此处转换后将为  t &#x3D; i; i +&#x3D; 99</span><br><span class="line">	&#125;				&#x2F;&#x2F;利用加法运算替换掉了指令周期长的乘法运算</span><br><span class="line">	printf(&quot;%d&quot;,t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;优化后的反汇编代码</span><br><span class="line">. text : 00401020 arg_0		&#x3D; dword ptr 4</span><br><span class="line">;将参数信息保存到edx中</span><br><span class="line">. text : 00401020	mov		edx, [esp+arg_0]</span><br><span class="line">. text : 00401024	xor		eax,eax				; 清空eax</span><br><span class="line">. text : 00401026	test	edx,edx</span><br><span class="line">. text : 00401028	jle		short loc_401035</span><br><span class="line">. text : 0040102A	xor		ecx,ecx				; 清空ecx</span><br><span class="line">. text : 0040102C	</span><br><span class="line">;循环语句玦首地址</span><br><span class="line">. text : 0040102C loc_ 40102C:		; CODE XREF: sub_ 401020+13↑j</span><br><span class="line">. text : 0040102C	mov		eax,ecx				; 将ecx传入eax中</span><br><span class="line">;ecx自加63h，即十进制99，等价于ecx每次加1乘以99.</span><br><span class="line">. text : 0040102E	add		ecx,63h</span><br><span class="line">. text : 00401031	cmp		eax,edx</span><br><span class="line">. text : 00401033	jl		short loc_40102C	; eax小于edx则执行跳转</span><br><span class="line">. text : 00401035</span><br><span class="line">. text : 00401035 loc_401035:	; CODE XREF: sub_ 401020+8↑j</span><br><span class="line">;printf函数调用处略</span><br><span class="line">. text : 00401043	retn</span><br><span class="line">. text :00401043 sub_401020		endp</span><br></pre></td></tr></table></figure>

<h1 id="函数工作原理"><a href="#函数工作原理" class="headerlink" title="函数工作原理"></a>函数工作原理</h1><h2 id="栈帧的形成和关闭"><a href="#栈帧的形成和关闭" class="headerlink" title="栈帧的形成和关闭"></a>栈帧的形成和关闭</h2><p>当栈顶指针esp小于栈底指针ebp时，就形成了栈帧</p>
<p><strong>栈平衡</strong>：</p>
<p>​    不同的两次函数调用，所形成的栈帧也不相同。当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的栈帧。当这个函数结束调用时，需要清除掉它所使用的栈空间，关闭栈帧，我们把这一过程称为栈平衡。</p>
<p>给一个小demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:一个空函数</span><br><span class="line">int main() &#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应的汇编代码讲解</span><br><span class="line">int main()&#123;</span><br><span class="line">; 以下是进入函数时的代码</span><br><span class="line">00401010	push	ebp			;进入函数后的第一件事，保存栈底指针ebp</span><br><span class="line">00401011	mov		ebp,esp		;调整当前栈底指针位置到栈顶</span><br><span class="line">00401013	sub		esp,40h 	;抬高栈顶esp,此时开辟栈空间0x40，作为局部变量的存储空间	</span><br><span class="line">00401016	push	ebx			;保存寄存器ebx</span><br><span class="line">00401017	push	esi			;保存寄存器esi</span><br><span class="line">00401018	push	edi			;保存寄存器edi</span><br><span class="line">00401019	lea		edi, [ebp-40h] ;取出此函数可用栈空间首地址</span><br><span class="line">0040101C	mov		ecx,10h ;设置ecx为0x10</span><br><span class="line">00401021	mov		eax, 0CCCCCCCCh ;将局部变量初始化为0CCCCCCCCh</span><br><span class="line"></span><br><span class="line">;根据ecx的值，将eax中的内容，以4字节为单位写到edi指向的内存中</span><br><span class="line">00401026	rep stos dword ptr [edi]</span><br><span class="line"></span><br><span class="line">;以下是用户编写的函数实现代码</span><br><span class="line">	return 0;</span><br><span class="line">0040102A	xor		eax,eax		;设置返回值为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;以下是函数退出时的代码</span><br><span class="line">0040102C	pop		edi 		;还原寄存器edi</span><br><span class="line">0040102D	pop		esi			;还原寄存器esi</span><br><span class="line">0040102E	pop		ebx 		;还原寄存器ebx</span><br><span class="line">0040102F	add		esp,40h 	;降低栈顶esp,此时局部变量空间被释放</span><br><span class="line">00401032	cmp		ebp,esp 	;检测栈平衡，如ebp与esp不等，则不平衡</span><br><span class="line">00401034	call	_chkesp (00401050)	;进入栈平衡错误裣测函数</span><br><span class="line">00401039	mov		esp,ebp 	;还原esp</span><br><span class="line">0040103B	pop		ebp	</span><br><span class="line">0040103C	ret</span><br></pre></td></tr></table></figure>

<h2 id="各种调用方式"><a href="#各种调用方式" class="headerlink" title="各种调用方式"></a>各种调用方式</h2><p>由于函数自身无法对不定参数执行平衡操作，所以有了函数的调用约定：</p>
<ul>
<li>_cdecl : CIC++默认的调用方式，调用方平衡栈，不定参数的函数可以使用。</li>
<li>_stdcall : 被调方平衡栈，不定参数的函数无法使用。</li>
<li>_fastcall : 寄存器方式传参，被调方平衡栈，不定参数的函数无法使用。</li>
</ul>
<p>_cdecl  与 _stdcall 的对比，debug版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_cdecl、_stdcall 两种调用方式的区别</span><br><span class="line">void _stdcall Showstd (int nNumber)&#123;	&#x2F;&#x2F; 使用_stdca1l 调用方式，被调方平衡栈</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">void _cdecl ShowCde (int nNumber)&#123;		&#x2F;&#x2F; 使用_ _cdecl 调用方式，调用方平衡栈</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">	ShowStd(5);				&#x2F;&#x2F;不会有平衡栈操作</span><br><span class="line">	ShowCde(5);				&#x2F;&#x2F;函数调用结柬后，对esp平衡4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++源码对比，_stdcall调用方式</span><br><span class="line">void _stdcall ShowStd (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">00401059	ret		4 			;结柬后平衡栈顶4，等价esp +&#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，_cdecl 调用方式</span><br><span class="line">void _cdec1 ShowCde (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">	printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">004010A9	ret					;没有平衡操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用 _stdcall方式调用函数Showstd</span><br><span class="line">ShowStd(5) ;</span><br><span class="line">0040B7C8	push	5 			;函数传参，使用push指令esp-4</span><br><span class="line">0040B7CA	call	@ILT+10 (show) (0040100f) 	;没有对esp操作的指令</span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用_cdecl方式调用函数ShowCde</span><br><span class="line">ShowCde(5) ;</span><br><span class="line">0040B7CF	push	5 			;函数传参，使用push指令esp-4</span><br><span class="line">0040B7D1	call	@ILT+15 (ShowCde) (00401014) </span><br><span class="line">0040B7D6	add		esp,4		;esp +&#x3D; 4,平衡栈顶</span><br></pre></td></tr></table></figure>

<p>虽然区别明显，但是不能当作区分依据，因为汇编语言可能会在其他地方平衡栈~</p>
<p><strong>在O2优化下，_cdecl会采取复写传播优化，将每次参数平衡的操作进行归并，一次性平衡栈顶指针esp。</strong></p>
<p>_cdecl  调用方式的函数在同一作用域内多次使用， 会在效率上比  _stdcal l 高一点，这是因为  __cdecl 可以使用复写传播，而 _ stdcall 都在函数内平衡参数，无法使用复写传播这种优化方式。在这三种调用方式中， _ fastcall 调用方式的效率最高，其他两种调用方式都是通过栈传递参数，唯独 _ fastcall 可以利用寄存器传递参数。但由于寄存器数目很少，而参数相比可以很多，只能量力而行，故 _fastcall 调用方式只使用了ecx和edx,分别传递第-一个参数和第二个参数，其余参数传递则转换成栈传参方式。</p>
<p>来份_fastcall代码康康~：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_fastcall调用方式</span><br><span class="line">vold _fastcall ShowFast (int nOne，int nTwo，int nThree, int nFour) &#123;</span><br><span class="line">	printf(&quot;%d%d%d%d \r\n&quot;, nOne, nTwo， nThree, nFour) ;	</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">	ShowFast(1,2,3,4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++ 源码对比， 函数调用</span><br><span class="line">ShowFast (1，2，3，4) ;</span><br><span class="line">004012A8	push	4					;使用栈方式传递参数</span><br><span class="line">004012AA 	push	3					;使用栈方式传递参数</span><br><span class="line">004012AC	mov		edx,2				;使用edx传递第二个参数2</span><br><span class="line">004012B1	mov		ecx,1				;使用ecx传递第一个参数1</span><br><span class="line">004012B6	call	@ILT+15 (ShowFast) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，函数说明</span><br><span class="line">void fastcall ShowFast(int nOne，int nTwo, int nThree, int nFour) &#123;</span><br><span class="line">004010F0	push	ebp</span><br><span class="line">004010F1	mov		ebp,esp</span><br><span class="line">004010F3	sub		esp,48h</span><br><span class="line">004010F6	push	ebx</span><br><span class="line">004010F7	push	esi</span><br><span class="line">004010F8	push	edi</span><br><span class="line">;由于ecx即将被赋值作为循环计数器使用，在此将ecx原值保存</span><br><span class="line">004010F9	push	ecx</span><br><span class="line">004010FA	lea		edi,[ebp-48h]</span><br><span class="line">004010FD	mov		ecx,12h</span><br><span class="line">00401102	mov		eax, 0CCCCCCCCh</span><br><span class="line">00401107	rep stos dword ptr [edi]</span><br><span class="line">00401109	pop		ecx					;还原ecx</span><br><span class="line">;使用临时变量保存edx (参数2)</span><br><span class="line">0040110A	mov		dword ptr [ebp-8] , edx</span><br><span class="line">;使用临时变量保存ecx (参数1)</span><br><span class="line">0040110D	mov		dword ptr [ebp-4] , ecx</span><br><span class="line">&#x2F;&#x2F; C++源码对比，printf 函数调用</span><br><span class="line">printf(&quot; %d%d%d%d \r\n&quot;, nOne，nTwo, nThree, nFour) ;</span><br><span class="line">;使用ebp相对寻址取得参数4</span><br><span class="line">00401110	mov		eax, dword ptr [ebp+0Ch]</span><br><span class="line">00401113	push	eax					;将eax压栈，作为参数</span><br><span class="line">;使用ebp相对寻址取得参数3</span><br><span class="line">00401114	mov		ecx, dword ptr [ebp+8]</span><br><span class="line">00401117	push	ecx					;将ecx压栈， 作为参数</span><br><span class="line">;在ebp-8中保存edx，即参数2</span><br><span class="line">00401118	mov		edx,dword ptr [ebp-8]</span><br><span class="line">0040111B	push	edx					;将edx压栈， 作为参数</span><br><span class="line">;在ebp-4中保存ecx，即参数1</span><br><span class="line">0040111C	mov		eax, dword ptr [ebp-4]</span><br><span class="line">0040111F	push	eax					;将eax压栈， 作为参数</span><br><span class="line">00401120	push	offset string &quot;%d %d %d %d \r\n&quot; (00422024)</span><br><span class="line">00401125	call	printf(004012e0)</span><br><span class="line">0040112A	add 	esp,14h				;平衡pirntf 使用的5个参数</span><br><span class="line">&#125;</span><br><span class="line">0040113D	ret		8					;此函数有4个参数，ret指令对其平衡</span><br></pre></td></tr></table></figure>

<h2 id="使用ebp或esp寻址"><a href="#使用ebp或esp寻址" class="headerlink" title="使用ebp或esp寻址"></a>使用ebp或esp寻址</h2><p>由于局部变量使用栈空间进行存储，因此进入函数后的第一件事就是开辟函数中局部变量所需的栈空间大小，变量随着进入函数体开始生命，函数执行的时候结束</p>
<p>在大多数情况下，使用ebp寻址局部变量只能在非O2选项中产生，这样做是为了方便调试和检测栈平衡，使目标代码可读性更高。而在O2编译选项中，只要栈顶是稳定的，就可以不再使用ebp, 利用esp直接访问局部变量，可以节省一个寄存器资源。来个小demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:通过esp访问局部变量</span><br><span class="line">void InNumber() &#123;</span><br><span class="line">	int nInt &#x3D; 1;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;nInt);</span><br><span class="line">	char cChar &#x3D; 2;</span><br><span class="line">	scanf(&quot;%c&quot;, &amp;cChar);</span><br><span class="line">	printf(&quot;%d %c\r\n&quot;,nInt,cChar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数在main函数中被调用</span><br><span class="line">void main()&#123;</span><br><span class="line">	InNumber();</span><br><span class="line">&#125;</span><br><span class="line">;在Release版下，反汇蝙代码信息</span><br><span class="line">;函数定义，由于在main函数中只有一句函数调用代码，因此IDA为其取名 _main_0， 而不是使用地址做标号</span><br><span class="line">_main_0 proc near</span><br><span class="line">var_5 &#x3D; byte ptr -5					; IDA定义的局部变量标号，IDA环境下局部变量用var_ 开头</span><br><span class="line">var_4 &#x3D; dword ptr -4				; IDA定义的局部变量标号</span><br><span class="line">;为局部变量开辟8字节栈空间，这里在没有了那些繁琐的操作</span><br><span class="line">sub		esp,8</span><br><span class="line">;这句指令等价于; esp+8-4,标号var_4等于-4， IDA自动识别出访问的变量地址，并调整显示方式，省去了计算偏移量这个过程，类似于高级语言中为变量命名，使代码显示起来更具可读性</span><br><span class="line">lea		eax,[esp+8+var_4]</span><br><span class="line">mov		[esp+8+var_4], 1 			; 初始化var_ 4变量为1</span><br><span class="line">push	eax							; eax中保存[esp+8-4]的值，将eax作为参数入栈</span><br><span class="line">push	offset aD 					; &quot;%d&quot;</span><br><span class="line">call	_scanf</span><br><span class="line"></span><br><span class="line">;在分析指令的时候，IDA会根据代码上下文归纳出影响栈顶的指令，以确定esp相对寻址所访问的目标。</span><br><span class="line">;于是IDA识别出以下相对寻址指令的目标是该函数中的局部变量var_5， 之前执行了两次push指令，</span><br><span class="line">;所以esp指向的栈顶地址存在-8的差值，而且本函数第一条指令sub esp，8也影响栈顶。综合以</span><br><span class="line">;上信息，IDA为了表达出此时访问的局部变量为var_5， 并且将var_5定义为-5， 需要对esp相对寻址进行调整，先求解[esp+X+var_5]中的X，此处求解的X值为10h, 然后就可以表达为; [esp+10h+var_ 5]， 以加强代码的可读性。</span><br><span class="line">lea		ecx，[esp+10h+var_5]</span><br><span class="line">mov		[esp+10h+var_5] ,2			; 为var_5处的局部变量赋值2</span><br><span class="line">push	ecx							; esp -&#x3D; 4</span><br><span class="line">push	offset aC					; &quot;%c&quot;,esp -&#x3D; 4</span><br><span class="line">call	_scanf</span><br><span class="line">;由于又执行了两次push指令，并且没有平衡钱，所以需要再次调整esp的相对偏移值，这里的调整值为18h。注意，在这里的movsx指令处点一下Q键，可以得到movsx edx， byte ptr [esp+13h]， 按K键可还原,名称。这里的movsx指令显示var_5 的类型为有符号类型，byte ptr 说明长度为单字节，对应C语言中的定义应该是char.当然读者也可以考察使用变量作参数的函数，如果函数功能是已知的，那么参数类型也就已知了，进而推导出变量的类型。</span><br><span class="line">movsx	edx, [esp+18h+var_5]</span><br><span class="line">mov		eax, [esp+18h+var_4]</span><br><span class="line">push	edx</span><br><span class="line">push	eax</span><br><span class="line">push	offset Format	</span><br><span class="line">call	_printf</span><br><span class="line"></span><br><span class="line">;经过优化后的代码，一次性平衡了栈顶esp.在此函数中，共执行了7次push操作，而函数scanf和printf函数使用相同的调用方式，即_ cdecl 调用方式，因此函数内没有平衡钱，需要调用者来平衡栈顶指针esp，又因为在退出函数前，还需释放局部变量的日个字节(见函数入口指令)空间，所以esp需要加(7*4+8&#x3D;)36转换成十六进制后为24h</span><br><span class="line">add		esp,24h</span><br><span class="line">retn</span><br><span class="line">_main_0  endp</span><br></pre></td></tr></table></figure>

<p>每次访问变量都需要计算，如果在函数执行过程中esp发生了改变，再次访问变量就需要重新计算偏移。为了省去对偏移量的计算，方便分析，IDA在分析过程中事先将函数中的每个变量的偏移值计算出来，得出了一个固定偏移值，使用标号记录。这里有两个方案，正数标号法和负数标号法</p>
<ul>
<li><p>正数标号法：以调整后的esp作为基址来计算局部变量的偏移值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var_0 &#x3D; 4 	;定义第一个变量偏移量，所在地址为0x0012FFEC</span><br><span class="line">var_1 &#x3D; 0  	;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp, 8 	;申请变量栈空间，esp保存地址变为0x0012FFE8</span><br><span class="line">lea eax, [esp+var_0]	;寻址第一个变量地址为0x0012FFE8+4 &#x3D; 0x0012FFEC</span><br><span class="line">push eax	;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">lea eax [esp+4+var_1]	;由于esp被减4，需要对基址esp进行加4,调整后再加上标号</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数标号法：以调整前的esp作为基址来计算局部变量的偏移值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var_0 &#x3D; -4		;定义第一个变量偏移量，所在地址为0X0012FFEC</span><br><span class="line">var_1 &#x3D; -8		;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp,8 		;申请变量栈空间，esp 保存地址变为0x0012FFE8</span><br><span class="line">;使用申请变量栈空间前的esp作为基扯，就需要调整esp,将其加8</span><br><span class="line">lea eax, [esp+8+var_0]</span><br><span class="line">push eax		;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">;由于esp被减4，需要对基址esp进行二次调整，加8后再加4，因此得到数值0x0C</span><br><span class="line">lea eax [esp+0Ch+var_1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>显然ida选择了后者，下一节分析</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>参数也是函数中的一个变量，采用正数标号法来表示局部变量偏移标号时，函数的参数标号和局部变量的标号值都是正数，无法区分，不利于分析。如果使用负数标号法表示，则可以将两者区分，正数表示参数，而负数则表示局部变量，0值表示返回地址。</p>
<p>不放代码了，挺简单的</p>
<p>C\C++将不定长参数的函数定义为：</p>
<ul>
<li>至少要有一个参数</li>
<li>所有不定长的参数类型传入时都是dword类型</li>
<li>需在某一个参数中描述参数总个数或将最后一个参数赋值为结尾标记</li>
</ul>
<p>根据参数的传递特性，只要确定第一个参数的地址，对其地址值做加法，就可访问到此参数的下一个参数所在的地址。获取参数的类型是为了解释地址中的数据。.上面提到的第三点是为 了获取参数的个数，其目的是正确访问到最后一个参数的地址，以防止访问参数空间越界。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>call指令被执行后，该指令同时还会做另一件事：<strong>将下一条指令所在的地址压入栈中</strong></p>
<p>ret指令读取栈中地址传送给EIP寄存器，使程序回到call的下一条指令</p>
<p>函数的返回值是由EAX寄存器来保存，但是只能保存<strong>四字节</strong>数据，大于四字节的需要使用其他方法保存，来个demo代码(DEBUG版)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明</span><br><span class="line">&#x2F;&#x2F; 函数功能:获取当前函数的返回地址</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">	&#x2F;&#x2F;获取参数地址，减1后得到返回地址在栈中的地址</span><br><span class="line">	int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">	return nAddr;			&#x2F;&#x2F;将返回地址作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">; Debug保护环境初始化部分略</span><br><span class="line">int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">; ebp加法与esp加法原理相同，都是取参数，但是这里为什么是加8呢?</span><br><span class="line">;在Debug版下进入函数后，首先保存ebp会执行push ebp的操作，这样esp将执行压栈减4操作,随后执行mov ebp， esp的操作，由于栈顶esp之前被修改，所以ebp需要加4调整到最初的栈底位置,因此ebp+4 可以得到返回地址，ebp+8将会寻址第一个参数</span><br><span class="line">;以下代码将第一个参数的地址传入eax中</span><br><span class="line">0040DB78	lea		eax,[ebp+8]</span><br><span class="line">;执行eax自减4操作，执行后eax等价于ebp+4, 得到函数返回地址所在栈中的地址</span><br><span class="line">0040DB7B	sub		eax,4</span><br><span class="line">;取出函数返回地址传入ecx中</span><br><span class="line">0040DB7E	mov		ecx, dword ptr [eax]</span><br><span class="line">;使用ecx赋值局部变量</span><br><span class="line">0040DB80	mov		dword ptr [ebp-4] , ecx</span><br><span class="line">return nAddr;</span><br><span class="line">;取出局部变量数据传入eax中，用做函数返回值</span><br><span class="line">0040DB83	mov		eax, dword ptr [ebp-4]</span><br><span class="line">&#125;</span><br><span class="line">; Debug恢复环境，平衡栈、栈平衡检测部分略</span><br><span class="line">0040DB8C	ret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">int nAddr &#x3D; Getaddr (1) ;</span><br><span class="line">0040DAF8 	push	1			;压栈传参，传入参数1</span><br><span class="line">0040DAFA	call	@ILT+30(ss) (00401023)	;函数调用</span><br><span class="line">0040DAFF	add		esp,4		;_cdec1调用方式，平衡栈</span><br><span class="line">0040DB02	mov		dword ptr [ebp-4] , eax		;取得返回值</span><br></pre></td></tr></table></figure>

<p>再来个结构体的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明:结构体类型作为返回值</span><br><span class="line">struct tagTEST &#123;				&#x2F;&#x2F;结构体定义</span><br><span class="line">	int m_nOne;</span><br><span class="line">	int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回值为结构体类型的函数</span><br><span class="line">tagTEST RetStruct () &#123;</span><br><span class="line">	tagTEST testRet ; </span><br><span class="line">	testRet.m_nOne &#x3D; 1;</span><br><span class="line">	testRet.m_nTwo &#x3D; 2;</span><br><span class="line">	return testRet ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用函数，并将返回值赋值到结构体实例test中</span><br><span class="line">void main()&#123;</span><br><span class="line">	tagTEST test;</span><br><span class="line">	test &#x3D; RetStruct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇蝙代码讲解</span><br><span class="line">tagTEST RetStruct() &#123;</span><br><span class="line">; Debug保存环境、初始化部分略</span><br><span class="line">tagTEST testRet;</span><br><span class="line">testRet.m_nOne &#x3D; 1;</span><br><span class="line">004012A8	mov		dword ptr [ebp-8] ,1		;对结构体成员变量赋值</span><br><span class="line">testRet.m_nTwo &#x3D; 2;</span><br><span class="line">004012AF	mov		dword ptr [ebp-4] ,2		;对结构体成员变量赋值</span><br><span class="line">return testRet ;</span><br><span class="line">004012B6	mov		eax, dword ptr [ebp-8]		;取结构体成员变量数据传入eax中</span><br><span class="line">004012B9	mov		eax, dword ptr [ebp-4]		;取结构体成员变量数据传入eax中</span><br><span class="line">&#125;</span><br><span class="line">;Debug恢复环境略</span><br><span class="line">004012C2	ret		;执行ret指令结束函数调用</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">tagTEST test; </span><br><span class="line">test &#x3D; RetStruct () ;</span><br><span class="line">0040DC38	call	@ILT+35 (RetStruct) (00401028)	;调用函数RetStruct</span><br><span class="line">; eax中保存函数Retstruct中结构体testRet成员m_nOne的数据</span><br><span class="line">0040DC3D	mov		dword ptr [ebp-10h] ,eax 		; ebp-10h 为临时变量</span><br><span class="line">; edx中保存函数Retstruct中结构体testRet成员m_nTwo的数据</span><br><span class="line">0040DC3D	mov		dword ptr [ebp-0ch] ,edx 		; ebp-0ch 为临时变量</span><br><span class="line"></span><br><span class="line">;经过几次数据传递，最终将返回结果存入结构体实例test的两个成员所在地址处</span><br><span class="line">0040DC43	mov		eax, dword ptr [ebp-10h]</span><br><span class="line">0040DC46	mov		dword ptr [ebp-8] ,eax</span><br><span class="line">0040DC49	mov		ecx, dword ptr [ebp-0Ch]</span><br><span class="line">0040DC4C	mov		dword ptr [ebp-4] ，ecx</span><br></pre></td></tr></table></figure>

<p>结构体只有两个成员，所以用了eax和edx来传递返回值</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%94/" rel="next" title="C++反汇编与逆向分析技术(五)">
                <i class="fa fa-chevron-left"></i> C++反汇编与逆向分析技术(五)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/02/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/" rel="prev" title="Diary">
                Diary <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/07/13/C-反汇编与逆向分析技术-三/"
           data-title="C++反汇编与逆向分析技术(三)" data-url="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kittener</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kittener" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="mail">
                      
                        <i class="fa fa-fw fa-globe"></i>mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/kittener" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkittener@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#流程控制语句的识别"><span class="nav-number">1.</span> <span class="nav-text">流程控制语句的识别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if语句"><span class="nav-number">1.1.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if···else···语句"><span class="nav-number">1.2.</span> <span class="nav-text">if···else···语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用if构成的多分支流程"><span class="nav-number">1.3.</span> <span class="nav-text">用if构成的多分支流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch的真相"><span class="nav-number">1.4.</span> <span class="nav-text">switch的真相</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#难以构成跳转表的switch"><span class="nav-number">1.5.</span> <span class="nav-text">难以构成跳转表的switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-while-for的比较"><span class="nav-number">1.6.</span> <span class="nav-text">do&#x2F;while&#x2F;for的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器对循环结构的优化"><span class="nav-number">1.7.</span> <span class="nav-text">编译器对循环结构的优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数工作原理"><span class="nav-number">2.</span> <span class="nav-text">函数工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈帧的形成和关闭"><span class="nav-number">2.1.</span> <span class="nav-text">栈帧的形成和关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各种调用方式"><span class="nav-number">2.2.</span> <span class="nav-text">各种调用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用ebp或esp寻址"><span class="nav-number">2.3.</span> <span class="nav-text">使用ebp或esp寻址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的参数"><span class="nav-number">2.4.</span> <span class="nav-text">函数的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的返回值"><span class="nav-number">2.5.</span> <span class="nav-text">函数的返回值</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kittener</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FSYBzoLmcoINlfmLJmsXaDA8-gzGzoHsz',
        appKey: 'aYNlN8CfvruV4yvdvxARsbD5',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  
 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
 <script type="text/javascript" src="/js/src/fireworks.js"></script>
 </pre>
</body>
</html>
