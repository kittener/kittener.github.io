<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kittener&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kittener.top/"/>
  <updated>2020-07-01T15:04:11.652Z</updated>
  <id>http://www.kittener.top/</id>
  
  <author>
    <name>Kittener</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++反汇编与逆向分析技术(二)</title>
    <link href="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/"/>
    <id>http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/</id>
    <published>2020-06-19T15:40:25.000Z</published>
    <updated>2020-07-01T15:04:11.652Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(二)</p><a id="more"></a>  <h1 id="第四章-各种表达式的求值过程"><a href="#第四章-各种表达式的求值过程" class="headerlink" title="第四章 各种表达式的求值过程"></a>第四章 各种表达式的求值过程</h1><p>单独的算术运算虽然可以编译通过，但是并不会生成代码。因为只进行计算而没有传递结果的运算不会对程序结果有任何影响，此时编译器将其视为无效语句，与空语句等价，不会有任何编译处理  </p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>VC++ 6.0有两种常用的优化方案  </p><ul><li>O1方案，生成文件占用空间最小</li><li>O2方案，执行效率最快</li></ul><p>在VC++ 6.0中，Release编译选项组的默认选项为<em>O2选项</em>，在Debug编译选项组中，使用的是<em>Od+ZI选项</em>，此选项使编译器产生的一切代码都以便于调试为最根本的前提，甚至为了便于单步调试，以及源码和目标代码块的对应阅读  </p><pre><code>//C++源码说明：加法运算//无效语句，不参与编译15+20//变量定义int nVarOne = 0;int nVarTwo = 0;//变量加常量的加法运算nVarOne = nVarOne + 1;//两个常量加法的加法运算nVarOne = 1 + 2;//两个变量相加的加法运算nVarOne = nVarOne + nVarTwoprintf(&quot;nVarOne = %d \r\n&quot;, nVarOne);//C++源码与对应汇编代码//C++源码对比，变量赋值int nVarOne = 0;//将立即数0，传入地址ebp-0x4中，即变量nVarOne所在的地址00401028 mov dword ptr [ebp-4],0//C++源码对比，变量赋值int nVarTwo = 0;0040102F mov dword ptr [ebp-8],0//C++源码对比，变量 + 常量nVarOne = nVarOne + 1;//取出变量nVarOne数据放入eax中00401036 mov eax,dword ptr [ebp-4]//对eax执行加等于1运算00401039 add eax,1//将结果返回变量nVarOne中，完成加法运算0040103C mov dword ptr [ebp-4],eax//C++源码对比，常量 + 常量nVarOne = 1 + 2;//这里编译器直接计算出了两个常量相加后的结构，放入变量nVarOne中0040103F mov dword ptr [ebp-4],3//C++源码对比，变量 + 变量nVarOne = nVarOne + nVarTwo;//使用ecx存放变量nVarOne00401046 mov ecx,dword ptr [ebp-4]//使用ecx对变量nVarTwo执行加等于操作00401049 add ecx,dword ptr [ebp-8]//将结果存入地址ebp-4处，即变量nVarOne0040104C mov dword ptr [ebp-4],ecx</code></pre><p>由上方代码可得：  </p><ul><li>在两常量相加的情况下，编译器在编译期间就计算出两常量相加后的结果，将这个结果值作为立即数参与运算，减少了程序在运行期的计算</li><li>当有变量参与加法运算时，会先取出内存中的数据，放入通用寄存器中，再通过加法指令来完成计算过程得到结果，最后存回到变量所占用的内存空间中</li></ul><p>在开启O2选项后，编译出来的汇编代码会由于效率优先的编译选项而发生很大变化，编译器会将无用代码去除，并将可合并代码进行归并处理。例如，在代码清单4-1中，“nVarOne =<br>nVarOne+1;”这样的代码将被删除，因为在其后又重新对变量nVarOne进行了赋值操作，而在此之前没有对变量nVarOne的任何访问，所以编译器判定此句代码是可被删除的  </p><p>O2选项后Release版代码如下：</p><pre><code>; int _cdecl main(int argc, const char **argu, const char **enup)__main proc nearpush    3push    offset format   ;&quot;nVarOne = %d \r\n&quot;call    __printfadd     esp,8xor     eax,eaxretn__main endp</code></pre><ul><li>常量传播</li></ul><pre><code>void main(){    int nVar = 1;    printf(&quot;nVarOne = %d  \r\n&quot;, nVar);}</code></pre><p>变量nVar是一个在编译期间可以计算出结果的变量。因此，在程序中所有引用到nVar的地方都会直接使用常量1来代替，于是代码等价于:   </p><pre><code>void main(){    printf {&quot;nVarOne = %d \r\n&quot;，1) ;}</code></pre><ul><li>常量折叠  </li></ul><p>当计算公式中出现多个常量进行计算的情况时，且编译器可以在编译期间计算出结果时，这样源码中所有的常量计算都将被计算结果代替，如下面的代码所示:   </p><pre><code>void main(){    int nVar = 1 + 5 - 3 * 6;    printf(&quot;nVarOne = %d \r\n&quot;,nVar);}</code></pre><p>在这串算式被编译后会直接转化成常量-12，即”int nVar = -12;”  </p><p>在给出的加法代码中，变量nVarOne和nVarTwo的初始化值是-一个常量， VC++编译器在开启02优化方案后，会尝试使用常量替换掉变量。如果在程序的逻辑中，声明的变量没有被修改过，而且上下文中不存在针对此变量的取地址和间接访问操作，那么这个变量也就等价于常量，编译器就认为可以删除掉这个变量，直接用常量代替。使用常量的好处是可以生成立即数寻址的目标代码，常量作为立即数成为指令的一-部分，从而减少了内存的访问次数  </p><pre><code>int nVarOne = 0;    //常量化以后: int nVarOne = 0; nVarOne 用0代替了int nVarTwo = 0;    // int nVarTwo = 0; 同上，这句也没有了//变量加常量的加法运算nVarOne = nVarOne + 1;      //nVarOne=0+1;//两常量相加的加法运算nVarOne = 1 + 2;    //nVarOne=1+2;nVarOne = nVarOne + nVarTwO;    // nVarOne = nVarOne + 0;printf (&quot;nVarOne = %d \r\n&quot;, nVarOne);</code></pre><p>经过转化后，直接变成”printf(“nVarOne = %d \r\n”);”<br>将代码修改为：  </p><pre><code>int main(int argc, char* argv[]) {    int nVarOne = argc;      //修改处    int nVarTwo = argc;      //修改处    nVarOne = nVarOne + 1 ;    nVarOne = 1 + 2;    nVarOne = nVarOne + nVarTwo;    printf {&quot;nVarOne = %d \r\n&quot;， nVarOne) ;    return 0;}</code></pre><p>这里初始化nVarOne和nVarTwo的时候用命令行参数argc，故在编译期间无法确定，程序中的变量就不会被常量替换掉，汇编代码为  </p><pre><code>; int_ cdec1 main(int argc, const char **argu, const char **envp)__main proc near  arg_0 = dword ptr 4mov  eax, [esp+arg_0]add  eax, 3  push  eax  push  offset Format     ; &quot;nVarOne = 0 \r\n&quot;call  printfadd  esp,8xor  eax, eaxretn__main endp</code></pre><p>这里还是被删除了一个变量，优化过程如下：  </p><pre><code>int main(int argc, char* argv[]) {    // int nVarOne = argc;在后面的代码中被常量代替    // int nVarTwo = argc;虽然不能用常量代替，但是由于之后没有对nVarTwo进行修改，所以引用nVarTwo等价于引用argc, nVarTwo 则被删除掉，这种方法称为”复写传播”    // nVarOne = nVarOne + 1;其后即刻重新对nVarOne赋值，这句被删除了    // nVarOne = 1+2;常量折叠，等价于nVarOne=3;    // nVarOne = nVarOne + nVarTwo; 常量传播和复写传播，等价于nVarOne = 3 + argc ;    // printf (&quot;nVarOne = %d \r\n&quot;, nVarOne) ;    //其后nVar0ne没有被访问，可以用3 + argc代替    printf (&quot;nVarOne = %d \r\n&quot;, 3 + argc) ;    return 0;}</code></pre><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法运算对应于汇编指令sub，计算机是通过补码将减法转变为加法形式来完成转换，有公式  </p><p>设有二进制数Y，其反码记为Y(反)，假定其二进制长度为8位，有:  </p><ul><li>Y + Y(反) = 1111 1111B  </li><li>Y + Y(反) + 1 = 0(进位丢失)  </li></ul><p>根据以上两点，可推出  </p><ul><li>Y(反) + 1 = 0 - Y&lt;==&gt;Y(反) + 1 = -Y &lt;==&gt; Y(补} = -Y  </li></ul><pre><code>//C++源码说明：减法运算//变量定义int nVarOne = argc;int nVarTwo = 0;//获取变量nVarTwo的数据，使用scanf防止被常量化scanf(&quot;%d&quot;,&amp;nVarTwo);//变量减常量的减法运算nVarOne = nVarOne - 100;//减法与加法混合运算nVarOne = nVarOne + 5 - nVarTwo;printf(&quot;nVarOne = %d \r\n&quot;,nVarOne);//C++源码对应汇编代码讲解//C++源码对比，变量 - 常量nVarOne = nVarOne - 100;//取变量nVarOne的数据到eax中00401125    mov    eax,dword ptr [ebp-4]//是用减法指令sub，对eax执行减等于100操作00401128    sub    eax,64h//将结果赋值回nVarOne中0040112B    mov dword ptr [ebp-4],eax//C++源码对比，减法与加法混合运算nVarOne = nVarOne +5 - nVarTwo;//按照自左向右顺序依次执行0040112E    mov    ecx,dword ptr [ebp-4]00401131    add    ecx,500401134    sub    ecx,dword ptr [ebp-8]00401137    mov    dword ptr [ebp-4],ecx//printf函数调用显示略</code></pre><p>Release与加法相同，就不赘述了  </p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法运算对应的汇编指令有有符号<strong>imul</strong>和无符号<strong>mul</strong>两种，由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换成加法，或使用移位等周期较短的指令。当它们都不可转换时，才会使用乘法指令  </p><p><strong>乘法转换——Debug版</strong>  </p><pre><code>    //C++源码说明，乘法运算//防止被视为无效代码，将每条运算作为printf参数使用//变量定义int nVarOne = argc;int nVarTwo = argc;//变量乘常量(常量为非2的幂)printf(&quot;nVarOne*15 = %d \r\n&quot;,nVarOne * 15);//变量乘常量(常量值为2的幂)printf(&quot;nVarOne*16 = %d&quot;,nVarOne * 16);//两常量相乘printf(&quot;2*2 = %d&quot;,2 * 2);//混合运算printf(&quot;nVarTwo *4 +5 = %d&quot;,nVarTwo * 4 + 5);//两变量相乘printf(&quot;nVarOne * nVarTwo = %d&quot;,nVarOne * nVarTwo);//C++源码对应汇编//C++源码对比，变量 * 常量printf(&quot;nVarOne*15 = %d \r\n&quot;,nVarOne * 15);0040B8A4    mov    edx,dword ptr [ebp-4]//直接使用有符号乘法指令imul0040B8A7    imul    edx,edx,0Fh//C++源码对比 常量*常量(常量值为2的幂)printf(&quot;nVarOne*16 = %d&quot;,nVarOne * 16)0040B8B8    mov    eax,dword ptr [ebp-4]//使用左移运算代替乘法运算0040B8BB    shl    eax,4//C++源码对比，常量*常量printf(&quot;2*2 = %d&quot;,2 * 2);//在编译期间计算出2*2的结果，将表达式转换为常量值0040B8CC    push 40040B8CE    push offest string &quot;2 * 2 = %d&quot;(0041ffac)0040B8D3    call printf(0040B750)0040B8D8    add esp,8//c++源码对比，变量*常量+常量(组合运算)printf(&quot;nVarTwo *4 +5 = %d&quot;,nVarTwo * 4 + 5);0040B8DB    mov    ecx,dword ptr [ebp-8]//利用lea指令完成组合运算0040B8DE    lea    edx,[ecx*4+5]//c++源码对比，变量*变量printf(&quot;nVarOne * nVarTwo = %d&quot;,nVarOne * nVarTwo);0040B90A    mov    ecx,dword ptr [ebp-4]//直接使用有符号乘法指令0040B90D    imul ecx,dword ptr [ebp-8]</code></pre><p>代码使用编译选项为Od+ZI。在这种侧重调试的编译方式下，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法<strong>imul</strong>指令。当常量值为2的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令,而若乘数不等于2的幂次方，则会先拆分后用<strong>imul</strong>指令进行编译  </p><p><strong>各类型的乘法转换示例——Release版</strong>  </p><pre><code>    //IDA直接将参数作为局部变量使用arg_0 = dword ptr 4  //保存环境push esi//取出参数变量存入esi中mov esi,[esp+4+arg_0]//经过优化后，将nVarOne*15先转化为 乘2加自身，相当于乘3//eax = esi*2+esi = 3*esilea    eax,[esi+esi*2]//将上一步操作结果乘4加自身，等同于乘15//eax = eax * 4 + eax = 5 * eax = 5 * (3*esi)lea    eax,[eax+eax*4]push eaxpush offset aNvaronel15D; &quot;nVarOne * 15 = %d&quot;call _printf// esi中的数据传送到ecx，esi中保存的为参数数据mov    ecx,esi//将ecx中的数据左移4为，ecx乘以2^4shl    ecx,4push ecxpush offset aNvarone15D; &quot;nVarOne * 16 = %d&quot;call _printf//两常量相乘直接转换常量值push 4push offset a22D;    &quot;2*2 = %d&quot;call _printf//这句话等等同于lea edx,[esi*4+5]都是混合运算lea    edx,ds:5[esi*4]push edxpush offset aNvartwo45D;    &quot;nVarTwo * 4 +5 =%d&quot;call _printf//此处为乘数不等于2 4 8 情况，编译优化9进行分解：(nVarTwo*1+nVarTwo*8),这样就可以使用lea了lea eax,[esi+esi*8+5]push eaxpush _offset aNvartwo95D;    &quot;nVarTwo * 9 +5 =%d&quot;call _printf//此处为两个变量相乘，都是未知数，无忧化mov    ecx,esiimul ecx,esipush ecxpush offest aNvaroneNvartwo;    &quot;nVarOne * nVarTwo = %d&quot;call _printfadd    esp,30hpop    esi</code></pre><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》(二)&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术</title>
    <link href="http://www.kittener.top/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.kittener.top/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</id>
    <published>2020-06-15T08:22:46.000Z</published>
    <updated>2020-06-19T15:37:58.437Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》</p><a id="more"></a><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="IDA函数识别"><a href="#IDA函数识别" class="headerlink" title="IDA函数识别"></a>IDA函数识别</h2><p>IDA可以识别出函数MessageBoxA及其各参数的信息，IDA通过SIG文件来识别已知的函数信息<br>常用的SIG文件放置在了IDA安装目录中的SIG文件夹下<br><a href="https://blog.csdn.net/youyou519/article/details/100140265" target="_blank" rel="noopener">SIG文件制作</a></p><h2 id="反汇编引擎的工作原理"><a href="#反汇编引擎的工作原理" class="headerlink" title="反汇编引擎的工作原理"></a>反汇编引擎的工作原理</h2><p><img src="%E5%9B%BE1.jpg" alt="Intel指令结构图">  </p><ol><li><p>Instruction Prefixes:指令前缀<br>指令前缀是可选的，作为指令的补助说明信息存在，主要用于以下4种情况  </p><ul><li>重复指令：如REP、REPE、REPZ  </li><li>跨段指令：如MOV DWORD PTR FS:[XXXX],0</li><li>将操作数从32位转为16位：如MOV AX，WORD PTR DS:[EAX]</li><li>将地址从16位转为32位：如MOV EAX，DWORD PTR DS:[BX+SI]  </li></ul></li><li><p>Opcode:指令操作码<br>Opcode为机器码中的操作符部分，用来说明指令语句执行什么样的操作<br>汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条Opcode码，但由于操作数类型不同，所占长度也不相同，因此对于非单字节指令来说，解析一条汇编指令单凭Opcode是不够的，还需要Mode R/M、SIB、 Displacement 的帮助，才能够完整地解析出汇编信息  </p></li><li><p>Mode R/M：操作数类型<br>ModeRM是辅助Opcode解释汇编指令助记符后的操作数类型。R表示寄存器，M表示内存单元。Mode RM占一个字节的固定长度<br><img src="%E5%9B%BE2.jpg" alt="Mode R/M">  </p></li><li><p>SIB: 辅助Mode R/M，计算地址偏移<br>SIB的寻址方式为基址+变址，如MOV EAX,DWORD PTR DS:[EBX+ECX*2],其中的ECX、乘数2都是由SIB来指定的。SIB的结构如图1-15所示。SIB占1个字节大小，第0、1、2位用于指定作为基址的寄存器;第3、4、5位用于指定作为变址的寄存器:第6、7位用于指定乘数，由于只有两位，因此可以表示4种状态，这4种状态分别表示乘数为1.2、4、8<br><img src="%E5%9B%BE3.jpg" alt="SIB">  </p></li><li><p>Displacement：辅助Mode R/M，计算地址偏移<br>Displacement用于辅助SIB，如MOV EAX,DWORD PTR DS:[EBX+ECX*2+3]这条指<br>令，其中的“+3”是由Displacement来指定的  </p></li><li><p>Immediate：立即数<br>用于解释指令语句中操作数为-一个常量值的情况  </p></li></ol><h1 id="第二章-C-反汇编揭秘"><a href="#第二章-C-反汇编揭秘" class="headerlink" title="第二章 C++反汇编揭秘"></a>第二章 C++反汇编揭秘</h1><h2 id="浮点数的编码方式"><a href="#浮点数的编码方式" class="headerlink" title="浮点数的编码方式"></a>浮点数的编码方式</h2><p>float类型在内存中占4字节(32 位)。最高位用于表示符号;在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如图  </p><p><img src="%E5%9B%BE4.jpg" alt="float类型二进制存储">  </p><p>在进行二进制转换前，需要对单精度浮点数进行科学记数法转换。例如，将float类型的12.25f转换为IEEE编码，需将12.25f转换成对应的二进制数1100.01,整数部分为1100,小数部分为01 ;小数点向左移动，每移动1次指数加1，移动到除符号位的最高位为1处，停止移动，这里移动3次。对12.25f进行科学记数法转换后二进制部分为1.10001，指数部分为3。在IEEE编码中，由于在二进制情况下，最高位始终为1，为一个恒定值，故将其忽略不计。这里是一个正数，所以符号位添0  </p><p>所以，转换为:  </p><ul><li>符号位: 0  </li><li>指数位：十进制3+127，转换为二进制是10000010  </li><li>尾数位：10001000000000000000000  </li></ul><p>这里指数位+127是因为指数可能出现负数，127的二进制表示为01111111，规定当指数域小于01111111时为一个负数，反之为正数，因此01111111为0  </p><p>12.25f转换后的IEEE编码按二进制拼接为010000010100010000000000000000。转换<br>成十六进制数为0x41440000,内存中以小尾方式进行排列，故为00 00 44 41  </p><p>浮点数-0.125f转换IEEE编码后，将会是一一个符号位为1,指数部分为负的小数。-0. 125f经转换后二进制部分为0.001,用科学记数法表示为1.0，指数为-3  </p><p>所以转换结果为:  </p><ul><li>符号位: 1  </li><li>指数位：十进制(-3)+127，转换为二进制是01111100  </li><li>尾数位：00000000000000000000000  </li></ul><p>上面的两个浮点数小数部分转换为二进制时都是有穷的，如果小数部分转换为二进制时得到一个无穷值，则会根据尾数部分的长度舍弃多余的部分。单精度浮点数1.3f,小数部分转换为二进制就会产生无穷值，依次转换为: 0.3、0.6、 1.2、 0.4、 0.8、1.6、1.2、0.4、0.8…转换后得到的二进制数为1.01001100110011001100110,到第23位终止，尾数部分无法保存更大的值  </p><p>转换结果为：  </p><ul><li>符号位: 0  </li><li>指数位：十进制(0)+127，转换为二进制是01111111  </li><li>尾数位：01001100110011001100110  </li></ul><h2 id="基本的浮点数指令"><a href="#基本的浮点数指令" class="headerlink" title="基本的浮点数指令"></a>基本的浮点数指令</h2><p>浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1)。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0) 中的数据将装入ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表2-1所示，其中，IN表示操作数人栈，OUT 表示操作数出栈  </p><p><img src="%E5%9B%BE6.jpg" alt="常用浮点数指令表">  </p><pre><code>类型转换函数_ftol的实现  ;保存环境，预留语句变量空间0040E688  push  ebp0040E689  mov   ebp,esp0040E68B  add   esp,0f4h  ;浮点异常检查、CPU与FPU的同步工作0040E68E  wait0040E68E  fnstcw  word ptr [ebp-2]0040E692  wait0040E693  mov   ax,word ptr [ebp-2]0040E697  or    ah, 0Ch0040E69A  mov   word ptr [ebp-4] ,ax0040E69E  fldcw  word ptr [ebp-4]  ;从ST(0)中取出8字节数据转换成整型并存入ebp-0Ch中;将ST(0)从栈中弹出0040E6A1  fistp  qword ptr [ebp-0Ch]0040E6A4  fldcw  word ptr [ebp-2];使用eax保存整型数据的低4字节，用于返回0040E6A7  mov   dword ptr [ebp-0ch];使用edx保存整型数据的高4字节，用于返回0040E6AA  mov   edx,dword ptr [ebp-8];释放栈0040E6AD  leave0040E6AE  ret</code></pre><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>ASCII使用GB2312-80，又叫汉字国标码，保存了6763个常用汉字编码，用两个字节来表示一个汉字。在GB2312-80中用区和位来定位，第一个字节保存每个区，共94个区;第二个字节保存每个区中的位，共94位。详细信息可查看GB2312-80编码的说明  </p><p>Unicode使用UCS-2编码格式，最多可存储65536个字符。汉字博大精深，其中有简体字、繁体字，以及网络中流行的火星文，它们的总和远远超过了UCS-2的存储范围，所以UCS-2编码格式中只保存了常用字。为了将所有的汉字都容纳进来，Unicode也采用了与ASCII类似的方式一用 两个Unicode编码解释一个汉字，称之为UCS-4编码格式。UCS-2编码表的使用和ASCII码表的使用是一样的。每个数字编号在表中对应-一个汉字，从0x4E00到0x9520为汉字编码区。例如，在UCS-2中，“烫”字的编码为0x70EB  </p><p>C++使用结束符\O’作为字符串结束标志。ASCII编码使用一个字节“0’,Unicode编码使用两个字节\0’。需要注意的是，<strong>不能使用处理ASCII编码的函数对Unicode编码进行处理</strong>，因为如果Unicode编码中出现了只占用1字节的字符，就会发生解释错误  </p><h2 id="地址、指针和引用"><a href="#地址、指针和引用" class="headerlink" title="地址、指针和引用"></a>地址、指针和引用</h2><h3 id="指针和地址的区别"><a href="#指针和地址的区别" class="headerlink" title="指针和地址的区别"></a>指针和地址的区别</h3><p>在32位操作系统下，地址是一个由32位二进制数字组成的值。为了便于查看，转换成十六进制数字进行显示，用于标识内存编号。指针是用于保存这个编号的-种变量类型，它包含在内存中，所以可以取出指针类型变量在内存中的位置一地址。 由于指针保存的数据都是地址，所以<strong>无论什么类型</strong>的指针都占据<strong>4字节</strong>的内存空间，如图  </p><p><img src="%E5%9B%BE7.jpg" alt="指针和地址">  </p><p>指针可以根据指针类型对地址对应的数据进行解释。而一个地址值无法单独解释数据,对于图中0x0012FF68这个地址值，仅仅凭借它自己无法说明该地址处对应数据的信息。如果是在一个int 类型的指针中保存这个地址，就可以将0x0012FF68这个地址值看做是int类型数据的起始地址，向后数4字节到0x0014FF6C处。将0x0012FF68 ~0x0014FF6C中的数据按整型存储方式解释  </p><p><img src="%E5%9B%BE8.jpg" alt="指针和地址之间的不同点"><br><img src="%E5%9B%BE9.jpg" alt="指针和地址之间的不同点"><br><img src="P10.jpg" alt="指针和地址之间的共同点">  </p><h3 id="各类指针的工作方式"><a href="#各类指针的工作方式" class="headerlink" title="各类指针的工作方式"></a>各类指针的工作方式</h3><p>不同指针的源码：</p><pre><code>// C++源码对比，定义int类型变量，初始化为0x12345678int nVar = 0x12345678;;为地址赋值4字节数据12345678h0040EB1D  mov   dword ptr [ebp-10h],12345678h// C++源码对比，定义int类型指针变量，初始化为变量nVar地址int *pnVar = &amp;nVar;0040EB24  lea   ecx,[ebp-10h]0040EB27  mov   dword ptr [ebp-14h],ecx  // C++ 源码对比，定义char类型指针变量， 初始化为变量nvar地址char *pcVar = (char*) &amp;nVar;0040EB2A  lea   edx,[ebp-10h]0040EB2D  mov   dword ptr [ebp-1ch],eax  // C++源码对比，定义short类型的指针变量，初始化为变量nVar地址short *psnVar = { short*) &amp;nVar ;0040EB30  lea   eax,[ebp-10h]  0040EB33  mov   dword ptr [ebp-1Ch],eax  //C++源码对比，取出指针pnVar指向的地址内容并显示printf(&quot;%08x \r\n&quot;，*pnVar) ;;取出pnVar中保存的地址值并放入ecx中0040EB36  mov   ecx,dword ptr [ebp-14h];从ecx保存的地址中，以4字节方式读取数据，存入edx中0040EB39  mov   edx,dword ptr [ecx]pcVar 以1字节的方式读取数据存入ecx中psnVar 以2字节的方式读取存入eax中</code></pre><p>指针类型只支持加法和减法，指针进行运算后，指针内保存的地址值的增加或减少取决于<strong>指针类型</strong>，如int类会使地址值的变换是4  </p><p>type *P;//这里用type泛指某类型的指针s<br>p+n的目标地址=首地址+ sizeof( 指针类型type) * n  </p><p>两指针相减可以得到数组长度  </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++将指针操作进行了封装，产生了引用类型<br>引用通过编译器寻址，而指针需要手动寻址  </p><pre><code>void Add (int &amp;nVar) {;在Debug版中添加汇编代码略nVar++;     // C++源码对比，对引用类型nVar执行++操作;取出参数nVar中的内容放入eax中00401078  mov   eax,dword ptr [ebp+8]  ;对eax执行取内容操作0040107B  mov   ecx,dword ptr [eax]0040107D  add   ecx,100401080  mov   edx,dword ptr [ebp+8]00401083  mov   dword ptr [edx],ecx}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h3><p>#define是一个真常量，而const是由<strong>编译器判断</strong>的假常量，实际上，const定义的变量，终究还是一个变量，只是在编译器内进行了检查，发现有修改则报错  </p><p>所以可以修改const常量，通过指针获取const常量的地址，强制将指针的const修饰去掉，就可以修改对应的数据内容  </p><pre><code>// C++源码对比，将变量nConst修饰为constconst int nConst = 5;;将地址ebp-4赋值给4字节数据5004010B8  mov   dword ptr [ebp-4],5// C++源码对比，定义int类型的指针，保存nConst地址int *pConst = (int*) &amp;nConst ; ;获取ebp-4地址并存入eax中004010BF  lea   eax,[ebp-4];将eax中的数据赋值到地址ebp-8处004010C2  mov   dword ptr [ebp-8],eax// C++源码对比，修改指针pConst并指向地址中的数据*pConst = 6;;荻取地址ebp-8中的数据并存入ecx004010C5  mov   ecx,dword ptr [ebp-8];将地址ebp-8中保存的数据修改为6004010C8  mov   dword ptr [ecx],6// C++源码对比，将修饰为const的变量nConst腻值给nVarint nVar = nConst ;;将5赋值到地址ebp-0Ch处00401OCE  mov   dword ptr [ebp-0ch],5</code></pre><p>最后的直接赋值5是编译器做出了优化</p><p><img src="P11.jpg" alt="#define与const的区别"></p><h1 id="第三章-认识启动函数，找到用户入口"><a href="#第三章-认识启动函数，找到用户入口" class="headerlink" title="第三章 认识启动函数，找到用户入口"></a>第三章 认识启动函数，找到用户入口</h1><h2 id="程序真正入口"><a href="#程序真正入口" class="headerlink" title="程序真正入口"></a>程序真正入口</h2><p>main或WinMain函数应该是“语法规定的用户入口”，而不是“应用程序入口”。在应用程序被操作系统加载时，操作系统会分析执行文件内的数据，分配相关资源，读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实<strong>并不是main或WinMain</strong>，通常是<strong>mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup</strong>，具体视编译选项而定。其中<strong>mainCRTStartup和wmainCRTStartup</strong>是控制台环境下多字节编码和Unicode编码的启动函数，而<strong>WinMainCRTStartup和wWinMainCRTStartup</strong>则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定入口  </p><h2 id="VC-6-0的启动函数"><a href="#VC-6-0的启动函数" class="headerlink" title="VC++6.0的启动函数"></a>VC++6.0的启动函数</h2><p>VC++6.0在控制台和多字节编码环境下的启动函数为<strong>mainCRTStartup</strong>，由系统库<strong>KERNEL32.dll</strong>负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处  </p><pre><code>void mainCRTStartup (#endif /* WPRFLAG */#endif /* _WINMAIN_ */    void){    //荻取版本信息    _osver = GetVersion();    _winminor = (_osver &gt;&gt; 8) &amp; 0x00FF;    _winmajor = _ osver &amp; 0x00FF;    _winver = (_ winmajor &lt;&lt; 8) + _winminor;    _osver = (_osver &gt;&gt; 16) &amp; 0x00FFFF;    // 堆空间初始化过程，在此函数中，指定了程序中堆空间的起始地址    // _MT是多线程标记#ifdef _MT    if ( ! _heap_ init(1) )#else /* _MT */    if ( !_ heap_ init(0) )#endif /* _MT */    fast_error_ exit(_RT_HEAPINIT);    //初始化多线程环境#ifdef _MT    if( !_ mtinit() )        fast_error_exit(_RT_THREAD);#endif /* _MT */    _try {        // 宽字符处理代码略        // 多字节版荻取命令行        _acmdln = (char *) GetCommandLineA();    // 多字节版获环境变量信息    _aenvptr = {char *)__crtGetEnvironmentStringsA();    // 多字节版获取命令行信息    _setargv();    // 多字节版荻取环境变量信息    _setenvp();#endif /* WPRFLAG */    // 初始化全局数据和浮点寄存器    _cinit();    // 窗口程序处理代码略    // 宽字符处理代码略    // 获取环境变量信息    _initenv = _environ;    // 调用main函数，传递命令行参数信息    mainret = main(_argc, _argv, _environ);#endif /* WPRFLAG */#endif /* _WINMAIN_ */    // 检查main函数返回值执行析构函数或atexit注册的函数指针，并结束程序    exit (mainret);}// 退出结束代码略</code></pre><ul><li><strong>GetVersion函数</strong>:获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息</li><li><strong>_ heap_ init函数</strong>:用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_heap_init传递的参数决定。_sbh_heap_init函数用于初始化堆结构信息  </li><li><strong>GetCommandLineA函数</strong>:获取命令行参数信息的首地址  </li><li><strong>_crtGetEnvironmentStringsA函数</strong>:获取环境变量信息的首地址  </li><li><strong>_setargv函数</strong>:此函数根据GetCommandLineA获取命令行参数信息的首地址并进行参数分析，将分离出的参数的个数保存在全局变量_arge中，将分析出的每个命令行参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量_argv中。这样就得到了命令行参数的个数，以及命令行参数信息  </li><li><strong>_ setenvp 函数</strong>:此函数根据__crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中  </li></ul><p>得到main函数所需的三个参数信息之后，当调用main函数时，便可以将_ _argc、 _argv、 env这三个全局变量作为参数，以栈传参方式传递到main函数中  </p><ul><li><strong>_cinit函数</strong>:用于全局数据和浮点寄存器的初始化。全局对象和I/O流等的初始化都是通过这个函数实现的。利用函数 <em>itterm 进行数据链初始化，这个函数由两个参数组成，类型为“_PVFV*”,这是一个函数指针数组，其中保留了每个初始化函数的地址。初始化函数的类型为_PVFV, 其定义原型如下:<br>typedef void (</em> cdec1 * _PVFV) (void);<br>也就是说，这个初始化函数是无参数也无返回值的，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的，具体如下所示：  </li></ul><pre><code>// 用于初始化寄存器if (_FPinit != NULL)  (*_ FPinit) (); //初始化浮点寄存器// 用于初始化C语法中的数据_initterm( _xi_a, _xi_z );// 用于初始化C++语法中的数据_initterm( _XC_a, _XC_z );</code></pre><p><strong>FPinit</strong> 是一个全局函数指针，类型也是_PVFV, 如果编译器扫描代码时发现有浮点计算，则此指针保存了初始化浮点寄存器的代码地址，否则为0值。如果浮点寄存器未被初始化而进行浮点计算，程序会产生异常或错误，这类错误应属于VC++ 6.0自身设计的Bug,在VC++6.0以后的版本中已将其修复。一般而言，第一个_initterm 初始化的都是C支持库中所需的数据。参数_xi_a 为函数指针数组的起始地址，_xi_z为结束地址。 _initterm 的实现：  </p><pre><code>static void__ cdec1 initterm (    _PVFV * pfbegin,    _PVFV * pfend){    // 遍历数组的各元素    while ( pfbegin &lt; pfend )    {        // 若函数指针不为空，则执行该函数        if ( *pfbegin != NULL )            (**pfbegin) () ;        ++pfbegin;    }}</code></pre><p>在默认情况下，入口函数为main,这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置人口函数，依次选择菜单Procject→Settings →Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称。编译后调试程序，结果如图所示  </p><p><img src="P12.jpg" alt="重设入口函数">  </p><p>由于没有调用mainCRTStartup函数，所以<strong>堆空间没有被初始化</strong>，当使用堆空间时，程序会报错崩溃  </p><h2 id="识别main函数"><a href="#识别main函数" class="headerlink" title="识别main函数"></a>识别main函数</h2><p>main函数有如下特征是:它有3个参数，分别为命令行参数个数、命令行参数信息和环境变量信息，而且它是启动函数中唯一的具有3个参数的函数。同理，WinMain 也是启动函数中唯一的具有4个参数的函数  </p><pre><code>;省略部分代码; O1lyDBG识别出的函数名称为GetCommandLineA00401210  |. FF15 38514200   call dword ptr ds: [&lt; &amp;KERNEL32.GetCommand&gt;;得到命令行参数00401216  |. A3 444F4200    mov dword ptr ds: [424F44] , eax;根据main函数特性，此处为函数_crtGetEnvironmentStringsA() 调用0040121B  |. E8 E0240000    call ProgramE.0040370000401220  |. A3 BC354200    mov dword ptr ds: [4235BC] , eax;根据main函数特性，此处为函数_setargv()调用00401225  |. E8 C61F0000    call ProgramE.004031F0;根据main函数特性，此处为函数cinit()调用0040122F  |. E8 8C1A0000    call ProgramE.00402CC000401234  |. 8B0D 00364200  mov ecx, dword ptr ds: [423600]0040123A  |. 890D 04364200  mov dword ptr ds: [423604] , ecx00401240  |. 8B15 00364200  mov edx, dword ptr ds: [423600] ;压栈传参，环境变量信息00401246  |. 52             push edx00401247  |. Al F8354200    mov eax, dword ptr ds: [4235F8];压栈传参，命令行参数信息0040124C  |. 50             push eax0040124D  |. 8BOD F4354200  mov ecx, dword ptr ds; [4235F4];压栈传参，命令行参数个数00401253  |. 51             push ecx;此处为main函数的调用处，跟进到函数中便是main函数的实现代码流程00401254  |. E8 ACFDFFFF    call ProgramE.00401005</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-19T13:49:04.000Z</published>
    <updated>2020-06-09T15:19:21.538Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完</p><a id="more"></a><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol><li>方便性  </li><li>有效性<br>有效性的第一层含义是提高系统资源的利用率。另一层含义是，提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。  </li><li>可扩充性<br>OS从早期的无结构发展称模块化结构，进而发展成层次化结构，近年来广泛采用了微内核结构，具有良好的可扩充性。  </li><li>开放性<br>指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。  </li></ol><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ol><li>OS作为用户与计算机硬件系统之间的接口<br>用户通过命令方式、系统调用方式和图标——窗口方式来实现与操作系统的通信  </li><li>OS作为计算机系统资源的管理者<br>OS中的资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）  </li><li>OS实现了对计算机资源的抽象<br>OS是铺设在计算机硬件上的多层软件的集合，不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。  </li></ol><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol><li>处理过程<br>简单来说就是将作业装在磁带上，一个一个单个处理，如图：<br><img src="%E5%9B%BE1.jpg" alt="单道批处理系统">  </li><li>缺点<br>资源得不到充分利用，如图：<br><img src="%E5%9B%BE2.jpg" alt="运行情况">  </li></ol><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol><li>处理过程<br>用户所提交的作业先放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。  </li><li>优缺点<br>（1）资源利用率高<br>（2）系统吞吐量大<br>（3）平均周转时间长<br>（4）无交互能力  </li></ol><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol><li>运行方式  </li></ol><ul><li>作业直接进入内存  </li><li>采用轮转运行方式（加入时间片）  </li></ul><ol start="2"><li>特征  </li></ol><ul><li>多路性：系统允许将多台终端同时链接到一台主机上  </li><li>独立性：系统提供了这样的用户各自独立环境  </li><li>及时性：用户的请求很短时间内能得到相应  </li><li>交互性：用户可通过终端进行人机对话  </li></ul><h2 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h2><ul><li>单用户单任务操作系统  </li><li>单用户多任务操作系统  </li><li>多用户多任务操作系统  </li></ul><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol><li>并行与并发  </li></ol><ul><li>并行性是指两个或多个事件在同一时刻发生  </li><li>并发性是指两个或多个事件在统一时间间隔内发生  </li></ul><ol start="2"><li>引入进程  </li></ol><ul><li>进程是指：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。  </li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ol><li>互斥共享方式<br>一个进程访问完资源后，资源才能被另一个进程访问。资源叫做<strong>临界资源</strong>    </li><li>同时访问方式  </li></ol><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在os中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为<strong>虚拟</strong>。  </p><ol><li>时分复用技术（时间）  </li><li>空分复用技术（空间）  </li></ol><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ol><li>进程控制：为作业创建进程、撤销（终止）已结束的进程，以及控制进程在运行过程中的状态转换。  </li><li>进程同步：  </li></ol><ul><li>进程互斥方式：指诸进程在对临界资源进行访问时，应采用互斥方式  </li><li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。  </li></ul><ol start="3"><li>进程通信：通常采用直接通信方式，由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接受命令从其消息队列中取出消息  </li><li>调度  </li></ol><ul><li>作业调度：从后备队列中按一定算法取出若干队列。为其分配运行所需资源。</li><li>进程调度：从就绪队列中按照一定的算法选出一个进程，执行。</li></ul><h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ol><li>内存分配  </li></ol><ul><li>静态分配方式：每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间。</li><li>动态分配方式：允许申请新的空间。  </li></ul><ol start="2"><li>内存保护：每个程序互不打扰，操作系统的程序和数据不允许访问。</li><li>地址映射  </li><li>内存扩充  </li></ol><ul><li>请求调入功能：将程序所需部分从存储器中调入内存</li><li>置换功能：将内存和磁盘的数据进行置换  </li></ul><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol><li>共享存储器系统  </li></ol><ul><li>基于共享数据结构的通信方式。</li></ul><h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol><li>高级调度<br>调度对象是作业，其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为其创建进程、分配资源，放入就绪队列，主要应用于多道批处理系统  </li><li>低级调度<br>又称为进程调度或短程调度，其调度对象是进程(或内核级线程)。其主要功能是根据某种算法决定就绪队列中的哪个进程应获得处理机。</li><li>中级调度<br>提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存，把能运行的调至内存。  </li></ol><h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol><li>处理机调度算法的共同目标<br>(1)<strong>资源利用率</strong> CPU的利用率 = CPU的有效工作时间/(CPU的有效工作时间+CPU的空闲等待时间)<br>(2)<strong>公平性</strong> 每个进程都应该获得合理的CPU时间<br>(3)<strong>平衡性</strong> 尽可能保持系统资源使用的平衡性<br>(4)<strong>策略强制执行</strong> 对所制订的策略，保证其准确执行  </li><li>批处理系统的目标<br>(1)<strong>平均周转时间短</strong><br>(2)<strong>系统吞吐量高</strong><br>(3)<strong>处理机利用率高</strong>  </li><li>分时系统的目标<br>(1)<strong>响应时间快</strong><br>(2)<strong>均衡性</strong>  </li><li>实时系统的目标<br>(1)<strong>截止时间的保证</strong><br>(2)<strong>可预测性</strong>  </li></ol><h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ol><li>作业与作业步<br>(1)作业。不仅包含通常的程序和数据，还包括一份作业说明书，再批处理系统中，作业为基本单位从外存调入内存<br>(2)作业步。每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。每个步骤叫做一个作业步。  </li><li>作业的三种状态和三个阶段  </li></ol><ul><li>收容阶段，操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。(后备状态)</li><li>运行阶段(运行阶段)  </li><li>完成阶段(完成阶段)  </li></ul><ol start="3"><li>先来先服务和短作业优先调度算法  </li></ol><ul><li>先来先服务调度算法(FCFS)  </li><li>短作业优先调度算法(SJF):作业越短优先级越高  </li><li>优先级调度算法(PSA):外部赋予作业优先级  </li><li>高响应比优先调度算法(HRRN):优先权 = (等待时间+要求服务时间)/要求服务时间  </li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol><li>非抢占方式<br>一旦处理机分配给某进程后，就一直让它运行下去，不会因为时钟中断而被抢占。<br>可能引起进程调度的因素：  </li></ol><ul><li>程序执行完毕，或发生某种事件使程序无法执行  </li><li>I/O请求  </li><li>原语操作如Block<br>不适用于分时系统和大多数实时系统  </li></ul><ol start="2"><li>抢占方式<br>允许调度程序根据某一原则暂停执行中的程序，分配处理机给新的进程<br>原则：  </li></ol><ul><li>优先权原则：高优先级先运行  </li><li>短进程优先原则</li><li>时间片原则：时间片用完就暂停执行  <h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3>就绪队列上的每个进程每次仅运行一个时间片。  </li></ul><ol><li><strong>原理</strong><br>系统将所有的就绪进程按FCFS策略排成一个就绪队列。  </li><li><strong>进程切换时机</strong>  </li></ol><ul><li>执行完成</li><li>时间片用完，计时器中断处理程序被激活  </li></ul><ol start="3"><li><strong>时间片大小的确定</strong><br>略大于典型交互时间  <h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3></li><li><strong>类型</strong>  </li></ol><ul><li>非抢占式优先级调度算法：一旦处理机分配给了优先级最高的进程，则一直执行下去直至完成。</li><li>抢占式优先级调度算法：出现了更高优先级的进程，中断当前执行进程，转而去执行更高优先级的进程。  </li></ul><ol start="2"><li>优先级的类型  </li></ol><ul><li>静态优先级：进程运行过程中优先级保持不变  </li><li>动态优先级：随着时间增加而改变  <h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3>将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的算法。<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3></li></ul><ol><li>调度机制  </li></ol><ul><li>设置多个就绪队列，每个队列不同的优先级不同的时间片大小，在优先级愈高的队列中，其时间片就越小。  </li><li>每个队列采用FCFS算法。</li><li>按队列优先级调度。 <h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3></li></ul><ol><li>保证调度算法<br>这里的保证并不是优先运行，而是性能保证。</li></ol><ul><li>跟踪计算每个进程自创建以来已经执行的处理时间</li><li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n  </li><li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比  </li><li>比较各进程获得处理机时间的比率</li><li>选择比率最小的进程将处理机分配给它，知道超过最接近它的进程比率</li></ul><ol start="2"><li>公平分享调度方法<br>对用户公平  </li></ol><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol><li>提供必要的信息<br>(1)就绪时间<br>(2)开始截止时间和完成截止时间<br>(3)处理时间<br>(4)资源要求<br>(5)优先级  </li><li>系统处理能力强  </li><li>采用抢占式调度机制  </li><li>具有快速切换机制<br>(1)对中断的快速响应能力<br>(2)快速的任务分派能力  <h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li><li>非抢占式调度算法</li></ol><ul><li>非抢占式轮转调度算法  </li><li>非抢占式优先调度算法  </li></ul><ol start="2"><li>抢占式调度算法  </li></ol><ul><li>基于时钟中断的抢占式优先级调度算法</li><li>立即抢占的优先级调度算法  </li></ul><h3 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h3><p>任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。  </p><h3 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h3><p>松弛度 = 必须完成的时间 - 其本身的运行时间 - 当前时间<br>松弛度低的先运行  </p><h3 id="优先级倒置-priority-inversion-problem"><a href="#优先级倒置-priority-inversion-problem" class="headerlink" title="优先级倒置(priority inversion problem)"></a>优先级倒置(priority inversion problem)</h3><p>低优先级和高优先级的共享一临界资源，就会导致如果低优先级的<strong>先执行</strong>，高优先级在得到处理机后，因为临界资源被<strong>占用</strong>而被<strong>堵塞</strong>，导致低优先级的先执行  </p><ul><li>解决方法：<br>1 低优先级在进入临界区后不允许被抢占<br>2 低优先级继承高优先级的优先级，率先执行完  </li></ul><h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ol><li>可重用资源和消耗性资源  </li></ol><ul><li>可重用资源：一种可供用户重复使用多次的资源，有如下性质：<br>(1)每一个可重用资源中的单元只能分配给一个进程使用，不能共享<br>(2)进程在使用可重用性资源时，必须先请求再使用<br>(3)数目固定，进程在运行期间既不能创建也不能删除  </li><li>可消耗资源：在进程运行期间，由进程动态创建和消耗  </li></ul><ol start="2"><li>可抢占性资源和不可抢占资源  </li></ol><h3 id="计算机中的死锁"><a href="#计算机中的死锁" class="headerlink" title="计算机中的死锁"></a>计算机中的死锁</h3><ul><li>竞争不可抢占性资源引起死锁</li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁  </li></ul><h3 id="死锁的定义、必要条件和处理方法"><a href="#死锁的定义、必要条件和处理方法" class="headerlink" title="死锁的定义、必要条件和处理方法"></a>死锁的定义、必要条件和处理方法</h3><ol><li>定义：如果一组进程中的每一个进程都在等待仅有该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</li><li>产生死锁的必要条件<br>(1)互斥条件。进程对所分配道德资源进行排他性使用<br>(2)请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有<br>(3)不可抢占条件<br>(4)循环等待条件  </li><li>处理死锁的方法<br>(1)预防死锁：通过设置某些限制条件，去破坏一个进程<br>(2)避免死锁：用某种方法防止系统进入不安全状态，从而可以避免发生死锁<br>(3)检测死锁：通过检测机构及时检测出死锁发生，采取适当措施<br>(4)解除死锁：撤销进程，回收资源  </li></ol><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><ol><li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需地全部资源。这样就避免了资源”请求”条件。</li><li>第二种协议：允许一个进程只获得运行储器所需资源后，便开始运行。进程运行过程中在逐步释放已分给自己的、且已用毕地全部资源，然后再请求新的所需资源  <h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3>当一个已经保持了某些不可被抢占资源地进程，提出新的资源请求而得不到满足时，它必须释放已经保持地所有资源，待以后需要时再重新申请  <h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3>对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增地顺序请求资源。一个进程在开始时可以请求Ri的资源，以后当且仅当F(Rj)&gt;F(Ri)的时候才可以请求Rj的资源  </li></ol><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul><li>安全状态<br>所谓的安全状态是指系统能按某种进程推进顺序(P1,P2,···,Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成  <h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><a href="https://blog.csdn.net/qq_36260974/article/details/84404369" target="_blank" rel="noopener">银行家算法</a>  </li></ul><h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储器结构"><a href="#多层结构的存储器结构" class="headerlink" title="多层结构的存储器结构"></a>多层结构的存储器结构</h3><p>可执行存储器：寄存器和主存储器<br>主存储器：内存或主存，用于保存进程运行时的程序和数据<br>寄存器：具有与处理机相同的速度  </p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序，需经过如下步骤：</p><ul><li>编译，有编译程序对用户源程序进行编译，形成若干个目标模块  </li><li>链接，由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块  </li><li>装入，由装入程序将装入模块装入内存  <h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3>有三种装入方式：  </li></ul><ol><li>绝对装入方式  </li><li>可重定位装入方式  </li><li>动态运行时的装入方式<br>装入程序把装入模块装入后，并不立即把装入模块中的逻辑地址转换为物理地址，而是等到运行时才进行  </li></ol><h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ol><li>静态链接方式<br>在程序运行之前，先将各目标模块及他们所需的库函数链接成一个完整的装配模块，以后不在拆开。<br>(1)对相对地址进行修改。在编译程序所产生的所有目标模块中，使用的都是相对地址。<br>(2)变换外部调用符号  </li><li>装入时动态链接方式<br>指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。<br>有以下优点：<br>(1)便于修改和更新<br>(2)便于实现对目标模块的共享  </li><li>运行时动态链接<br>对某些模块的链接推迟到程序执行时才进行  <h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2>为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻  <h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3>把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常时放在内存的低址部分。而在用户区中，仅装有一道用户程序  <h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3>将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业  </li><li>划分分区的方法<br>(1)分区大小相等<br>(2)分区大小不等  </li><li>内存分配<br>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态  </li></ol><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol><li>动态分区分配中的数据结构  </li></ol><ul><li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等数据项  </li><li>空闲分区链：每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针  </li></ul><ol start="2"><li>分区分配操作  </li></ol><ul><li>分配内存</li><li>回收内存  </li></ul><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><ol><li>首次适应算法(FF)<br>FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按作业大小，从该分区划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中<br>该算法倾向于优先利用内存中的低址部分的空闲分区，从而保留高址部分的大空闲区  </li><li>循环首次适应算法(NF)<br>为了避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找  </li><li>最佳适应算法(BF)<br>将所有空闲分区按其容量以从小到大的顺序形成一空闲分区链  </li><li>最坏适应算法(WF)<br>将所有空闲分区按其容量以从大到小顺序形成一空闲分区链，每次挑选最大的从中分割一部分给作业使用  </li></ol><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><ol><li>快速适应算法(QF)<br>分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针<br>搜索时分为两步：(1)根据进程长度，从索引表中寻找能容纳它的最小空闲区链表;(2)从链表中取下第一块进行分配即可<br>缺点是在分区归还主存时算法复杂，一个分区只给一个进程容易浪费  </li><li>伙伴系统(buddy system)<br>无论已分配分区或空闲分区，其大小均为2的k次幂。分配时找2的i次方，合并时一样  </li><li>哈希算法<br>利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张一空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针  </li></ol><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>动态重定位<br>程序在执行时，真正访问的内存地址时相对地址与重定位寄存器中的低址相加而形成的，动态重定位分区与动态分区算法除了增加了”紧凑”功能外基本上相同  </li></ol><h2 id="对换-Swapping"><a href="#对换-Swapping" class="headerlink" title="对换(Swapping)"></a>对换(Swapping)</h2><h3 id="多道程序环境下的对换技术"><a href="#多道程序环境下的对换技术" class="headerlink" title="多道程序环境下的对换技术"></a>多道程序环境下的对换技术</h3><ol><li>对换技术：<br>在系统中设置一个对换进程，由它将内存中暂时不能运行的进程调出到磁盘的对换区;同样也由该进程将磁盘上已具备运行条件的进程调入内存  </li><li>对换的类型：  </li></ol><ul><li>整体对换:以整个进程为单位对换  </li><li>页面(分段)对换:以一个”页面”或”分段”为单位进行对换  <h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3></li></ul><ol><li>对换空间管理的主要目标<br>(1)对文件区管理的主要目标<br>提高文件存储空间的利用率，然后提高对分及的访问速度，因此，对文件区空间的管理采取离散分配方式<br>(2)对对换空间管理的主要目标<br>提高进程换入和换出速度，然后提高文件存储空间的利用率，因此对对换空间的管理采取连续分配方式  </li><li>对换区空闲盘块管理中的数据结构<br>可以用空闲分区表或空闲分区链，每个表目中包含两项:对换区的首地址及其大小，分别用盘块号和盘块数表示  </li><li>对换空间的分配与回收<br>与动态分区一样  <h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3></li><li>进程的换出<br>(1)选择被换出的进程<br>(2)进程换出过程  </li><li>进程的换入<br>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出”就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程  </li></ol><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><ol><li><p>页面与物理块<br>(1)页面<br>分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号，内存的物理低址空间分为若干块，同样也为它们加以编号。为进程分配内存时，以块为单位，将进程中的若干个页分别装入到若干个可以不相邻接的物理块中。<br>(2)页面大小  </p></li><li><p>地址结构<br>分页地址包含两部分内容：前一部分为页号P，后一部分为位(偏)移量W，即页内地址  </p></li><li><p>页表<br>分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表  </p></li></ol><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号  </p><ol><li>基本的地址变换机构<br>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，若未出现错误，则将页表始址与页号和页表项长度的成绩相加，则得到该表项在页表中的位置  </li><li>具有快表的地址变换机构<br>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”<br>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中  </li></ol><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经给地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间(EAT)  </p><h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>32位系统中页表可能会很大，所以有两个方法解决问题:<br>(1)对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题<br>(2)只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入  </p><ol><li>两级页表<br>将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中<br>为离散分配的页表再建立一张页表，称为<strong>外层页表</strong>，在每个页表项中记录了页表页面的物理块号  </li><li>多级页表  </li></ol><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>为每一个物理块设置一个页表项，并将它们按物理块的序号排序，其中的内容则是页号和其所隶属进程的标识符<br>在利用反置页表进行地址变换时，是根据进程标识符和页号，取检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器  </p><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul><li>方便编程  </li><li>信息共享  </li><li>信息保护  </li><li>动态增长  </li><li>动态链接  <h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3></li></ul><ol><li>分段<br>在分段存储管理方式中，作业的地址空间被划分为若干段，每个段定义了一组逻辑信息，即每个段既包含了一部分地址空间，又标识了逻辑关系，其逻辑地址由段号和段内地址所组成  </li><li>段表<br>在分段式存储管理系统中，为每个分段分配一个连续的分区，进程中的各个段，可以离散地装入内存中不同的分区中，然后建立一个段映射表，<em>段表</em>  </li><li>地址变换机构<br>段表寄存器和联想寄存器  </li><li>分页和分段的区别  </li></ol><ul><li>页是信息的物理单位  </li><li>页的大小固定且由系统决定  </li><li>分页的用户程序地址空间是一维的  </li></ul><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol><li>基本原理<br>先将程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名，系统中需要同时配置段表和页表，段表的内容与分段系统略有不同，是页表始址和页表长度  </li><li>地址变换过程<br>首先利用段号S，将它与段长TL进行比较。若S &lt; TL, 表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址  </li></ol><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>因为实际运行作业的时候可能会出现:  </p><ol><li>有的作业很大  </li><li>有大量作业要求运行<br>出现上述情况的原因都是内存容量不够大，所以从逻辑上扩充内存容量  <h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><h3 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h3></li><li>常规存储器管理方式的特征  </li></ol><ul><li>一次性，是指作业必须一次性地全部装入内存后方能开始运行  </li><li>驻留性，是指作业被装入内存后，整个作业都一直驻留再内存中，其中任何部分都不会被换出，直至作业运行结束  </li></ul><ol start="2"><li>局部性原理<br>程序在执行时将呈现出局部性规律，即在一较短地时间内，程序的执行仅局限于某个部分，相应地，它访问的存储空间也局限于某个区域  <h3 id="虚拟存储器地定义和特征"><a href="#虚拟存储器地定义和特征" class="headerlink" title="虚拟存储器地定义和特征"></a>虚拟存储器地定义和特征</h3></li><li>定义<br>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充地一种存储器系统  </li><li>虚拟存储器的特征  </li></ol><ul><li>多次性：指一个作业中的程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行  </li><li>对换性：指一个作业中地数据和程序，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出  </li><li>虚拟性：指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量  <h3 id="虚拟存储器地实现方法"><a href="#虚拟存储器地实现方法" class="headerlink" title="虚拟存储器地实现方法"></a>虚拟存储器地实现方法</h3></li></ul><ol><li>分页请求系统<br>是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统<br>(1)硬件支持：请求分页的页表机制、缺页中断机制、地址变换机构<br>(2)实现分页请求的软件：包括有用于实现请求调页的软件和实现页面置换的软件  </li><li>请求分段系统<br>是在分段系统的基础上，增加了请求调段及分段置换后所形成的段式虚拟存储系统  <h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3></li><li>请求页表机制<br>每个页表应该包含页号、物理块号、状态位、访问字段A、修改位M、外存地址  </li></ol><ul><li>状态位P:用于指示该页是否已经调入内存  </li><li>访问字段A:用于记录本页在一段时间内被访问的次数  </li><li>修改位M:标识该页在调入内存后是否被修改过  </li><li>外存地址:用于指出该页在外存上的地址  </li></ul><ol start="2"><li>缺页中断机构<br>每当要访问的页面不存在时，便产生一缺页中断，请求OS将所缺之页调入内存，有两个特点:<br>(1)在指令执行期间产生和处理中断信号<br>(2)一条指令在执行期间可能产生多次缺页中断  </li><li>地址变换机构<br><img src="%E5%9B%BE5-2.png" alt="地址变换过程">  </li></ol><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ol><li>最小的物理块数的确定<br>指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行  </li><li>内存分配策略  </li></ol><ul><li>固定分配局部置换:为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，如何再调入一页，然后再调入一夜，以保证分配给该进程的内存空间不变  </li><li>可变分配全局置换:指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地增加或减少。如果在进程运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块中选出一块换出  </li><li>可变分配局部置换:只允许在该进程的内存页面选择一页换出，若频繁缺页，则增加进程页面  </li></ul><ol start="3"><li>物理块分配算法  </li></ol><ul><li>平均分配</li><li>按比例分配  </li><li>优先权分配  <h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3></li></ul><ol><li>何时调入页面  </li></ol><ul><li>预调页策略</li><li>请求调页策略  </li></ul><ol start="2"><li>从何处调入页面<br>外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区<br>对换区一般采用连续分配方式，文件区一般采用离散分配方式<br>(1)系统拥有足够的对换区空间:<br>这时可以全部从对换区调入所需页面<br>(2)系统缺少足够的对换区空间:<br>不会被修改的文件，直接从文件区调入，会被修改的，须先调到对换区<br>(3)UNIX方式:<br>未运行过的页面，都从文件区调入，对于曾经运行过但又被换出的页面，从对换区调入  </li><li>调入过程<br>先找物理块位置，如果内存未满，调入；已满，置换。被置换的若被修改过，重写进磁盘  </li><li>缺页率<br>访问失败次数/总访问次数  <h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><a href="https://www.cnblogs.com/Leophen/p/11397699.html" target="_blank" rel="noopener">置换算法</a><h3 id="访问内存的有效时间-1"><a href="#访问内存的有效时间-1" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3>(1)被访问页在内存中，且其对应的页表项在快表中<br>EAT = 查找快表的时间+访问实际物理地址的时间<br>(2)被访问页在内存中，且其对应的页表项不在快表中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间<br>(3)被访问页不在内存中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间+处理断页中断的时间+更新快表的时间+访问实际物理地址的时间  <h2 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h2><h3 id="多道程序度和”抖动”"><a href="#多道程序度和”抖动”" class="headerlink" title="多道程序度和”抖动”"></a>多道程序度和”抖动”</h3></li><li>多道程序度和处理机的利用率<br>处理机的实际利用率随着进程数的增加而提高，但达到一定数目时开始下降  </li><li>抖动<br>在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求  <h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3>工作集是指，在某段时间间隔里，进程实际所要访问页面的集合  <h3 id="“抖动”的预防办法"><a href="#“抖动”的预防办法" class="headerlink" title="“抖动”的预防办法"></a>“抖动”的预防办法</h3></li><li>采用局部置换策略  </li><li>把工作集算法融入到处理机调度中  </li><li>利用”L=S”准则调节缺页率<br>L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面的时间  </li></ol><ul><li>L &gt;&gt; S，说明很少缺页，磁盘未充分利用  </li><li>L &lt;&lt; S,说明频繁缺页</li><li>L = S，完美  </li></ul><ol start="4"><li>选择暂停的进程  <h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><img src="%E5%9B%BE5-3.png" alt="段表结构">  </li></ol><ul><li>缺段中断机构<br>一条指令不可能被分割在两个分段中<br><img src="%E5%9B%BE5-4.png" alt="中断处理"></li><li>地址变换机构<br><img src="%E5%9B%BE5-5.png" alt="地址变换">  <h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3></li></ul><ol><li>共享段表<br>配置一张共享段表，所有各共享段表中占有一表项。在表项上面记录了共享段的段号、段长、内存始址、状态(存在)位、外存始址以及共享计数等信息  </li></ol><ul><li>共享进程数:显示当前共享该分段的进程数  </li><li>存取控制字段:赋予不同进程不同权限  </li><li>段号:不同的进程有不同的段号  </li></ul><ol start="2"><li>共享段的分配与回收<br>(1)共享段的分配<br>对第一个请求使用该共享段的进程，系统为该共享段分配一物理区，再把共享段调入该区。同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中添加一表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1，之后的count+1，再添加表项<br>(2)共享段的回收<br>撤销进程段表中共享段所对应的表项,count-1  </li><li>分段保护  </li></ol><ul><li>越界检查  </li><li>存取控制检测  </li><li>环保护机构  <h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h3></li></ul><ol><li>中断和陷入  </li></ol><ul><li>中断是指CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，叫做外中断  </li><li>陷入是CPU内部事件引发的中断，如运算溢出，程序出错，称为内中断  </li></ul><ol start="2"><li>中断向量表和中断优先级  </li></ol><ul><li>中断向量表是为每种设备配以中断的不同类，处理的时候直接查表找处理程序</li><li>中断优先级，为每个中断规定不同的优先级  </li></ul><ol start="3"><li>多中断源的处理方式</li></ol><ul><li>屏蔽中断<br>当处理机在处理一个中断时，将屏蔽其他所有中断  </li><li>嵌套中断<br>(1)当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求<br>(2)高优先级的中断请求可以抢占正在运行的低优先级中断的处理机  <h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3></li><li>测定是否有未响应的中断信号  </li><li>保护被中断进程的CPU环境  </li><li>转入相应的设备处理程序  </li><li>中断处理  </li><li>恢复CPU的现场并退出中断：<br>是否会返回到被中断的进程取决于哪个阶段：</li><li>是否采用屏蔽中断方式，若采用则返回  </li><li>采用的是中断嵌套方式，若没有更高优先级的中断，仍被返回被中断进程  <h3 id="对I-O设备的控制方式"><a href="#对I-O设备的控制方式" class="headerlink" title="对I/O设备的控制方式"></a>对I/O设备的控制方式</h3></li></ul><ol><li>采用轮询的可编程I/O方式<br>设置busy标志，输入未完成时为1，完成时为0  </li><li>使用中断的可编程I/O方式<br>CPU和I/O设备可以并行操作  </li><li>直接存储器访问方式  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向学习</title>
    <link href="http://www.kittener.top/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.kittener.top/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-17T09:52:25.000Z</published>
    <updated>2020-04-17T15:07:20.189Z</updated>
    
    <content type="html"><![CDATA[<p>这是TG:HACK2020的一道比赛题目<br>题目给的hint很误导人…反正我没看出来  </p><a id="more"></a><blockquote><blockquote><blockquote><p>Hint<br>Random title?  </p></blockquote></blockquote></blockquote><p>这是题目描述：Someone found this very old game lying around. Apparently there is an extremely funny joke in there somewhere.</p><p>之前没怎么做过安卓题目，所以这次真是学到了很多<br>题目的名字叫Bad intentions<br>上Google搜索之后发现是一堆歌曲，好吧这肯定跟题目没啥关系<br>当搜索apk intentions的时候就出现了有用的信息：<br><img src="1.jpg" alt="google搜索结果">  </p><p>所谓的apk intentions就是指这个程序能不能被外部访问，或者进行数据交换  </p><blockquote><blockquote><blockquote><p>Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动 作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的 交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。  </p></blockquote></blockquote></blockquote><p>然后就是如何查看这个apk包中有没有调用intent这个类了<br><code>aapt dump xmltree gaiainvaders.apk AndroidManifest.xml</code></p><blockquote><blockquote><blockquote><p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。  </p></blockquote></blockquote></blockquote><p>关于AndroidManifest.xml这个文件的介绍<a href="https://www.jianshu.com/p/3b5b89d4e154" target="_blank" rel="noopener">点这</a></p><p>就会输出如下信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E: activity (line&#x3D;19)  </span><br><span class="line">    A:android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;20)</span><br><span class="line">          E: action (line&#x3D;21)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;23)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br><span class="line">    E: activity (line&#x3D;26)</span><br><span class="line">        A: android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.JokeActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.JokeActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;27)</span><br><span class="line">          E: action (line&#x3D;28)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;30)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br></pre></td></tr></table></figure><p>可以看出了是调用了intent类的，而且发现一个JokeActivity的类。联想到题目描述觉得应该是这个文件了，用jeb打开看一下(我当时做这道题的时候没想到这，被其他地方误导了)  </p><p><img src="2.jpg" alt=""></p><p>这是JokeActivity方法，我当时被这个给迷惑了…  </p><p><img src="3.jpg" alt=""></p><p>到这可以看出来是个AES加密，写出脚本就可以跑出来了(大概，我没试)<br>还有一种更简单的方法<br>学习一下<br>上述提到了intent这个包，它是对于Android程序安全性相关性很大的包，有了它之后我们就可以对这个APK进行调试<br><code>adb install gaiainvaders.apk</code>  </p><blockquote><blockquote><blockquote><p>adb全称Android Debug Bridge，是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。说直白一点就是通过adb可以实现<strong>用命令行控制设备。</strong></p></blockquote></blockquote></blockquote><p>使用adb有两种方法  </p><ol><li>需要安装安卓手机模拟器，这里我选择了网易的mumu模拟器，安装之后在<strong>platform-tools</strong>下运行adb程序<br><code>adb connect 127.0.0.1:7555</code><br>每个模拟器默认的端口不一样，具体的<a href="https://www.cnblogs.com/HakunaMatata-/p/10609307.html" target="_blank" rel="noopener">看这</a><br>等它显示success之后就表示连接上了，之后执行安装命令就好了  </li><li>用安卓手机之间连接，手机进入开发者模式，cmd中输入<br><code>adb devices</code><br>之后就安装就可以了  </li></ol><p>然后我们只需要运行JokeActivity这个类就能得到flag了，这里用<br><code>adb shell am start -n &quot;no.tghack.gaiainvaders/.JokeActivity&quot;</code>  </p><blockquote><blockquote><blockquote><p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.</p></blockquote></blockquote></blockquote><p>启动的方法为</p><p><code>adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}</code>  </p><p>然后就得到了flag<br><img src="4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是TG:HACK2020的一道比赛题目&lt;br&gt;题目给的hint很误导人…反正我没看出来  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.kittener.top/categories/Android/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于python2的encode(&#39;hex&#39;)在python3上的解决</title>
    <link href="http://www.kittener.top/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://www.kittener.top/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-07T14:34:38.000Z</published>
    <updated>2020-04-17T16:07:22.783Z</updated>
    
    <content type="html"><![CDATA[<p>今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  </p><a id="more"></a>  <p>python2对于字符串转换成hex编码的时候使用的是str本身具有的方法，即str.encode(‘hex’)<br>但是这个方法在python3中取消了，解决方案如下：<br>首先  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 &#x3D; bytes(str,encoding &#x3D; &#39;utf-8&#39;)  </span><br><span class="line">str1.hex()</span><br></pre></td></tr></table></figure><p>即可  </p><p>顺便扩充一下知识：  </p><h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><h3 id="1-使用bytes函数创建bytes"><a href="#1-使用bytes函数创建bytes" class="headerlink" title="1.使用bytes函数创建bytes"></a>1.使用bytes函数创建bytes</h3><ul><li>bytes() 创建一个空的bytes  </li><li>bytes(int) 创建一个int位的全位0的bytes  </li><li>bytes(iterabl_of_ints) 可迭代数字组成的bytes(比如range)</li><li>bytes(string,encoding[,errors]) 等价于string.encode()</li><li>bytes(bytes of buffer) 创建一个bytes的copy  </li></ul><h3 id="2-直接定义"><a href="#2-直接定义" class="headerlink" title="2.直接定义"></a>2.直接定义</h3><p>比如：</p><p>​ b = b’abc’</p><p>​ b = b’\x61’</p><h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><ul><li>string.encode()</li><li>int.tobytes()</li><li>bytes.from</li><li>bytes函数定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes()</span><br><span class="line">b&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(3)</span><br><span class="line">b&#39;\x00\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(range(3))</span><br><span class="line">b&#39;\x00\x01\x02&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;中国&#39;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(b)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br></pre></td></tr></table></figure><p>直接创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; b&#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; 97</span><br><span class="line">&gt;&gt;&gt; n.to_bytes(1,byteorder&#x3D;&#39;big&#39;)</span><br><span class="line">b&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;中国&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.encode(encoding &#x3D; &#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;61&#39;)</span><br><span class="line">b&#39;a&#39;</span><br></pre></td></tr></table></figure><h2 id="bytes的显示方式"><a href="#bytes的显示方式" class="headerlink" title="bytes的显示方式"></a>bytes的显示方式</h2><blockquote><blockquote><blockquote><p>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</p></blockquote></blockquote></blockquote><p>只有ASCII中的字符串是可以直接在bytes类型中显示出来的，所有大于127的数值用转义字符表达。</p><p>比如，内存中的字节对象用十六进制表示为61，在python中显示的方式不是b’\x61’ 而是b’a’；而b’\xe4’显示方式就是b’\xe4’；注意：仅仅是显示方式而已</p><p>另外，并不是所有的小于127的都可以被友好的显示出来，有些对象本身不可显示，就显示其十六进制表示。比如</p><p>b’\x00’</p><p>bytes的一般方法<br>bytes类似于string；在方法上，除了自己特有的方法外，跟str也类似。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.find(b&#39;\x63&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.replace(b&#39;\61&#39;,b&#39;A&#39;)</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure><h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><p>bytearray是可变的bytes数据类型，可以通过bytearray创建和定义</p><h3 id="一：bytearray-定义"><a href="#一：bytearray-定义" class="headerlink" title="一：bytearray()定义"></a>一：bytearray()定义</h3><ul><li><p>bytearray() 创建一个空的bytearray</p></li><li><p>bytearray(int) 创建一个int位的全位0的bytearray</p></li><li><p>bytearray(iterabl_of_ints) 可迭代数字组成的bytearray(比如range)</p></li><li><p>bytearray(string,encoding[,errors]) 将一个字符串编码为bytearray</p></li><li><p>bytearray(bytes of buffer) 创建一个bytearray</p><h3 id="二-bytearray的方法定义"><a href="#二-bytearray的方法定义" class="headerlink" title="二: bytearray的方法定义"></a>二: bytearray的方法定义</h3></li><li><p>bytearray.fromhex()  </p><h3 id="bytearray的一般方法"><a href="#bytearray的一般方法" class="headerlink" title="bytearray的一般方法"></a>bytearray的一般方法</h3></li></ul><p>bytearray具备bytes的操作方法，像字符串一样操作；</p><p>另外bytearray还具备像list一样的操作方法，比如pop，append等</p><h3 id="bytes-和-bytearray的方法"><a href="#bytes-和-bytearray的方法" class="headerlink" title="bytes 和 bytearray的方法"></a>bytes 和 bytearray的方法</h3><p>十六进制和字节类型的相互转换  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bytes.fromhex()</span><br><span class="line">bytearray.fromhex()</span><br><span class="line">bytes.hex()</span><br><span class="line">bytesarray.hex()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; ba &#x3D; bytearray(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;hell&#39;</span><br><span class="line">&gt;&gt;&gt; ba</span><br><span class="line">bytearray(b&#39;hell&#39;)</span><br><span class="line">&gt;&gt;&gt; b.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&gt;&gt;&gt; ba.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br></pre></td></tr></table></figure><p>但是decode的好像没有特别好的办法除了使用binascii模块…  </p><h2 id="binascii模块的使用"><a href="#binascii模块的使用" class="headerlink" title="binascii模块的使用"></a>binascii模块的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>binascii模块包含很多用来方法来转换二进制和各种ASCII编码的二进制表示法。通常不直接使用这些功能，而是使用封装模块，如uu, base64或binhex。binascii模块包含用C语言编写更快的低级功能，通常为高级模块所使用。  </p><ul><li>相关模块  </li></ul><ol><li>base64 模块</li><li>binhex 模块</li><li>uu 模块</li><li>quopri 模块  </li></ol><h3 id="UU编码"><a href="#UU编码" class="headerlink" title="UU编码"></a>UU编码</h3><p>相关函数binascii.a2b_uu(string)和binascii.b2a_uu(data)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p><h3 id="Binhex编码"><a href="#Binhex编码" class="headerlink" title="Binhex编码"></a>Binhex编码</h3><p>相关函数有：binascii.rledecode_hqx(data) ，binascii.rlecode_hqx(data)，binascii.b2a_hqx(data) ，binascii.crc_hqx(data, crc)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>binascii.a2b_base64(string)：转换的base64数据块为二进制，并返回二进制数据。一次可以传递多行。和base64. b64decode对应。 binascii.b2a_base64(data)：转换二进制数据为一行base64编码的ASCII字符。返回字符串包含换行符。根据base64的标准data的长度最大为57。和base64. b64encode对应。，更多资料点<a href="http://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">这</a>  </p><h3 id="QP编码"><a href="#QP编码" class="headerlink" title="QP编码"></a>QP编码</h3><p>Quoted-printable，或QP encoding，没有规范的中文译名，可译为“可打印字符引用编码”、“使用可打印字符的编码”。Quoted-printable是使用可打印的 ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。  </p><p>QP使用”=”开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.  </p><p>binascii.a2b_qp(string[, header])：转换引述打印数据块为二进制，并返回二进制数据。多行可以在同一时间被传递。如果可选参数头存在和真实，下划线将被解码为空格。  </p><p>实际上，QP码是是把’\x00’转换成’=00’，也就是替换’\x’为’=’。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D;&#39;\x00&#x3D;&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;&#x3D;\x00hello&#39;</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; encoded &#x3D; binascii.b2a_qp(s)</span><br><span class="line">&gt;&gt;&gt; encoded</span><br><span class="line">&#39;&#x3D;3D&#x3D;00hello&#39;</span><br><span class="line">&gt;&gt;&gt; decoded &#x3D; binascii.a2b_qp(encoded)</span><br><span class="line">&gt;&gt;&gt; print decoded</span><br><span class="line">&#x3D;hello</span><br><span class="line">&gt;&gt;&gt; print repr(decoded)</span><br><span class="line">&#39;&#x3D;\x00hello&#39;</span><br></pre></td></tr></table></figure><h3 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h3><p>binascii.crc32(data[, crc])：计算的data 的32位校验和CRC- 32时，crc为初始CRC 。crc32与ZIP文件的校验和一致。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print binascii.crc32(&quot;hello world&quot;)</span><br><span class="line">222957957</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot;hello&quot;)</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot; world&quot;, crc) &amp; 0xffffffff</span><br><span class="line">&gt;&gt;&gt; print &#39;crc32 &#x3D; 0x%08x&#39; % crc</span><br><span class="line">crc32 &#x3D; 0x0d4a1185</span><br><span class="line">&gt;&gt;&gt; crc</span><br><span class="line">222957957</span><br></pre></td></tr></table></figure><h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><p>binascii.b2a_hex(data)和binascii.hexlify(data)：返回二进制数据的十六进制表示。每个字节被转换成相应的 2位十六进制表示形式。因此，得到的字符串是是原数据长度的两倍。 binascii.a2b_hex(hexstr) 和 binascii.unhexlify(hexstr)：从十六进制字符串hexstr返回二进制数据。是b2a_hex的逆向操作。 hexstr必须包含偶数个十六进制数字（可以是大写或小写），否则报TypeError。  </p><pre><code>&gt;&gt;&gt; s = &apos;hello&apos;&gt;&gt;&gt; b = b2a_hex(s)&gt;&gt;&gt; print b68656c6c6f&gt;&gt;&gt; a2b_hex(b)&apos;hello&apos;&gt;&gt;&gt; b = hexlify(s)&gt;&gt;&gt; print b68656c6c6f&gt;&gt;&gt; unhexlify(b)&apos;hello&apos;</code></pre><p>参考博客：<a href="https://www.jianshu.com/p/701960098b7a" target="_blank" rel="noopener">https://www.jianshu.com/p/701960098b7a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  &lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.kittener.top/categories/python/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>静态编译</title>
    <link href="http://www.kittener.top/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/"/>
    <id>http://www.kittener.top/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</id>
    <published>2020-03-24T12:20:32.242Z</published>
    <updated>2020-03-31T04:27:10.288Z</updated>
    
    <content type="html"><![CDATA[<p>今天由一道入群题入手之后了解到了静态编译这个知识：  </p><ul><li><a id="more"></a>  </li></ul><h3 id="1-静态编译："><a href="#1-静态编译：" class="headerlink" title="1.静态编译："></a>1.静态编译：</h3><p>编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，<br>使可执行文件在运行时不需要依赖于动态链接库.</p><h3 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2.动态编译:"></a>2.动态编译:</h3><p>动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一<br>方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p><p>然后静态库的连接与使用看<a href="https://www.cnblogs.com/xiaotianxiedaima/p/9824643.html" target="_blank" rel="noopener">这</a></p><p>IDA使用sig文件的说明看<a href="https://www.jianshu.com/p/7a1441e4f355" target="_blank" rel="noopener">这</a><br>但是我的libc.a是在/usr/lib/x86_64-linux-gnu下的并不是这篇博客的libx32下的<br>然后这道题好像因为glibc版本的关系，还是有一些库函数没被解出来，所以我被迫爆破出了flag…  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天由一道入群题入手之后了解到了静态编译这个知识：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://www.kittener.top/categories/re/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Diary</title>
    <link href="http://www.kittener.top/2020/03/21/kittener&#39;s%20blog/"/>
    <id>http://www.kittener.top/2020/03/21/kittener&#39;s%20blog/</id>
    <published>2020-03-21T11:45:42.966Z</published>
    <updated>2020-05-05T15:06:55.475Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="290e199acad66200eb3d0022e9e7606322a286a1095b6deec02f71a0ebdc78b4">638d200a7a6cc82e36cc5fe4837307bf2f1b2c0e755fa0341ce2aa62d621334ca03f47f0d1d23791e3c383e9c3c5299c0699a0325d9275d45ad0615f9d79a1f456850b84327df89dac6eb7ec5bc8f05b25879971126fb0b3e37254699e1af27abe27d0c4fda4d1e2d1454366e96bc8616f2a9b700ee381de8cebdf7490123091716a07b0ff8ad54771aa2f99a6e48e9d1e60afe0c4fdc77e1e4742363a0200716163f991198267ffcb3052e34c4ccb749051d227eb21eec619f09e9269cf606c22470e1eb0cd6811843959bb4c155136863ab6685af267a4849dec7688b3b6399deb9ec86eefdc1e70d086c9dab34d391010deac696aee1b4d38c6d18e1942dd3695290d9ce96ce24b883ba31bd49e439e0144324d81b27a9e20b08975fb3f79475e9a9d3ea1b650fc139abd05971fc89c353c784490d09fd67dcaea2bc8d1556d35cffa37bd4937a8ab872036b3fc90291448fa41049b965f32b10afb4df7e550b8a6b2d3dc52c2d6c26f6401e4df353f01e3ef97b6e594e09579e794c9e21ed99e9d4b71e90a535c8820e8bdd2e03ea93c9468ca6b99a6d28d1583c0799787cda60074849e0e3446e032de1fc4d474db50c7818be62e4baf892c413371effd03c5c65a7ebc7e439179a6754e05719b9e01fa5cae26523dfa4ea64b57d7a486c6a023596b0330ce2cefc0f566f03a6d451ebc41e3dd88ef4d9b860608128954dff88086364e9574a21655a975d7857130fdbc9bae6fc23902154f3ba47f40bc0f4349165bea34e57aa19f88bd72d6719393397aca9ecb7d0c54fb505ad5d5a5aba9d9a8ca92cffe4af76ad62e093e879b56d138a5d7b53e55ef7d24fbecc534031422708e6f678dcdb082de4b33e542fdc9325152bad46f65ffce0e0c94d4c7aae301cb5fca3ce99307eb39ad6f163e9918a689e1f2086af73b792bee815fdb03ede02ccfc5f84786227440a318b66b3890f3b793bcdf7dfd7439aaa269d3f0c02770c92cd662de08ef98839db2ba60cdfd491056c2ba094175bdf1cd5308b53113486e0ef93a3594a9bf29792bfcab4ba10b0dc816fa7e9ce6c2a0b25db76856a3da698968823b1eb8039e7b126823dc3badbbc6c7a022e0b6677a370907262a74ab3b4a930b82cce6a7ccef9fa2fcfc8269c2cb557884ba8adce1eb17430b1aae55bad0cff501a07b2203558d17bcd5564bb16706f0a13faa89ca79f7c416301a33c47259d548758c820e9532ec426b06c4af781a2efff58acb74ed504493584c0e087c59e80934b5004c5897c41bebd3d3d2bfe0aabb9fb38214dfb7229560e3616c25e4d066fa48ca197583ee4ae50ef6afa37b21084f049b36181c33200953172bd26d863d344eff7a1c975f1a0f28af0d989b89bf4bd565405e7b273222551b942b18e4fcc29ece69132c9fe2c78f844ef1ab40ab1167ad2797089d4aa5793952cfed4296ab8e488f7a4e70bf0c6b2e3f1b4939c9f5caf27ea6facbcd94419018eb1543488b853ca96d28e5f5e0c8c4b3652ca931c7877b591933fea338a8e8ec6aeaa38eb84b46c89fcf92291d1c7274d0382c5d586f019d05785a1a48e6e61511e28e361cb2174b532b8cd9b5156a66d036e4e188e840242ca4f91f9210f4c56d8148cb3a4475a09e2537a29cc7d0fc0a621f1a52a01166e074f5213eab1e951dc654a600c570e911d675ada4c0da88c88681486d946ea21786e26d9e04b657bb5bf114e6151941cd771771af082d80f9839f0a29888d39db4cc6205e7eab242027709aad2bff5513f704cf60a331b89c727458e68aee1f4598ff1ad826bdfdeaf507b038fab2b2bdfaaae14137cd633f58fd3c6bbe8b390792114a666b6b0f7cbb0b27e8c605914b3561b42fc469d680d8c12c9b95d57e3a05bbc1c994479ff64a4b39bbe74e5d1f261caf596255f144fd45de662254b84c316946ff5c439babf95ec79ce1e3d7c67d92d975369ea4b3ee53e8be0c7156df5b7e8ae7969044f28f7f338e81d05564df252ada33c5c9f114cfc238271fc2e95881e2d658897af7ba97021d1ed60fc6a710c17361975b2199252b6426f3ff8614c9c2da70a09176bba02f715ae72af18e337c0a216bb6bcd2ce49675322a170000a772778e60f2bce645a5c03209dd8ff373849e9373507637a8de5833cc9ea3bc078d5d3513f50ed9b86028c4ba9be43e840b6c3cbd17f8faa95ac2e211787452d191906e35577a141cb044424b03df6f208a24c4533cbb1a30c19c2bbccc753b4f6d698ba94ee5fee0d51af608c266aa9dd8de21a5f7b01a0e4264c798f2faba1d29eb972f4e3895d3d91f7c72399af449cda1e140c8ecd7e907e9a258fa2ccba15b271ac3f4e23bc6a2b7a77306070c2a508587b41ca684b8312fcc710bc0d7796eede8e954b8303b0d9a564d963a965bb494b558e8c5ad9c4f158e07858f94c7a5895a3541648d98a317ea115c2901da7dec9d401ea8cc0c0ad746ee9b7253e666f7dd768d8a0a0ce935b7241931d51dbdc0944b355ff09dd41b6848464136c16470ea117837be4115dcac6d31347b04518f1fa2adc08492bd5dfb4d10cb84b2a0e814772737e2c9e814466e62efa40ac3bb6d0df9e61769f48eca2aeac5542dc3d2066e0a21a944db5b314d9c22980a7bd482b7ff79544a0034e0c5849b6c591d579926459ca7e8114d206a58817d88803d834b4e7ede5d7611bf8a122b3bee581171dca2d0dc2bf6e3f963710fa3834f2f2375a66167489aeea159613d9d8cfa5651c7aeee13e9dc5e0b4bd0dc681422a2d182c41ab21eec77e2bfde40ca2241c14e63548df95e630bc0f670aec926dfffba04f558aefc5d9b9113b505e3836e0797b9df41fefc0db2d24ee9abffd7bae940ccb4e1a4c03cddd0f06763ee536bf48055e877e357d1b6f00e4645d5a4d04e6c371bb48ebdfc9afec146c93e0526300a2dc0012840bb6d661f216b28d8174237e9ae5b8fbb2e9aab04a259d774955b0fc84fd36dfec49978b8607981acb7d047b3d240b38b9236357931973ece042d5ce2041c81a94b36b0717458d6e411e3f9bf4bb0700547c8e3ec5360ab216b46e6f4552cc62685bc87ae73e9e85f128ab6de424a45413d2704bea3b3c4b8de38dcc2a82aa40124cd8cc40d8d97119b9664a31929dfa3bc85a8e838198a8299df9a732a00fff268342b3d04d5455987f61a115056639b64688a54c04f3f09cf59f8a737c73b0c6e9fb12383b800c537d9142d9774fa1a656331ab3aee794362e76b5bd92fb1b4b86ceb59b792e44986a28f1ac6f4321753ec7dcadae498eedd4d461960b0bdf187570081192b13f145f067ae392d7512bd5a4acf614ca037ec89838fb61fbbce3007786b75ad2bc9fc9f766c5da345134cb541bb102b5725fe96177cfd97bf82b11e95616c6c813a01f9623eff58e61a54214eeb80a9708f31aeef989492898ff2de5b8b16b92b6e8c154411e1f67b395b6df099c60ca6bd140a619a6a687cab3ea6c7563739a243a9f339e7321e4a425a99eda623d95a2b50b55ae7a0b0da9d0ab504349fb6d48a48205a61da8d99a38e531e564ed05c45cb4116892b2b14cef9772f7d45c5f93f6aa54bd0b9813528de423ea6a6bf1e1f497690d9e1e3c92826c306f09bf0c0ca7f32c08e156b9d55f23ca90ecc3161de234a8d44b480b74d6d9836fba55cd13b5ca981999ad3107f564cbd85fde400e009b49bb2bcc5183b0c17e1ebb56e6741349364439f177fd953fba10093274013a71edb155fa192ee8997e18b90e91c60cb69edd1dcd0a6fca670230e31895aba355fa73680be8bb89b642d35dea91c4b329b0f83551793e63f223e7bcb4b316b2ec5fd925e24e351aa1cbc66ccb58b5b8d62b4439eeb3ba134fd0acaf994ef696dd3731e605b36766a1a3892102d0895e8c02919044a244e188bce4c27d19d64ba0f42b4aa2e4a2ca7d87a7284e2833ec78cd5a54f827123469954df58a419b2e96f5ef702efcacfc366d6e9c41673635679a6d3aae52ee9ef0360f074910cd288cc7585028200affac4a457dd9d1cc2b2183eacf320fb416ec0aa28f48ca7db9c79c95fbf9a36fdb0b2bef7693048cb662e8db1351f9d75083d080c5374a0e9af302c7906702ba0f4d58ffd7fdff5e5fae483c9834b8c1915ebf5ba1015f8baafa09b3bd285e63c0bd6925e8defff9bc23e4435f302ca26686458c7a66e0d01da1c0d7aa7401543956b889e0b2e800428a8c5179d8707ae1e22523928c656a27fc96182771cfef7c6e3414d165671a28b77262374035183cb3848e9c97b3ffa41ba8cd4f331049f4d24e6d1617bad452f8ba7eb2cfb3b0ea3c847e5b5bdf893448e70e9ae749acb14e84a7c1c4d0e75666a8d291b972bfa2ab0d50b0049108092762b93e6114b13a5d93850712954f809dd81a774d31f6b7b2ba114580930cc4bbd22b1abddb2f342aeef9dee7f1fd727acbe6abae0722f1f0b690e3958948744319ab6f750f708654df740ba52c7d190c775d23a068800bc856d0238544f2ba3ef81aec2cc11962824d2436d08e05873ce3c3fbd4921c16d1356a9f5984abe3a4256c93a261836db169d6b2d17034581a2ba1decea7d512ebd1a0ff2bfc5415028607366d59a35f948ebc3c9b0c3ce2573723d8bed58050abb55c1c1b7be5f6f24eb24b8c53dcb38c26cec46fbae3467b44bcc93acdd8f2ec90af8e8f6b3048fa635e13c28aa55b6c2fc03c849a9961433fe714dc7695df9bd4a8c6ea075f7d384e7fabf2400c14c1e8df4d0d7a4a257aac418ac52acd698687ed67122e90d6aa1b32a878908b56802564ef458e7be471b0ce2cb90fa91d5de15233e4584f8ccab0a8d2fb2bbf631eb55c1898c76f469431c33b58fedd664e8d078fe833325b2c2d35c92a12ef015855c2a6024cd1b32c9e82dcce4d16bd0be5f4721943807df19ecc71a6fce792b16b2289e077bb62bf5828ac4246b6e87e11fa45fb8dd1be7eb10b6c9bc9e6500b04045483eba52eec239f18214e6877386723dd6883cdba1df32512933b67acc29fb27fb0f33210042c90496f6ed840d0343727befdf910808cae04fcf14f10d1e05e5b6e0fa12b03c367bd6045ea32d729bd711fda3725e11504f479676f66a144ee56d3a4b156ad4f26bc54f05653bcf2e4cb05e1ab13afa4ce68e6f6e8212e08bbdb5c2b8db2f6ee80ffe8423762244aead3639cb85b416245c4d0668920739a32ca2ce7e75f5be02c5d0afc55db3ce7ddb0b53a3b3fef8b52ae8043b40de4745fe88afa2b3c2bbc3ca35a8f625a146764b236b42af25bcc74cf95e1e39a4f880be4a2864402bae7bafb3303988a627ac3888e5c02ebd432afecf96abd930d85d251bd52521034164402960a5fb41cd6b26590b8f05d86f37b677674fb87ee5861e607963c5e17f0d95edfc01a6c289c9672f3f24e5a97b7e288e65f93bc00375aebd859845c6dba644ae9d4fed84818b560c2f67f47f3376433dee20a9fafc1ad2cf512288dec08170875f029486ff3b0785835db85c01300f2c1149ce6a813c63cf182b5cc37a839ba65bc938f71fe3d3b9343a9d7a1c72c87dc9a76b237961ffe2a7c4d2a2d7cfb8a88db6be6f898aa67fcf2f64c5bc83243b83c8cbbed370eef6f6fd00f19ca9fa1f07792deb46ca01c1f256e1f67227fa5909b3a2fa53d87fd9e6a3d5a4ec972a36e5486fc5a1d75a5a3cc1ca3611991b59751c570d6cdc71ac3b66d2adc83a764c746b86ce100a0a7893f944f43423901762f5fa8048741b89c45fe6e237900eca9d694490fba267782344d86e56a60fedb574f57605319cdc37b7cfee444707328055e002d89008607f73eb96f19f8dcd19627116d73ff414371fe26cfbd3e4e0d56a544e584bb8a05478041abb31a9d499c4daae107e56fb0d31d720a396c6cfdb5866195b19ecc2f949f403a10914d0dec35cabc51ad95dd3f26e09663b1d3a1241a631da8b9b0a6139c2f62dc6ed69809d9535f52a7761b07ba35a71635028d06dbbf1f375cb8ed13f8ce69641102eeff3b1d5ff67badee5696cadd6bacbbe2b666f3177bb91ab508eb137cc210b970ce4447ffe7b673f67453c820b75f88b7c985bcb8be930b38fadc502a5046d019d7cec1e3137eb3f4d2bf6a405680608c1ae528aeec61ee2568ae6e8fa11f1c827181ea007a6907cee6d897ade99f71db6ec029a95afadec2e8bce96476ab410676f2eec73d1c461d4a6d67e9f92ecf731e3d59b8a3de49bcd643ba805d9fed0bc974ccb51f47ba67327a14cf517fcc62173fe238f186d88d86d0aecc1e88491d7fa391b9b66f516948e11fea9a42461a8b92a9f9df27602e083e4cd06d5d0ea2302e462a91d30792cbdf8558b990f9d2b9ba4a85c4be449641935dd9a2679ada3d9828e805e9e4d5aa4c805861f3e367664418d948ccb66d2149ceb181f0817d74aba9cdfbdd790d089cc22f8c8273ed359d92562a144897b03b8c478dde3a0b386cfe38cbbab9253cf83dc1f51071a8a1b10dbc26a183e5bc983c297f299bffe96a75bd13f90c7f1cb6c1a099f47de3070d196416a58bd9186e381a10055fae79740b7c9b7d5916a4aac840cd1fddb12de19a7f808bb7c5802fb60dd6f5040a4facdf7d4a6b668ff3004a4e86a888f418a279c724296f5e705e50798076c623c5352ecab5ed5df08d5712e07c707ab1c6cf28b4a485de7c34169ab885692a11a5cfdbc87723b3949da69a60129a7a5dca22ad2d22ba6f3af4f4322331aa044484d2844e83120a44be99d0df1d7d1168306794d5388388b0e85be3221e6c7eb00e55df7714146681079a2e2a97b88d72678cb77666d27dc50c52d439af5fd4e389e4b521cf86c0530280dc50cc98f0c9f1be79049a5e372405b850aab61d7d7909e472e39c7a11781d6f45ea12275011089030ab21f6a44e0d3cfeaf318537a31739449afdad76171d2d16f1ec08b0b1d0c580a73ce89cfb1d61b8211e9a0fe64d5f425537b336acfcb752e159c49d3e12093e9b00b1ffe2de5dea43db4073541d0fd5adcd44110163a73e1c66625a60264be2d529f4d63bc3d3170ebbc61919c06c61e5deb9b77f7abb8af770c7688361ea6c2b8eb7b68f4bec3144095a2b5447acbee2b87d50494b8312c7aecfecd1978dee81ffa70dc84ea18bb585f77472f44ade7c4ad1af67ed3e05a6a4b8759791548f9380330e946298ca89ad3e576a4fc25e7b2d67a441ff750e7c8e85fe64725bc3bb682464a39ac4330dfbdc83300225fcf15875367a6d451d91b443bcd4da5f86096f059662eaeef2032db348ea1726b4a744421aa98bac454b6450460c32f1ca46be9c6848ce65cfc748c7d81726cdef6fae338e7d9cab52aaf894df46295ab662cfe876b5cafee6b01b7b1fc9bec00b72bc81c7e0c60dc7062a9241aab81144acd4717fc947bcbb24f2bf912be944f7ad4190cb1053074eefef60bdc2d15c6d6b74c819f311afcf75eb176eefc6593ae693adb1d4b528f728a6ad426ca345bcdf0248a959687a96304f721abb320ed9a4fc28d09dfea77b65bba88f1523772158883f3911657c987e917b0f81726368514a77be78ef27da7593f8b5de440c7707322acb7822fb709c4375095549a53c023bf77a33dbafd7e2e6f4035bf42bcb966b14291cb5c98112db56590e90c62759f6c658c9476aa01ec0a782ecf80d9429b3645349378e9434e405e0707fe7d0cfbb296f867107d8784f8110f6437817c48693a290883e58b845b7af406ab8d85f18debe121e311eb6cf91234117bdea2ef6647d4e4c0d1c75a5503e591a2ec773b0349c8fec256556e97e9ca624c71ca719501b7bf9fbb8c0492412a495872b5c21814048f2871efffff070a677a3aef0e2b14fbef2a66cb098a4549d85f9922b66ad5c63754bd976ae06ee92db8701ee244cfc998fb16fecb2c81db0b02b92768bf5cef4d4a19078cf082359b255ef5c494546ed5aa4266a8657f9daa3d7e68453ccbf2115bb94d884afa2f41acd0b0a14a12883e4005e51e1d2317a27f15b4dc96dc88b891acf73719cf4a66395c83b08b74e511ab9dfd8231a70500b0a742dd04d0543409100c67a8d42a074894a104fcdab75ac5f6c0727184b42baebbc75c341744ad5b90ab85b9ab873870ae71ad6db2220693cc7a2ec73c7a293df3b2dc1b2e7298edfe0f7d400f92c7fbb3b0b655ddebc2ce7694057748d131f3840b6e96092af16ac123c2644afb84b32a4ba8c92f88ea803d001e622ce69946101b069efac352a77146e3f7dfde5b9656fc0597e530183556bb9c33d3e4beaba4b6eb71294eb43e5130da7c4f7080c74636d9d414631ed5f34fc14e3f09a4e9364cca1794409047daeb7ff2ee8f4bc838c2d3ebafad4591395784f011c0e059ee0513607c5997965b9a14e7492ec5001bb37c0bb6336b1e22ec867aa2d0a73e12d4cb15d2b41cf7f1b0cc24ae4ae2d64f102ba98a0f27706d10a94c3ad6d12bc75fbd195c9bfdc11f72b6bd3fdad1fc83adf6cdcfe84b069ea19cc510902207ad8baeb98a6dc16b6cf18683a7ef213c1523afcbccd79f6302c3227c4046a977a0657e6e24455c720ad9e8379b7b3cb2492f8523a7733d8ca68e7fea1ee8ff5c124a25da1ccf9a673158c536d78c699511da81fb4c1a0d05bb4b104305bd853d6fc883605e8020bb1a3cdcd4637473e7b7405d448f01ecc5d4cc5f697f2b6d0af2bcabfa7a67c79a8758ecf554b7d233e6209805de7a8834d44e6420214997586634dfd4f846ad2dffa4122ac130f4ce80cdba07ca2e97e0d29063e5f5272ea6136174030dcbe9b9c898ca203c6558a50fd45adbc6c0b7acdba50d1f3e2385ffb2dc7d5823b4475106ae99a660d54607c47a6b24254ba2df3d4dde6734e4870b9b40b19238b2d440dd447ded19048565ea43821af246d23e05d3cb5761a528789c012f3bda475b1a15dae91bcba9155ccd2212e8782cd2e70e722e21442c41614d2d1e7a39bbd6a9104e1d5339007ed6557dd358f6bd864d1ac23e068c1d9f4bac48d4b798c8f630dc451f453126849ce25bae4285e726ad97ee2df57c1eacc602e967e39feb27685f4853ab8e90ace5405d5f94071f111cbf6b26366d44ca854edc4be87c64953819185e694a77cc3902da11737f0d1b7b932232ad24f5843b9f31e61f2be118311653967ae857e1232fa3e341f473e284ae013ea589d0c22ee5ab263debc8187f52dfe123f8d9abe0d6ce274c78a8854651a24a5a028df9c00e7a650e4550d963d9bbcbf446182b0253f513fac141ca76de23dd4a6ef9554f8a635d02a9fcbb59a296f64027db69ad458282584bba180dcc10bec00edc9bb331053c9c884437c44ef3c6780c52696e77a07b3132fae1bb927566ade4b367e06eddd6b538e0ffebae9641da1c805b384ffe05215ba72ec98206e68e003113d7ff58b0cbdfe8e5aa012f884486f8058eac3e8fd86ca91886989355bdba08a11d066805ca1a56e7edef56c49f19480ffd84357420152e7845d3e9d1a96dd8fcc2be020c60bdbb7878d5a8d3e7f69cf0ba673eb5a671d1fee64af191aa5b78847e1944bc27905541a691a0e0f9d0d4f297a6e3d7ac6a84aeec84045024b71a7db75a50b8388cc03c51c4b780f186c266814ceac50f648ddb178c3a4f4c9a0a290ad8660ec990d6445314168c52f9103e6da24cd0349234796a978aea0a3eaa852be86fb504c13664cf947bb070febeca103fb15a96325e98e050f6fb373d18265cf586c77ce51c97a252eadfbd01405464037a29f1f222ba1899250f3387e9a31fe8ea477d4a45f9d5e86fa05f8d258df879e79b56fa20ee2e6e03baf9c622cfabdf7c217453a075c33c21f293c4282c0a916d15e3e7ce53bcb3255840e8035029dcc1f76055053e2286bb3953c58f0dcda3c8aac8eebf8a7863b27c34627ee2536562a3ea1942294da5afdf1e8dac15e0efa8af1b12af1550506796636fcc9c2b6296249a05fa9f97454008d0490e0958ab0ec7f3b2468557d0639df9bf8e172143beb256cf4a973920e40c5c88cfa5f02ac53b07c3fc620231640252b73ab8b99940da14dbe62c21161879c1dce2bfd6bca3239f07a8589a2acd22693e0a5a12560b354061408e8910ae22f99c88e7921c3dc0aecc7cc6ec7ef71a51fad10ac4834d9053e529fea9a76117c058f71881b567dc0ffba7d3c33d93e24082e131e602b6b35e55b0027925814442b7361a838142bcc6ef3e37f67c4038bec3e19d3d2e425e82d4f10d8914cd630f0f3a24dd21abbf71902e34ba3633c753aaa32403685134b1d5c993d2bcb86403f32cdac9026ee0fd949d411843987a663b422d3d744d533149b5b6cdd0ed69e0f5f3274ad23e085dc31bae2021687a6fade2214f101447e3cdc149358add34d90958c27b1bf7475f3261375e5c394a860ffa1be2975f61d946a3ceafa560c7271c7fcdb3dcddce13836cd05af5ec0330365d2805995defe5b77906bcbbefe8ed3fe19d8fdd4ffd282bf15088f07106fa49010b1ce5590fddd08a7cb367bf3c0d09b284f52409fb886e88318ed6fb8fa771460b8bf88fec34fec7bc68db9a15b46d29aefc2340c71ba9427e1bd33978c82465b3e093b1cfbe327d427ef95634d3964c3d9f20ad8c200d0ee7bfec241887b5e80fd2205327cf6d7c7b98577f6b5502e8ff710083d77f70cb62aee8ae34064c1ac83c20b4e92cadbb67e467fd0380b7c4b15834f76918740bcb53aac08aa40234acbf9e8e31b5d0634303b0b62f2a38b19623fe801dc83e13a7c678fbb7dda67a5abcd538155cb7b5f41cb707092ff69171c9f878ad26826b19b751ec043a0fe3cc832aa61be6c13da42fde7c40fecc29607040f4269324c2e7cf1dde6884c3e29481b23043d03dd577a7d47f548e0c82971d68b4be23cb8cb5d89f9715cdf90cedc2d5cfd4557daad2af2f7bf7a01156703a280731b03b09432f82684ecedd854477e022402fba09792d5f644b20f897209c2e61920e932075390808323b8a295a3cfeb4cdee6c3f529d7bf30c40c06297b7ce0a92595acbf09f79de661e4faa02f2a3d36e4228da1cc5105b761a710a25de050edf3d42d821eb4999a34f3218a83b2cf41de28e964653e37dda7927f5ad9f792ada323e761bcb20f945e6bd7ae86edb2afec98f02f67378d494b74cd8b71d2fc8ffae2023ab341cb491173fb283ba6d7dc2f2b291fe83464604b5b9ff0ccb9522051c286d14a9c778a71bc1df4200a6713dc6442346f9621aaf09bc5412099a2a6d03d2537335e3bdbc11e31a3014876d7c4d46785816042b8b64d60b63e7075f8a3bde933ff7dba418302c4a86eb7a2a6ffb9e07ea2008a9362c4aefed5769774765af55f8b3080202ffc490553204b051d2c0007d7c3af4b6e457d55046e41e274e2115d265f1f0d6e9e53f3b2d4e4df0115161ebebaf56757b1790cb64bba20875a6ba3d89c2a02e6e3b0fd8d4513d3ba0ea42dd20e1582f0b4497c6944807b92020e92ba0c6881b7758b14eda6ba3e308a4804abc20cee8a1a4bf7abb4269c180055f4ab4b9530688dbfaf6b81e75c45741e03fd4c30e2540d4f581fe0b58a5dffded2b3fde5063e7a14b290f02601b2a307679520bd3666bf301e1ca5f721e56e2e69de2605226141cde73eb8cbd6a468179d5c3d446def051220fea311311ff0205de820862aa457413cb5dad6ac78090b27a93f267c67857097cf635e46bc9f2e5e9ff4737ef187bef9ab19557379e5aa930c88ddccc353ff5471d7a0d83ea1d18167bc73f2a1d76a34bd31348fb8dae13b1a66670b272bf1bcfc7f55b1f7c339aefd4ef1e0c9ba71ec4e11408af6972a92e015eaa8d67e8dd1028a7c1907521f91ba339dd16f6cb37e05348c76f1212f184a452c15b7cb7232ec2c8bbeba2110c3ade5d68f3dfa46ddb2ad66e133c6c58810822aeaf968525f1a9245db4f7b4dfa7041e5c3df5bc74542fd4c5127def0a59ad40177e956cea0dd3da8b428eb60086fdb082f206e8db262ad01be7798ad3ac718d1c7d6fc34ad6ef34d6c976c02a5cd15bb523374aba81c1d0b6e121929fe3bec23c127f59bc1e74c55266b5bd6d39bae8a9ed61e2f6ba937f9c025274e5b5b3d02c3c3802eae89cba7100b6a355d7726d81c39614e2659cb2a57760d882b90f21f77d735cd8164ab9d2acdcdb1927ca5f03a74f00d818d32efbff02c8aa20b12f9747553c9c3fea7e82f4829ed8d15fe0fd26386f062970838a28198bae6bd4272c75e52364fd5d6b1b5f50d954e762ac93e88794c6c3188006e0d828855890ad0fa9b012a67e98e327ed4e0493dcf14d1b9f3cd1621932211037af656f4c91408280e6271a59b19615fce7f2a699c144436ad2fe6863539e4bf05eff054796f14dfdf377773380ac74dcdcb9e2a6e7aaa2b2bb3287f559f6253261886ee744f6cf0b4d61a76652433614b2f839a0b6daa9a8f165133328e62f80a870c9770368702cb4a64cc394f690ff3a840c6b491c167021eb5590f4da7119510afcc45e1298f8530dff69051cbeb82a691f56964f32180e0bbdecd11cc27ee0c1aece0b4318c6c366ae0f1038ad679da9f53612eea1ee8c01b1b655b76f6f9c1fac0f895da651fedd1f5d83775fc636772ef76c211aae954414e8ca70d5aa5e58d513ca9630302829cc915f73d93b7266d705b66de45723fa9a35b4952190740f72376222d90fc174520422dd0b2a2e061014b787bca2c5ef2c57edc28fb21bbabd63e1f8dd68c8b5f439c80d711a315f77c6c7dd61771e0d4cb18c4c5327d49d597e93edcfac6b1dc3446d8b0a6d261569c1eece03dfe43fa3951ab514f6088629e092f05239c4189bfd08e6a3a8a1dabaf0b41574d6496a77d7ec922bc0a9f6cc164e4e16d35c805387f630e4fbe58770b76fd163f0d5cbd038979750d35d25da5ec589fcb69256f923dce301d612164f02fdde0b5dcc144ef3d4d625423106747ce7d59bcd65ca6252c5de870803dff2610aac929d48c19fc49b42f11694e2e816f8f12d868e1c72e5c30a1260bb24360ea61314e700d24ec7ca94111a0428d26f9affb609f1f853e9d5b599f46ce0123c475bd1ad780ad322d86cbbc363b34b2a88ecc1343337609f09dce361bb8c6d5d8b5a89d894d3c6a83fa9775ae0582c00e00216107499edcb094d115c7556d5a9eca7c547e6ff5266db5b728999fb131e5964013c0f7d4d17d89159ff56fb5bb91bb7983c8b239f216b16b4473e99e95866d4d0bbf5720b48f0e423e29b2798b5da419650c240ad6e8589caf0c12a4ce2ed15d33d3e81122b3a92cb62ba2b725a2c951535cc4264827deaff6f04b87df7f3e8f38d6c4425a9872f63a94c8005e043f4a9ab54a8586f3799729be84ee67cf0ebaa7b5c418f3c900a61a608032587bbcc4424bf2961d9905ef0e81269a8e6d1eef7b88b76b0a71c59f636958e052cd0570d168db142ff42738ce6705b179007d98e9e46ae524e83f1e370ee948b7137b67db32ec555f742983cacd853447817ebc1227ca652b79e6a2c6291539b1018c793681ba19b494ca573754721389864accfc1a91e957f8a2495e04b501cf3b1632afba9b14b6c7a809944e73f134c9285fc2b4d9ca67dfd11628607f0ca3cf43ffc1707adba2d39e2420bc163a4d4c9e31925abd43e0e811d0ed2c3ae0fa8a81ed26d3f9f3fd8febc6b2be594574f98706725bae6685d73cf59f481deb5940588b9778e02584dd650a4b7cbfea5f5ea241f9ce73689e92605ca689f1f83a3d8d9b2dabcaba60ce6b0efc40356fec3ccc75d5fb86c7a2218d84f05a81f6d1ffa33800cad49afe39a752e13a8b6867f85e6600f4d7bd111f7d5d10a891f1a72436d2ba0e883238f505255dccec7a0dcfe9a1fc5efec7e583725cec6a3dbed636a62b110109acf610a7cae001b538d29e80be8e858ec0f4636c5f3e1d19ba8644c47aee848b00be927e7229e9d7bd0a8728b34d902aee04d740356d7ef21795b88ea0e3342167d2c7af484f475c36c1c486cf39b60089a080b4df8693eb4529735ce164fd3f91018c222213769d766d12d6fedea4358845185868e4b9eb5a27c2fff7d7d69db5a5485aff0026ad30ce4e6a0ffadbbcdc20278eb12b3c777f630ecda3c920e48da65dec467e3f12599f69fe7bae1dfeee7f64d32b6770d355d837fcaa26f748caacc55012c105d1450df53d94da527c3237df69bf4b5d8ff51b97e1de95534e97644aab6e935da135b0e2058f46e5432da8a85ffdfd893d67def3ffbf9bb3f056dcdbe6c0fd07778b0bc46a749a37c8e598f98d352b47fa069b4b843eac1608d06f2912dedf6b0bfa5520e81e83ded882410d50a7a216eb2298b0f14e116019b013a853d0db6a8fefcd2eb07b57643975b2143c0bd7427e9c1cfb2dc93fe73846dd4b23cc6b9f5f64a98a1efb488eb0073971cce4d014503f4a1be2a7284582735d4d99842274c521228fc062ad570f58b26030372ccddcd3dc548c9d7208b9d1be7834ab4f1a72f4529d57ea7eee2f8762611e26d15c0efcde65a0f4d1ee06f988064c76da4532b6fdb8d7d446d9d5a72b0d2d48b8d68caba75289307513c1739cb38be302dc45fc3b7e499b23bfbf3f35e85d57d8a88be4774e857f5c148ff9285b5fe79c2bc3ba3a23959d760ff19dff4f3e86a8b4099b702434459c04b7d0536d7b9cdb3d9afa3e7a03086d7044619aa6c8cff448399b18fcdd19709614513868484b8bdce193a3e047c16f4f1b9cd826d4986a8a0f12cb98d598a4751e30b1c6c23100db34bc2e2aff9d232d9df146225f8851b5cfc54456fd4fa1e28101f169b9c86a35aa60d48ca41105ca7369e41bbd71cc1b72c17bbfaa3055e523e96ece30a1140518200865e6fc6e62a613333ef21a45f48b8dd98dd3827bc0ae773014bc6e5883c2245b98fe8b64145be49ae72ee1d88705fbdd4cd3055ff15ddaf623ea6ee6550cfff399b02276123fb207ae84f8a99586391717fa85d185a6495b54b75ccb37c9f5c1ca9b23788554d6d7777cf83ab06e613faeef966cfc050fc7a9e4cb2d19ac8a0c84a1109aa276face2f24d790c80ef92cfd1efbe0078ba37e8e1c11257542f683fd23f1eb3b9607f2d1ba9e77f4e6b140deed7eb10e1a09817ac3f09ce9e1dce627c3c3e4068c69c5015434409a1bcaf3455e005341c67d86b15c26c705d724fa037c451face49de3ecbc6f175150c666106edd8a5232abf50cfcc3c2523119796f5dc42837610576db703f82ec53f5a59eddecce592570ad0e3fd9670f1c3bed29b346abdc836824d8e85cd31297e75db233fe18674d9346eb4076d8daf7d76388a61315f022294ae23485f78f0755439a8836a4022b3de4d628a85e8100d17987e3cb1806e13fdfbc41a7300dadf4ab0071608753dffbcfffd21b3eecedae6142ebde5ffd1a1a1b6f807b7a1620aada48d755148de06b73dd3a2165423a7e2b7c739d7fe0ca095e039d3fd5ae861c80329b446665fed8ef7978507930b0e0a20ba37d7fbeaaefefb1836464aad7658567a549c106e13017fdd4774cddc9b4234a774945a0cdcd7d752f7f2c2317a955af43232f931d1720d07dd102fc5adba7c91f66899f4ff7abf33931b876e94d561a488649e5d32af304e4ac35436dd83e380c72cf6bf8a072a4104b64e56a6df3cdedba2fa2ba8fcefac7548fc3c8ce0db8620990678641149f67218e0e6457d8178fb3a0d2ed29ae4bcf39e06936223792f8a2dc7e8390e0fc7374092ff102c5c4711ef812092c58b6fab2a409b60177bf54b75d94dac1465fe15bc1f535fd738d5a3e8d7bdf4c152da072911996d37c33ed90f70401d0db13ec216c0525ca42217282a9f991debdcf7c73811ab7f3b27a55ffb725213f620ca1b3a6c3c2a7cd31498751b09c11b630d0f6da775b5e3ec849491bfa24f6a703314e64dea3e161795c42ba3fb5a0cfb855621dc5ed3849f2235c208e959d339b1d421a01d6184f064c46e63858cfe04fafcb34c7ae90db39aa3f06bf3bd254d5ad7a93d91d17b17a7f8707824a1b88103b34b23fbacb5453182ecee3240d9fc6f55a738041417b1dc558fff46c5c54e63ff4d3182026241a180f783d41165f1f06891b4d5bbb3348e414df0273c21cb7e93e66020f8ffb82c7f716a49a9e5f413426549e401e4412eccd30b6bc591d67d051b5c82684d2f85a9020c4b297fa1294030f865ae2ea86d500b483fba3dd46f7653d97941fafbfcd06280c6ac3074cfe7ae7e15bbe914757779132808ec32000c8cc21cbf3679dd0715c4eae7b86bd1020d00b6f94c274ae2a28e8f48cac6f029a73fc165e1f8ee62133a84572c4e5c6ed052a2e31430713df6c67f6817b07b8b823fb6325751191e4518101527b21242b62d5a2ac2d207536886476afd099ef1f13d21633286816352279b5ffd0a9c67a32a694cbc266ad4d9968f7b2375a65f19cbe3681ed15dab04116ae8ca64573800d544bafaf76aa66abf817173340b505fc080f48c667e673fed4d6b93c920a8aa03327ed6433dc369e815244b7cfc34197783c9289ad778e48eeb5b68c69094f62001f8a87f2e88554fc827b8921ef79fd25ebb7cbd30d6641030bd8258c36e3501a6b5fca1ba685b2ce913d6bf60fbe862a0b1295564bd4c49e560efff9509507d7cf7a39e942b45b78ee045b7610551572117c63191e5ef201c075120e22de0498d4d9516819c8d19b2331a476c8404197ab7763061e959fca974e5054f8ea182d41f1477b74157a79397d3baf04b184201dddef7114da97747f609484202f989a319cb2aa76032c8f2261df0e60549814a81a1c2524f72ca73b27f2334d2cc20ab0ffc9c85966f0b12188bacb8a5021a41eb0635ef6ee</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
    
      <category term="diary" scheme="http://www.kittener.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.kittener.top/2020/03/19/hello-world/"/>
    <id>http://www.kittener.top/2020/03/19/hello-world/</id>
    <published>2020-03-19T04:00:09.895Z</published>
    <updated>2020-03-31T04:08:06.030Z</updated>
    
    <content type="html"><![CDATA[<p>这里是我的blog，记录自己的学习足迹，日常吐槽的地方，欢迎大家一起交流学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是我的blog，记录自己的学习足迹，日常吐槽的地方，欢迎大家一起交流学习！&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
