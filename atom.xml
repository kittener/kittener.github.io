<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kittener&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kittener.top/"/>
  <updated>2021-10-14T09:27:57.238Z</updated>
  <id>http://www.kittener.top/</id>
  
  <author>
    <name>Kittener</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gdb调试手册</title>
    <link href="http://www.kittener.top/2021/10/14/gdb%E8%B0%83%E8%AF%95%E6%89%8B%E5%86%8C/"/>
    <id>http://www.kittener.top/2021/10/14/gdb%E8%B0%83%E8%AF%95%E6%89%8B%E5%86%8C/</id>
    <published>2021-10-14T02:14:23.000Z</published>
    <updated>2021-10-14T09:27:57.238Z</updated>
    
    <content type="html"><![CDATA[<p>elf文件一般采用gdb调试，但是gdb调试有很多技巧性，记录一下</p><a id="more"></a><ul><li><p>ctrl+x+a 进入TUI窗口</p><p>有源码的时候进比较好，不然啥也看不见</p></li><li><p>tbreak 临时断点</p><p>这类断点有效期限只到首次到达指定行时为止</p></li><li><p>watch (z &gt; 28) or wathc z  监视z的值</p></li></ul><h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><ul><li>info breakpoints 查看断点信息</li></ul><p><strong>有源码的情况下，可以指定断点</strong></p><ul><li>break function</li><li>break line_number</li><li>break filename:line_number</li><li>break filename:function</li></ul><p><strong>在无源码的情况下，可以这样指定断点</strong></p><ul><li><p>break *address</p><p>可用来在虚拟地址处设置断点</p></li></ul><p><strong>删除断点</strong></p><ul><li>delete breakpoint_list 删除断点使用树脂标识符</li><li>delete 删除所有断点</li><li>clear 清除GDB将执行的下一个指令处的断点</li></ul><p>禁用启用断点</p><ul><li>disable 3</li><li>enable 3</li><li>enable once breakpoint-list 该断点下次引起GDB暂停执行后被禁用</li></ul><p>有一种骚操作就是command 断点号</p><p>之后进行编程语句，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commands 1</span><br><span class="line">&gt;silent</span><br><span class="line">&gt;print ...</span><br><span class="line">&gt;end</span><br></pre></td></tr></table></figure><p>也可以定义宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)define print_and_go</span><br></pre></td></tr></table></figure><p><strong>继续执行</strong></p><ul><li><p>finish</p><p>一直运行直到当前栈帧结束</p></li><li><p>until</p><p>跳出当前循环</p></li></ul><h2 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch val</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;elf文件一般采用gdb调试，但是gdb调试有很多技巧性，记录一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>回忆录</title>
    <link href="http://www.kittener.top/2021/09/29/%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    <id>http://www.kittener.top/2021/09/29/%E5%9B%9E%E5%BF%86%E5%BD%95/</id>
    <published>2021-09-29T10:54:19.000Z</published>
    <updated>2021-11-17T11:01:47.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对于我大学生涯的小回顾"><a href="#对于我大学生涯的小回顾" class="headerlink" title="对于我大学生涯的小回顾"></a>对于我大学生涯的小回顾</h1><p>属于是最开始的心愿了结了吧，所以想写点什么，写的不好，可能会语无伦次，凑合看orz</p><h2 id="0-致谢"><a href="#0-致谢" class="headerlink" title="0.致谢"></a>0.致谢</h2><p>这一路走来真的磕磕绊绊，无数次迷失过方向，万幸受人恩惠，最后找到了一条出路</p><p>感谢我的战队指导老师刘淑娴老师，刘老师真的帮助我们解决了很多后顾之忧，可以没有包袱的去打比赛，除了几场实在拿不到奖的比赛（大概是网鼎杯和一些奇奇怪怪的比赛，我们都还算有不错的成绩，真的很感谢刘老师。</p><p>感谢我的班主任李伟和周宇老师，两位老师在我的学习和生活上真的帮助了许多，有些事情能得到很好的解决。感谢社团指导老师努尔布力老师和张琳琳老师，两位老师在社团的场地，项目的支持上真的令人动容(虽然最后场地被学校收回去了吧…)，但是给了我这个刚刚入门信息安全的人很多必要的帮助。感谢各位任课老师的倾囊相授，我真的学到了很多。</p><p>感谢信工所龚晓锐老师，没有老师我连夏令营都入不了。</p><p>感谢我未来的导师朱红松老师，希望能在老师手下学到更多的知识，见识更广阔的天地。</p><p>感谢我的余恩泽学长，带领我拿了第一个国奖，是我信安路上的引路人，常常教导我们不要骂人，非常的亲切和蔼，除了tmd把我扔进逆向的坑里再也不管我之外，还tmd打击我自信心说你这勾巴绩点肯定保不上之外，没啥不好的。我很想念他的嘴臭，有机会一定去东南看望他。</p><p>感谢我的史思博学长，在我比赛刚入门的阶段非但没有放弃我，还很看好我，除了有时候会有肢体上的交流，其他时间还是很友好的。即使到现在，还是作为xjusec的兜底王在一线战斗，嘴上说着不打，身体却很诚实。希望史学长能去到想去的单位，我也会很想念他的。</p><p>感谢我的高镭学长，我滴超人，永远滴神降临在了字节并带去了真理和漏洞。我们经常一起在实验室里看舞蹈视频，交流心得。除了pua我没啥大问题，相互嘴臭看谁先破防。希望他在杭州一切都好，能找到自己的爱情。</p><p>（…这三个人还嫌我写的不够多，草了。）</p><p>感谢XJUSEC的各位！现在能取得的成就离不开大家的共同努力，欢迎校内的小伙伴们加入我们呀~</p><p>感谢我的舍友万明江，虽然你有时候不做人，但还是很可靠的，没有万明江，可能我的大学生活要快乐减半了。很感谢他陪我度过的这三年。</p><p>感谢NepNep的各位小伙伴，感谢永远的hr观花，当初是她把我拉进去的，因为加入的时间早，所以面试可以说是没有，技术差没有被嫌弃还被收留至今，真是太好了。机机，我的超人！不多说了，铁血好兄弟，希望你在字节一切都好，等我去投奔你。Q神和B师傅，我心中的re王，真的跟他们学到很多，快虚脱了。其他nepnep的小伙伴也超级牛，非常激动能遇到你们，阿里嘎多。</p><p>感谢我的同学们，无论是高中同学还是大学同学，谢谢大家。</p><p>感谢我的爸妈，没有经济援助，活不到今天，也对我的选择全力支持，嘻嘻。</p><p>最后，感谢我的女朋友董兰兰哈哈哈哈，多的不说了，私聊。</p><h2 id="1-大一"><a href="#1-大一" class="headerlink" title="1.大一"></a>1.大一</h2><p>其实对于大一我还印象不多了。仔细回想还是有些记忆片段，因为学校实在是小，所以走的路太多次了也就习以为常，没有发现新大陆的惊喜也没有风花雪月的故事。刚入学时读的是化学专业，也没啥想法，因为高考实在太差，对自己的期望也没那么高，浑浑噩噩的度日子，想来，来这之前就对家里豪言壮语全当放屁，当时也实在没有斗志，再加上学生会工作也算小有成就，想着差不多就行了，这大学四年就这么过也挺好。</p><p>转变是在，2019年元旦的前一天晚上，那天晚上我将永远铭记。狗血的事情有很多种，我也遇到了其中一种。从那天晚上我就下定决心要改变这颓废的日子，在晚上给舍友说了大话还被嘲笑至今。之后就是重拾高中的底子(noip打铁选手)，本来想着去计科，奈何绩点实在拉跨，被调剂来了信安。说来这转专业还有点运气成分，真是，可以说是命运的选择了。</p><p>转过来第一件事就是看看有没有什么比赛可打，当时想着高中打比赛还挺快乐的，希望能在大学也继续打打，我对书本上的理论知识实在没什么天赋，动手能力还算可以，就想着通过比赛学习了。acm做了两场就不做了哈哈哈，实在是在数学上没有任何天赋，推导式看半天看不明白，一旦涉及到数论立马趴窝，想来自己实在做不了算法题了，就看看别的比赛了，条条大路通罗马嘛。</p><p>然后被拽去参加信安作品赛了，真的初生牛犊不怕虎，当时余恩泽带着我和毛臣两个大一的就参加了，第一次参加，感觉很新奇，找论文看，提出很多新奇的想法（然后被余恩泽无情否定。当时初步定了是在Linux系统上进行作品编写，让我对pcap流量包进行自动化分析和矩阵提取，然后我直接写了一大堆if语句差点把他送走（笑死，没办法当初只会面向过程，不懂面向对象。当初实在是不知道怎么把pcap包变成数字的集合，就各种上网找资料。最后查到源数据集的最初使用者的方法，终于是解决了。一瞬间成就感爆满，感觉自己无所不能~~然后就是编写文档，被余恩泽骂了好几次。嫌我写的简单，呜呜呜，从此对写文档深恶痛绝(?)好歹是勉强达到要求交上去了。</p><p>之后大一还参加了一次自治区内部的信息安全比赛，哈哈哈哈，这个实在是太有意思了，主要参加比赛的人都是对电脑一知半解的，然后比赛开始的时候他们都还不会用xshell连远程主机，我就很鸡贼的和毛臣“帮”他们登录了主机，并改了密码，所以导致他们一大部分人一整场比赛下来都没连上主机（罪过罪过。还记得那时候rdd刚刚失恋，比赛前一天跟我们说，明天没啥交流，他要自闭，然后比赛日他被我们操作逗乐了，放弃日站，跟着我们一起愉快抓“肉鸡”了。然后rdd通过一台主机上发现了残留的木马，我们就成功上了冠希哥的车车，还把司机踢下了车车，笑死。在这个阶段拿到了第一名好像是()，rdd真是太强了，渗透之神。总之就是非常快乐的拿到了一等奖，抱走了一个华为智能音箱（现在还在我家里发光发热呢。从此之后就对网络安全感兴趣了，没办法第一次体验太好了，就开始踏上一条不归路了。然后，tmd真正的比赛完全不是一回事(擦眼泪)，这都是后话了。</p><p>暑假就去南京的东南大学去参加作品赛的线下答辩啦。还记得在比赛前两天我才把系统调试好，可恶的余恩泽，参加完东南的夏令营就两腿一撇不管事了，美名其曰锻炼我的能力，其实就是懒。然后答辩的时候有点小插曲，我为了省电先把电脑关了，然后到演示的时候等了好久的电脑开启，场面一度很尴尬。。。现在还想给犯蠢的自己一巴掌。但是结果是好的！我拿到了人生中第一个国家级的竞赛奖项。</p><p>我想起来了一件事情！我过敏被自治区人民医院给误诊成水痘，给我无语死了。哈哈哈哈，万明江更惨一点，给他留点面子，我就不说了。</p><p>ps：然后跟女朋友讨论这篇文章的时候，还被提到了一个囧事，大一我和她第一次见面的时候我把她鸽了，从此对我印象很深刻（她觉得我是个铁憨憨），天啊撸，我感觉这个能唠叨我好几年了。</p><h2 id="2-大二"><a href="#2-大二" class="headerlink" title="2.大二"></a>2.大二</h2><p>大一下学期的时候，和学长一起打了ctf国赛。现在一想全是回忆啊（双手附后回忆青春状，还记得那时候有道misc是高数，大物的几个习题拼起来的，那时候好快乐啊hhh。然后大二上学期就开始琢磨这个比赛了（咳咳，不归路开始。</p><p>记得当初咱因为某种原因（余恩泽说，队伍里没有做re方向的，看我基础还行就让我去做），被迫入了reverse这个方向的大坑。最开始的时候接触真的一头雾水，看不懂题目，不知道要干嘛。最好笑的有一次是，elf文件，我运行了之后显示权限错误，我就跟rdd说这题太难了，都不能运行文件哈哈哈哈。其实chmod就好了，唉。没人指路，只能自己摸索，比赛的时候常常拖后腿，真的一道题都做不出来，每个周末都跟rdd一起打比赛，每个周末都做不出来题，每场比赛都在当时的一号楼702坐牢一整天，哈哈哈使劲拖rdd后腿，把他整无语了都，说实话我也有点无语。但还好rdd没放弃我，还是强行拽着我做题。</p><p>说实话心态不炸裂是不可能的，因为感觉真的不会做，题目太难了，而且一直练了很长很长时间的，我整个大二期间的休息时间都是扑在上面了，但是还是没有任何成果，而且还会每次比赛完都会收到小群里几位不做人的学长的“亲切问候”，可恶。还好我够不要脸(嘻嘻)，抗压王本人属于是，但是每次看到因为自己这个方向毫无贡献导致团队积分特别低的时候，说不沮丧是假的，记得快期末的时候，我去跟余恩泽说，如果下一场我还一道题都做不出来，我就不打比赛了。</p><p>感谢成都大学的校赛（鞠躬，阿里嘎多。完全是面向新手的，AK(全部解答)了。这场比赛就像黑暗中的一束光照在了迷途的黑雾中，给了我坚定的信心和一往无前的勇气。rdd夸了我呢(骄傲脸)，我也终于是得到了“救赎”，继续去钻研赛题去了。</p><p>因为在此之前因为我校实力确实孱弱，于是rdd和疆内其他高校的领头人说联合战队的事情，成立的很快，一起组队打了几场之后，发现和内地的强校确实差距还是很大，于是就无疾而终了，我们就另寻出路。一直在打比赛，一直没有拿奖，虽然老师学校没给什么压力，但还是觉得丢人。当时每日思索如何变强，如何能有所成就，在参加了一次南邮举办的NCTF之后，转机算是来了。</p><p>因为我本人还是有些社交属性的，就加了赛事官方群。当时做出来了三四道题，看到群里有人在组建联合战队，还是个妹子（，兴趣立马来了，一细问还是浙江那边的联合战队。我就心向往之了。高中的时候搞算法竞赛的时候，浙江省的实力是有所耳闻的，他们的计算机技术确实比我要好太多，没啥犹豫的就报名加入了。</p><p>感谢观花小姐姐（鞠躬，阿里嘎多，没嫌弃我是个菜逼就把我拉进队里了，为NepNep打call <del>可以说又是一个转折点吧，我在队里见到了很多很多很厉害的人，Q神，B师傅，机机等等。当时差距真的很大，所以有机会就暗戳戳的问他们怎么学的怎么分析的，真的学到了很多。再次为NepNep打广告 ~</del>跟着NepNep打比赛真的太快乐了233，我逐渐喜欢上了这项竞赛。</p><p>上半学期快结束的时候，因为702被收回去了，就只能窝在宿舍里打比赛，仔细想想好像没啥回忆，每天打比赛打比赛打比赛的。</p><p>下半学期真是风云突变啊，突然来了疫情，我们学校也是采取线上课程的形式。匆匆开学了，因为线上了，所以比赛也渐渐多了起来，打了好多好多场比赛，越来越赛棍了。</p><p>因为上半年就是在家躺尸上网课打比赛，没啥特别的记忆，还记得网鼎杯的初赛，我们被各种神仙从稳进线下赛锤到差十几名才能进，唉。当时真是非常沮丧，因为打比赛将近一年，从来没进过线下，好不容易有点希望，还被锤没了…</p><p>然后国赛拖到了暑假，初赛发挥的不错，成功进入了分区赛。当初就在想这是不是我快要实现目标的日子。因为校队实力确实有差距，我在大二刚刚开始打比赛的时候就对学长说，我大学本科期间，<strong>一定要进一次全国总决赛的线下赛</strong>！然后我把那次当作了我此生唯一一次的机会，重铸xjusec荣光，吾辈义不容辞！</p><p>然后就大二就结束啦~~</p><p>回忆满满的一学年啊~(茶)</p><h2 id="3-大三"><a href="#3-大三" class="headerlink" title="3.大三"></a>3.大三</h2><p>大三上半学期就回学校啦，回到学校就先和指导老师商量场地的事情，最后给我们划了计算机实验室的一部分当作比赛场地。</p><p>嗯…爆发了不小的冲突，具体原因不多说了，挺匪夷所思的。</p><p>书接上文，刚来到学校就是国赛的分区赛，比了两天，差一名进决赛…</p><p>我当时真的有点崩溃，欲哭无泪。但是我学长进了，也算成功吧…</p><p>唉，说不沮丧是假的，那能怎么办呢，继续努力吧，然后接着祥云杯，湖湘杯，我们都被临比赛结束二十分钟内疯狂上分的神仙给锤没了，我一个线下没进…看到别的师傅美滋滋的晒自己去线下的照片，真的很沮丧…</p><p>印象最深刻的是湖湘杯，从早上9点开始到实验室，然后一直打到晚上9点，到最后被锤没了，人是傻掉的。因为组委会要求，写完WP已经10点多将近11点了，浑浑噩噩的从实验室出来，欲哭无泪。自己慢慢踱步到操场上，拿起手机，苦闷不知道跟谁诉说。当时rdd已经全力备战考研了，这一级就我在做这场比赛，学弟们早就放弃了，真是拔剑四顾心茫然啊。走了两圈自己消化了就回寝室躺着了，跟万明江说今天又是白打工2333。</p><p>这是我最想放弃的瞬间之一，，说来挺没出息的，我就是想去次线下。。</p><p>颓丧了一段时间，真的挺难熬的，每次都差一点…还是跟自己和解了。不去关心结果，加油做好自己的事情吧。</p><p>然后不知道从什么时候开始，事情就迎来转机了，网鼎杯(大二下半学期打的)组委会说顺位到我们了，然后我们就跑去深圳啦！去深圳的旅途也是很坎坷，因为某些原因，南航取消了我们去北京大兴的航班，我们买的机票是中转的，到不了北京就去不了深圳，没办法，只能改签。到北京已是深夜，我们想找个地方住，没想到进了河北的某一个县里面…光是来回的打车费就200多。太坎坷了，流眼泪了。不过在深圳总归是见到了很多师傅，大型网友面基会23333，特别快乐，谢谢你网鼎杯。</p><p>铁三复赛也打进线下，去合肥又跟机机面基一次，非常快乐。去合肥来回坐了将近100个小时的火车…真给我坐吐了，我下火车的时候第一次有种亲吻大地的冲动。这次比赛是和rdd打的最后一场比赛了，还拿到了队史最好成绩，全国二等奖，只能说无愧于学长的栽培和老师的信任了。然后回来就因为合肥有病例被隔离了23333，被隔离的日子不愿在回想，实在是太过难熬。和刚刚谈一个月的女朋友分别的滋味想想就知道痛苦了。</p><p>哦对了，我谈恋爱了，哈哈哈。之前追过她，结果失败了，原因不想提，太丢脸了，现在终于成功啦，嘻嘻嘻。</p><p>在隔离期间，我再一次参加这一年的国赛（没错，就是这么顽强），毫无悬念的进分区赛了。分区赛的举办时间特别阴间…在我们期末考试的间隙，我上午考完试就得立马去机场赶飞机，而且兰州机场离市区真的远…到市区的时候都晚上10点多了，然后第二天7点起床。为了不耽误大家之后的考试，我们在第二天的比赛还没结束的时候就跟主办方说提前上交录屏，接着赶飞机。万幸到最后没有被踢出晋级的排名，踩着线进入全国总决赛了。</p><p><strong>至此，我开始打比赛的最初的目标终于实现。</strong></p><p>发入围名单那天也特别巧合，当时在姥姥家，我姥爷正给我们看他光荣在党50年的勋章，哈哈哈。然后就收到了通知，我们入围线下，哈尔滨见，哈工大见！去哈工大参加比赛的时候真的很开心，好像是所有的负担全部卸下，开始享受这场比赛了。虽然只拿到了国三，但我真的很开心，我感觉学弟们真的成长的很快。虽然我这个re手没啥参与感，被带飞2333。之后参加华为之夜也很开心<del>哈哈哈，除了飞飞提前回去之外，我们三个人都中奖了，我中了一个华为手环，nice</del></p><p>大三真是丰收的一年，仿佛之前所有的努力都得到了回报。</p><p>rdd也去了想去的公司（欢呼，考研离郑大分数线差一分，不过他只复习了两个月，我只能说，天才。</p><h2 id="4-保研"><a href="#4-保研" class="headerlink" title="4.保研"></a>4.保研</h2><p>我在刚入学的时候就以保研为目标而努力的。在跟余恩泽学长接触的过程中也坚定了自己的想法。看到史思博学长备战的时候的痛苦面具，我也就放弃了考研的想法（最后史思博上岸啦，欢呼~），就想着看看能不能保。</p><p>我的父母是期望我深造的，他们一直觉得学历高就好找工作，虽然事实跟他们想的有些出入，但还是影响了我。</p><p>以下这段话只代表个人观点~</p><p>但是在打比赛的过程中。我渐渐意识到学历不等于技术，求职过程中，技术的比重应该是更大一些，rdd就是我的偶像，所以我当时也犹豫了，再加上我确实对发论文比较打怵，就想着要是能工作就去工作吧。</p><p>但是在求职面试的过程中，我发现我还是太天真了。实际工作环境和工作需求和比赛完全是两码事，我在公司需求这个方向可以说是一无所知，我这两年完全就是个赛棍，还是个技术不咋地的赛棍。导致理想和现实偏差太大，简单来说，就是找不到工作，太菜了。。</p><p>面某厂的时候，面试官直接给我说，你这个方向我们这里都是研究生和博士生，你去读个研再说吧。唉，说不难过是假的，不是我不想，是真的找不到工作…</p><p>所以又把保研的念头捡起来，想着研究生这几年多学习学习，然后就去找有没有合适的导师了。</p><p>我本人对机器学习领域的前景感到悲观，但是现在的大方向就是机器学习，网安学院大部分老师也是把方向转向了和机器学习相关。奈何我的数学功底是真的不怎么样，我就很抗拒这个方向，漏洞挖掘的老师的名额可谓是一席难求。但我是一个绩点混子，四级分飘过，六级还没过的人，根本就没有得到强校初审通过的可能性。</p><p>所以只能另辟蹊径…因为余恩泽学长成功过，所以我在夏令营开始之前就开始和导师发邮件套磁。没想到的是…真的有老师回复我…</p><p>当时我正在被隔离，突然收到了一封邮件，意思是老师挺看好我的，然后可以给我一个机会！</p><p>天啊撸我太感动了，哈哈哈。感谢老师</p><p>然后夏令营投报的的时候也被西工大过初审了。西工大的考核就很简单，交一个socket通信的程序和说明文档就可以了。开心，向大家强烈安利西工大，老师们都很年轻，研究生后两年在江苏的太仓校区，感觉很有活力，特别nice。(但是我还是选择中科院信工所2333)果咩，西工大，谢谢你。</p><p>信工所的面试是三轮，英语面试，acm(ctf今年被取消了)，综合面试。英语面试没啥好说的，2分钟自我介绍+英语问答。我女朋友专门帮我准备英语，因为她本人也在准备雅思，就顺带着帮我了。呜呜，真的好好，让我跟着一遍遍读，纠正发音。英文问答我也是提前模拟，想老师会问什么问题，我该怎么回答，这些全部都背下来了。面试的过程也是意料之中，甚至老师问问题的语句都是我提前预判的，面试完我差点笑出来…哈哈哈。面完英语之后准备下午的机试，之前几年都是ctf or acm 但是今年不知道为什么突然强制变成acm，让我着实很慌。我就开始刷leetcode，打铁选手开始复建，很痛苦，没办法。幸好最后出的题也很简单，模拟，青蛙跳台阶和一个深搜。也是全都做出来啦，鼓掌👏。最后一项是综合面试，因为担心有龚导亲自面，我狠狠的准备了一下，给女朋友模拟了一边讲解ppt，被纠错后再来。真的很感谢她，帮助我了太多。结果龚导好像没有来2333，面试的老师都很年轻的，也是问了问比赛和项目就结束了。</p><p>最后也是拿到了总成绩第四！芜湖~！</p><h2 id="5-遗憾"><a href="#5-遗憾" class="headerlink" title="5.遗憾"></a>5.遗憾</h2><p>其实人的一生多多少少有些遗憾，但我一路走来，经历的多，也就来不及遗憾。</p><p>ummmm，还是说一下吧哈哈哈</p><ul><li><p>绩点</p><p>啊西，我的绩点真的比较低，这也就导致我夏令营入营前的初审被卡了非常多次，而且也必须错开绩点大佬报名的学校，一般都是他们入了，我没了。</p></li><li><p>英语</p><p>高中英语老师，果咩。我的英语真是一如既往的垃圾，六级考了两次还差20分才能过，下次一定。因为英语的原因，我的夏令营入营情况也很惨淡，包括预推免我都不敢再冲击华五了，英语真的很重要，切记切记。</p></li><li><p>逆向</p><p>也谈不上遗憾吧…但可能选择pwn的话，我会更容易找到工作些？也不一定，毕竟我实在是太菜了呜呜呜</p></li><li><p>技术</p><p>我曾跟着sakura师傅制定的目标学习了一段时间，原本打算继续学习直到具备一定的技术储备，奈何学校课程实在太紧，无奈放弃了，甚是可惜，现在在看着各位大师傅的知识树狂补中</p></li><li><p>感情</p><p>…如果不犯蠢的话，早就脱单了，大家一定要好好用心追求另一半啊。。。</p></li></ul><p>就先写到这里吧，总之，本科生涯真的很充实，我对我所经历的这三年时光感到骄傲和自豪。再次感谢路上与我同行，帮助过我的人，真的谢谢你们。也感谢那个，为了梦想，不断拼搏的自己。</p><p>​                                                                                                                            2021年9月19日</p><p>​                                                                                                                                于西安咸阳</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对于我大学生涯的小回顾&quot;&gt;&lt;a href=&quot;#对于我大学生涯的小回顾&quot; class=&quot;headerlink&quot; title=&quot;对于我大学生涯的小回顾&quot;&gt;&lt;/a&gt;对于我大学生涯的小回顾&lt;/h1&gt;&lt;p&gt;属于是最开始的心愿了结了吧，所以想写点什么，写的不好，可能会语无伦次
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾回收的算法与实现</title>
    <link href="http://www.kittener.top/2021/04/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.kittener.top/2021/04/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-14T11:21:50.000Z</published>
    <updated>2021-04-28T13:35:26.718Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收的算法与实现，实现篇目前先做python的，Dalvik和v8的当作个坑后续补</p><a id="more"></a><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p><img src="/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/P1.jpg" alt=""></p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>变量以及函数都用小写字母表示（例：obj）。常量都用大写字母表示（例：COPIED）。另外，本书采用下划线连接两个及两个以上的单词（例：free_list、update_ptr()、HEAP_SIZE）。</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><strong>对象</strong>：通过应用程序利用的数据的集合，由头(head)和域(field)构成</p><ul><li>头：对象中保存对象本身信息的部分<ul><li>对象的大小</li><li>对象的种类</li></ul></li><li>域：对象使用者在对象中可访问的部分<ul><li>指针</li><li>非指针</li></ul></li></ul><p><strong>children(obj)</strong> ：获取指向对象 obj 的子对象的指针数组，<strong>指针默认指向对象首地址</strong></p><p><strong>Mutator</strong>： 主要进行两种操作</p><ul><li>生成对象</li><li>更新指针</li></ul><p><strong>活动对象/非活动对象</strong> ：我们将分配到内存空间中的对象中那些能通过 mutator 引用的对象称为“活动对象”。反过来，把分配到堆中那些不能通过程序引用的对象称为“非活动对象”。也就是说，不能通过程序引用的对象已经没有人搭理了，所以死掉了。死掉的对象（即非活动对象）我们就称为“垃圾”。</p><p>死去的对象无法复活，无法通过Mutator找到死掉的对象，GC会清理死掉的对象</p><p><strong>分配</strong>：在内存空间中分配对象。当 mutator 需要新对象时，就会向分配器（allocator）申请一个大小合适的空间。分配器则在堆的可用空间中找寻满足要求的空间，返回给 mutator。当堆被活动对象占满时，有以下两种选择：</p><ul><li>销毁至今为止的所有计算结果，输出错误信息</li><li>扩大堆，分配可用空间</li></ul><p><strong>分块</strong>：为利用对象而事先准备出来的空间。内存里的各个区块都重复着分块→活动对象→垃圾（非活动对象）→分块→ …… 这样的过程。</p><p><strong>根</strong>：指向对象的指针的“起点”部分</p><h1 id="2-GC标记-清除算法"><a href="#2-GC标记-清除算法" class="headerlink" title="2 GC标记-清除算法"></a>2 GC标记-清除算法</h1><h2 id="2-1-什么是GC标记-清除算法"><a href="#2-1-什么是GC标记-清除算法" class="headerlink" title="2.1 什么是GC标记-清除算法"></a>2.1 什么是GC标记-清除算法</h2><p>GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。</p><h3 id="2-1-1-标记阶段"><a href="#2-1-1-标记阶段" class="headerlink" title="2.1.1 标记阶段"></a>2.1.1 标记阶段</h3><p>内存利用一般是堆，会递归标记指针数组能访问到的对象</p><p>将对象头部打上记号表示这是一个活动对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mark(obj)&#123;</span><br><span class="line">if(obj.mark &#x3D;&#x3D; FALSE)</span><br><span class="line"> obj.mark &#x3D; TRUE</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-清除阶段"><a href="#2-1-2-清除阶段" class="headerlink" title="2.1.2 清除阶段"></a>2.1.2 清除阶段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()&#123;</span><br><span class="line">sweeping &#x3D; $heap_start</span><br><span class="line"> while(sweeping &lt; $heap_end)</span><br><span class="line"> if(sweeping.mark &#x3D;&#x3D; TRUE)</span><br><span class="line"> sweeping.mark &#x3D; FALSE&#x2F;&#x2F;准备下一次的GC(实际的code应该不会这样干吧233)</span><br><span class="line"> else</span><br><span class="line"> sweeping.next &#x3D; $free_list&#x2F;&#x2F;加入free链(单向链表)</span><br><span class="line"> $free_list &#x3D; sweeping</span><br><span class="line"> sweeping +&#x3D; sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next 的域，我们只在生成空闲链表以及从这个空闲链表中取出分块时才会使用到它。没有必要为各个对象特别准备域，从对象已有的域之中分出来一个就够了。在本章中，next 表示对象（或者分块）最初的域，即 field1。也就是说，给 field1 这个域起个别名叫 next。这跟 C 语言中的联合体（union）的概念相同。</p><h3 id="2-1-3-分配"><a href="#2-1-3-分配" class="headerlink" title="2.1.3 分配"></a>2.1.3 分配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">chunk &#x3D; pickup_chunk(size, $free_list)</span><br><span class="line"> if(chunk !&#x3D; NULL)</span><br><span class="line"> return chunk</span><br><span class="line"> else</span><br><span class="line"> allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是malloc嘛（摊手</p><p>pickup_chunk() 函数用于遍历 $free_list，寻找大于等于 size 的分块。它不光会返回和 size 大小相同的分块，还会返回比 size 大的分块。如果它找到和 size 大小相同的分块，则会直接返回该分块；如果它找到比 size 大的分块，则会将其分割成 size 大小的分块和去掉 size 后剩余大小的分块，并把剩余的分块返回空闲链表。</p><p>这里再提一下立即适配，延后适配和最佳适配吧，贴一个网上的答案</p><ol><li><p>首次适应算法（First Fit）   </p><ul><li><p>算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。   </p></li><li><p>优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件；</p></li><li><p>缺点：（1）每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。            </p><p>​            （2）每次都是从低址部分查找，使得查找空闲分区的开销增大；  </p></li></ul></li><li><p>循环首次适应算法（Next Fit）  </p><ul><li><p>算法：分配内存时不是从链首进行查找可以分配 内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；    </p></li><li><p>优点：（1）使得空闲分区分布更加均匀；             </p><p>​            （2）空闲分区的查找开销小；</p></li><li><p>缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存；  </p></li></ul></li><li><p>最佳适应算法（Best Fit）  </p><ul><li>算法：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”。    </li><li>优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的； </li><li>缺点:产生大量难以利用的外部碎片。  </li></ul></li><li><p>最坏适应算法（Worst Fit）  </p><ul><li>算法：与最佳适应算法刚好相反，将空闲分区链的分区按照从大到小的顺序排序形成空闲分区链，每次查找时只要看第一个空闲分区是否满足即可。    </li><li>优点：效率高，分区查找方便；  </li><li>缺点：当小作业把大空闲分区分小了，那么，大作业就找不到合适的空闲分区。</li></ul></li></ol><h3 id="2-1-4-合并"><a href="#2-1-4-合并" class="headerlink" title="2.1.4 合并"></a>2.1.4 合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()&#123;</span><br><span class="line">sweeping &#x3D; $heap_start</span><br><span class="line">while(sweeping &lt; $heap_end)</span><br><span class="line">if(sweeping.mark &#x3D;&#x3D; TRUE)</span><br><span class="line">sweeping.mark &#x3D; FALSE</span><br><span class="line">else</span><br><span class="line"> if(sweeping &#x3D;&#x3D; $free_list + $free_list.size)</span><br><span class="line"> $free_list.size +&#x3D; sweeping.size</span><br><span class="line"> else</span><br><span class="line">sweeping.next &#x3D; $free_list</span><br><span class="line"> $free_list &#x3D; sweeping</span><br><span class="line"> sweeping +&#x3D; sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好嘛，free函数（摊手，但是实现的并不好</p><p>作者给的多链表的其实也是malloc的简单实现，建议大家码一遍CMU的malloc lab，我就不多写了</p><p>本章的几个优化方法，跟malloc lab的提分技巧大同小异，我就不做笔记了</p><h1 id="3-引用计数法"><a href="#3-引用计数法" class="headerlink" title="3 引用计数法"></a>3 引用计数法</h1><p>GC 原本是一种“释放怎么都无法被引用的对象的机制”。那么人们自然而然地就会想到，可以让所有对象事先记录下“有多少程序引用自己”。让各对象知道自己的“人气指数”，从而让没有人气的对象自己消失。</p><p>感觉好有意思~</p><h2 id="3-1-引用计数的算法"><a href="#3-1-引用计数的算法" class="headerlink" title="3.1 引用计数的算法"></a>3.1 引用计数的算法</h2><p><img src="P2.jpg" alt=""></p><h3 id="new-obj-函数"><a href="#new-obj-函数" class="headerlink" title="new_obj()函数"></a>new_obj()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">obj &#x3D; pickup_chunk(size, $free_list)</span><br><span class="line"> if(obj &#x3D;&#x3D; NULL)</span><br><span class="line"> allocation_fail()</span><br><span class="line"> else</span><br><span class="line"> obj.ref_cnt &#x3D; 1</span><br><span class="line"> return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，pickup_chunk() 函数的用法也大致与在 GC 标记 - 清除算法中的用法相同。不过这次当 pickup_chunk() 函数返回 NULL 时，分配就失败了。</p><p>在引用计数法中，除了连接到空闲链表的对象，其他所有对象都是活动对象。也就是说，在 pickup_chunk() 函数返回 NULL 那一刻，堆中就没有合适大小的分块了。</p><h3 id="update-ptr-函数"><a href="#update-ptr-函数" class="headerlink" title="update_ptr()函数"></a>update_ptr()函数</h3><p>update_ptr() 函数用于更新指针 ptr，使其指向对象 obj，同时进行计数器值的增减。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">update_ptr(ptr, obj)&#123;</span><br><span class="line">inc_ref_cnt(obj)</span><br><span class="line"> dec_ref_cnt(*ptr)</span><br><span class="line"> *ptr &#x3D; obj</span><br><span class="line">&#125;</span><br><span class="line">inc_ref_cnt(obj)&#123;</span><br><span class="line"> obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> if(obj.ref_cnt &#x3D;&#x3D; 0)</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> dec_ref_cnt(*child)</span><br><span class="line">  reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个点要注意，就是<code>inc_ref_cnt()</code> 和 <code>dec_ref_cnt()</code> 的调用顺序，这一点是为了处理 * ptr 和 obj 是同一对象时的情况。如果按照先 dec_ref_cnt() 后 inc_ref_cnt() 函数的顺序调用，* ptr 和 obj 又是同一对象的话，执行 dec_ref_cnt(*ptr) 时 *ptr 的计数器的值就有可能变为 0 而被回收。这样一来，下面再想执行 inc_ref_cnt(obj) 时 obj 早就被回收了，可能会引发重大的 BUG。因此我们要通过先对 obj 的计数器进行增量操作来回避这种 BUG。</p><p>这里有个卡我的点，记录一下，就是我不大明白这个update_ptr为什么要进行这种将对象赋值给指针的操作。看了看书，知道，这个是改变指针指向对象的操作，如果一个指向正在使用中的对象的指针被改变了，那么这个对象一定被放弃了。如图中的B：</p><p><img src="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CP3.jpg" alt=""></p><h3 id="“致命”缺点"><a href="#“致命”缺点" class="headerlink" title="“致命”缺点"></a>“致命”缺点</h3><p>这个算法，无法回收相互引用的对象</p><p>example：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123; </span><br><span class="line">string name</span><br><span class="line"> Person lover</span><br><span class="line">&#125;</span><br><span class="line">taro &#x3D; new Person(&quot;太郎&quot;)   #生成Person类的实例太郎</span><br><span class="line">hanako &#x3D; new Person(&quot;花子&quot;)   #生成Person类的实例花子</span><br><span class="line">taro.lover &#x3D; hanako#太郎喜欢花子</span><br><span class="line">hanako.lover &#x3D; taro#花子喜欢太郎</span><br><span class="line">taro &#x3D; null    #将taro转换为null</span><br><span class="line">hanako &#x3D; null#将hanako转换为null</span><br></pre></td></tr></table></figure><p>为两个对象互相引用，所以各对象的计数器的值都是 1</p><p>hhh，顺便说句题外话，日本人的土名也挺土的（</p><p>如何改进？</p><h2 id="3-2-延迟引用计数法"><a href="#3-2-延迟引用计数法" class="headerlink" title="3.2 延迟引用计数法"></a>3.2 延迟引用计数法</h2><p>简单来说，就是减轻计数器的增减处理，引入一个ZCT表</p><p>所谓ZCT表就是会记录下计数器值在<code>dec_ref_cnt()</code>函数作用下为0的对象。所以应该改进一下该函数。</p><h3 id="dec-ref-cnt-函数"><a href="#dec-ref-cnt-函数" class="headerlink" title="dec_ref_cnt()函数"></a>dec_ref_cnt()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> if(obj.ref_cnt &#x3D;&#x3D; 0)</span><br><span class="line"> if(is_full($zct) &#x3D;&#x3D; TRUE)</span><br><span class="line">scan_zct()</span><br><span class="line"> push($zct, obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就那样</p><h3 id="new-obj-函数-1"><a href="#new-obj-函数-1" class="headerlink" title="new_obj()函数"></a>new_obj()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line"> obj &#x3D; pickup_chunk(size, $free_list)</span><br><span class="line"> if(obj &#x3D;&#x3D; NULL)</span><br><span class="line"> scan_zct()</span><br><span class="line"> obj &#x3D; pickup_chunk(size, $free_list)</span><br><span class="line"> if(obj &#x3D;&#x3D; NULL)</span><br><span class="line"> allocation_fail()</span><br><span class="line"> obj.ref_cnt &#x3D; 1</span><br><span class="line"> return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scan-zct-函数"><a href="#scan-zct-函数" class="headerlink" title="scan_zct()函数"></a>scan_zct()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scan_zct()&#123;</span><br><span class="line">for(r : $roots)</span><br><span class="line"> (*r).ref_cnt++</span><br><span class="line"> for(obj : $zct)</span><br><span class="line"> if(obj.ref_cnt &#x3D;&#x3D; 0)</span><br><span class="line"> remove($zct, obj)</span><br><span class="line"> delete(obj)</span><br><span class="line"> for(r : $roots)</span><br><span class="line"> (*r).ref_cnt--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete(obj)&#123;</span><br><span class="line"> for(child : children(obj)</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> if((*child).ref_cnt &#x3D;&#x3D; 0)</span><br><span class="line"> delete(*child)</span><br><span class="line"> reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法…让我想起了计算机科学的万能法宝——中间层</p><h2 id="3-3-Sticky引用计数法"><a href="#3-3-Sticky引用计数法" class="headerlink" title="3.3 Sticky引用计数法"></a>3.3 Sticky引用计数法</h2><h2 id="3-7-部分标记-清除算法"><a href="#3-7-部分标记-清除算法" class="headerlink" title="3.7 部分标记-清除算法"></a>3.7 部分标记-清除算法</h2><h3 id="3-7-1-约定"><a href="#3-7-1-约定" class="headerlink" title="3.7.1 约定"></a>3.7.1 约定</h3><p>对象会被涂成4种不同的颜色来进行处理</p><ol><li>黑(BLACK) : 绝对不是垃圾的对象（对象产生时的初始颜色）</li><li>白（WHITE）：绝对是垃圾的对象</li><li>灰（GRAY）：搜索完毕的对象</li><li>阴影（HATCH）：可能是循环垃圾的对象</li></ol><h3 id="3-7-2-dec-ref-cnt-函数"><a href="#3-7-2-dec-ref-cnt-函数" class="headerlink" title="3.7.2 dec_ref_cnt()函数"></a>3.7.2 dec_ref_cnt()函数</h3><p>接下来，通过 <code>mutator</code> 删除由根到对象 A 的引用。这个引用是由 <code>update_ptr()</code> 函数产生的。跟以往的引用计数法一样，为了将对象 A 的计数器减量，在 <code>update_ptr()</code> 函数中调用 <code>dec_ref_cnt()</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> delete(obj)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line"> obj.color = HATCH</span><br><span class="line"> enqueue(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 obj 的颜色不是阴影的时候，算法会将其涂上阴影并追加到队列中。</p><h3 id="3-7-3-new-obj-函数"><a href="#3-7-3-new-obj-函数" class="headerlink" title="3.7.3 new_obj()函数"></a>3.7.3 new_obj()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line"> obj &#x3D; pickup_chunk(size)</span><br><span class="line"> if(obj !&#x3D; NULL)</span><br><span class="line"> obj.color &#x3D; BLACK</span><br><span class="line"> obj.ref_cnt &#x3D; 1</span><br><span class="line"> return obj</span><br><span class="line"> else if(is_empty($hatch_queue) &#x3D;&#x3D; FALSE)</span><br><span class="line"> scan_hatch_queue()</span><br><span class="line"> return new_obj(size)</span><br><span class="line"> else</span><br><span class="line"> allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当可以分配时，对象就会被涂回黑色。当分配无法顺利进行的时候，程序会调查队列是否为空。当队列不为空时，程序会通过 <code>scan_hatch_queue()</code> 函数搜索队列，分配分块。<code>scan_hatch_queue()</code> 函数执行完毕后，程序会递归地调用 <code>new_obj()</code> 函数再次尝试分配。</p><h3 id="3-7-4-scan-hatch-queue-函数"><a href="#3-7-4-scan-hatch-queue-函数" class="headerlink" title="3.7.4 scan_hatch_queue()函数"></a>3.7.4 scan_hatch_queue()函数</h3><p><code>scan_hatch_queue()</code> 函数在找到阴影对象前会一直从队列中取出对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scan_hatch_queue()&#123;</span><br><span class="line"> obj &#x3D; dequeue($hatch_queue)</span><br><span class="line"> if(obj.color &#x3D;&#x3D; HATCH)</span><br><span class="line"> paint_gray(obj)</span><br><span class="line"> scan_gray(obj)</span><br><span class="line"> collect_white(obj)</span><br><span class="line"> else if(is_empty($hatch_queue) &#x3D;&#x3D; FALSE)</span><br><span class="line"> scan_hatch_queue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果取出的对象 obj 被涂上了阴影，程序就会将 obj 作为参数，依次调用 <code>paint_gray()</code>函数、<code>scan_gray()</code> 函数和 <code>collect_white()</code> 函数（第 4 行到第 6 行），从而通过这些函数找出循环引用的垃圾，将其回收。</p><p>当 obj 没有被涂上阴影时，就意味着 obj 没有形成循环引用。此时程序对 obj 不会进行任何操作，而是再次调用 scan_hatch_queue() 函数。</p><h3 id="3-7-5-paint-gray-函数"><a href="#3-7-5-paint-gray-函数" class="headerlink" title="3.7.5 paint_gray()函数"></a>3.7.5 paint_gray()函数</h3><p>程序会把黑色或者阴影对象涂成灰色，对子对象进行计数器减量操作，并调用 paint_gray() 函数。把对象涂成灰色是为了防止程序重复搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paint_gray(obj)&#123;</span><br><span class="line"> if(obj.color &#x3D;&#x3D; (BLACK | HATCH))</span><br><span class="line"> obj.color &#x3D; GRAY</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> paint_gray(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CKittener%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210419204550063.png" alt="image-20210419204550063"></p><p>首先，在 (a) 中 A 被涂成了灰色。虽然程序对计数器执行了减量操作，但并不是对 A，而是对 B 的计数器进行了减量操作。下面在 (b) 中 B 也被涂成了灰色，不过这时程序并没有对 B 进行减量操作，而是对 C 进行了减量操作。在 (c) 中 C 被涂成灰色时，程序对 A 和 F 的计数器进行了减量操作。这样一来，A、B、C 的循环垃圾的计数器值都变成了 0。(d) 是 A、B、C、F 各个对象搜索结束后的样子。</p><h3 id="3-7-6-scan-gray-函数"><a href="#3-7-6-scan-gray-函数" class="headerlink" title="3.7.6 scan_gray()函数"></a>3.7.6 scan_gray()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scan_gray(obj)&#123;</span><br><span class="line"> if(obj.color &#x3D;&#x3D; GRAY)</span><br><span class="line"> if(obj.ref_cnt &gt; 0)</span><br><span class="line"> paint_black(obj)</span><br><span class="line"> else</span><br><span class="line"> obj.color &#x3D; WHITE</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> scan_gray(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打个比方，在图 3.11 这种情况下，程序会从对象 A 开始搜索，但是搜索的只有灰色对象。如果对象的计数器值为 0，程序就会把这个对象涂成白色，再查找这个对象的子对象。也就是说，A、B、C 都会被涂成白色。计数器值大于 0 的对象会被 paint_black() 函数处理。</p><h3 id="3-7-7-paint-black-函数"><a href="#3-7-7-paint-black-函数" class="headerlink" title="3.7.7 paint_black()函数"></a>3.7.7 paint_black()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paint_black(obj)&#123;</span><br><span class="line"> obj.color &#x3D; BLACK</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> (*child).ref_cnt++</span><br><span class="line"> if((*child).color !&#x3D; BLACK)</span><br><span class="line"> paint_black(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-8-collect-white-函数"><a href="#3-7-8-collect-white-函数" class="headerlink" title="3.7.8 collect_white()函数"></a>3.7.8 collect_white()函数</h3><p>回收函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collect_white(obj)&#123;</span><br><span class="line"> if(obj.color &#x3D;&#x3D; WHITE)</span><br><span class="line"> obj.color &#x3D; BLACK</span><br><span class="line"> for(child : children(obj))</span><br><span class="line"> collect_white(*child)</span><br><span class="line"> reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-9-限定搜索对象"><a href="#3-7-9-限定搜索对象" class="headerlink" title="3.7.9 限定搜索对象"></a>3.7.9 限定搜索对象</h3><p>部分标记 - 清除算法的优点，就是把要搜索的对象限定在阴影对象及其子对象，也就是“可能是循环垃圾的对象群”中。</p><p><img src="C:%5CUsers%5CKittener%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210419204451339.png" alt="image-20210419204451339"></p><p>部分标记 - 清除算法中用 <code>dec_ref_cnt()</code> 函数来检查这个值。如果对象的计数器值减量后不为 0，说明这个对象可能是循环引用的一份子。这时会先让这个对象连接到队列，以方便之后搜索它。</p><h1 id="4-GC复制算法"><a href="#4-GC复制算法" class="headerlink" title="4 GC复制算法"></a>4 GC复制算法</h1><p>简单来说就是复制能用的对象到另一块区域，然后把原区域全部清空。</p><p>copy函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line"> $free &#x3D; $to_start</span><br><span class="line"> for(r : $roots)</span><br><span class="line"> *r &#x3D; copy(*r)</span><br><span class="line"> swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$free 是指示分块开头的变量。首先在第 2 行将 $free 设置在 To 空间的开头，然后在第 3 行、第 4 行复制能从根引用的对象。copy() 函数将作为参数传递的对象 *r 复制的同时，也将其子对象进行递归复制。复制结束后返回指针，这里返回的指针指向的是 *r 所在的新空间的对象。</p><p>在 GC 复制算法中，在 GC 结束时，原空间的对象会作为垃圾被回收。因此，由根指向原空间对象的指针也会被重写成指向返回值的新对象的指针。</p><h2 id="4-1-GC复制算法是什么"><a href="#4-1-GC复制算法是什么" class="headerlink" title="4.1 GC复制算法是什么"></a>4.1 GC复制算法是什么</h2><h3 id="4-1-1-copy-函数"><a href="#4-1-1-copy-函数" class="headerlink" title="4.1.1 copy()函数"></a>4.1.1 copy()函数</h3><h1 id="python的垃圾回收机制"><a href="#python的垃圾回收机制" class="headerlink" title="python的垃圾回收机制"></a>python的垃圾回收机制</h1><p>ok终于来到重头戏，让我康康python的GC机制(标记清除法)到底是怎么回事吧</p><p>下载了跟书上一样python3.0.1的源代码（有时候研究实现机制并不需要最新版的</p><h2 id="10-1-对象管理"><a href="#10-1-对象管理" class="headerlink" title="10.1 对象管理"></a>10.1 对象管理</h2><table><thead><tr><th>结构体名</th><th>对应的内置数据类型</th></tr></thead><tbody><tr><td>PyListObject</td><td>列表型</td></tr><tr><td>PyTupleObject</td><td>元组型</td></tr><tr><td>PyDictObject</td><td>字典型</td></tr><tr><td>PyFloatObject</td><td>浮点型</td></tr><tr><td>PyLongObject</td><td>长整型</td></tr></tbody></table><p>直接康源码</p><p>浮点型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Include&#x2F;floatobject.h</span><br><span class="line">typedef struct &#123;</span><br><span class="line"> PyObject_HEAD</span><br><span class="line"> double ob_fval;</span><br><span class="line">&#125;PyFloatObject;</span><br></pre></td></tr></table></figure><p>PyObject_HEAD 定义如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Include&#x2F;object.h</span><br><span class="line">#define PyObject_HEAD PyObject ob_base;</span><br></pre></td></tr></table></figure><p>元组型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Include&#x2F;tupleobject.h</span><br><span class="line">typedef struct &#123;</span><br><span class="line"> PyObject_VAR_HEAD</span><br><span class="line"> PyObject *ob_item[1];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure><p>宏 PyObject_VAR_HEAD 的定义如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Include&#x2F;object.h</span><br><span class="line">#define PyObject_VAR_HEAD PyVarObject ob_base;</span><br><span class="line">typedef struct &#123;</span><br><span class="line"> PyObject ob_base;</span><br><span class="line"> Py_ssize_t ob_size; &#x2F;* 保持元素数量 *&#x2F;</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>看上去好像是定义了PyVarObject型的成员，但是还是定义了PyObject</p><p>那么这里就有一个问题，PyObject到底什么内容，上源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Include&#x2F;object.h</span><br><span class="line">typedef struct _object &#123;</span><br><span class="line"> _PyObject_HEAD_EXTRA</span><br><span class="line"> Py_ssize_t ob_refcnt;</span><br><span class="line"> struct _typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>ob_refcnt成员负责维持引用计数</p><h2 id="10-2-Python的内存分配器"><a href="#10-2-Python的内存分配器" class="headerlink" title="10.2 Python的内存分配器"></a>10.2 Python的内存分配器</h2><p>python的分配器很有意思，它不是简单的malloc，它是分层的</p><p><img src="E:/BaiduNetdiskDownload/P10-1.jpg" alt=""></p><p>如果生成一个字典对象，则会发生如下过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyDict_New()——3层</span><br><span class="line">PyObject_GC_New()——2层</span><br><span class="line"> PyObject_Malloc()——2层</span><br><span class="line"> new_arena()——1层</span><br><span class="line"> malloc()——0层</span><br></pre></td></tr></table></figure><h2 id="10-3-第0层-通用的基础分配器"><a href="#10-3-第0层-通用的基础分配器" class="headerlink" title="10.3 第0层 通用的基础分配器"></a>10.3 第0层 通用的基础分配器</h2><p>以 Linux 为例，第 0 层指的就是 glibc 的 malloc() 这样的分配器，是对 Linux 等 OS 申请内存的部分。</p><p>Python 中并不是在生成所有对象时都调用 malloc()，而是根据要分配的内存大小来改变分配的方法。申请的内存大小如果大于 256 字节，就老实地调用 malloc()；如果小于等于 256 字节，就要轮到第 1 层和第 2 层出场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">PyObject_Malloc(size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line"> block *bp;</span><br><span class="line"> poolp pool;</span><br><span class="line"> poolp next;</span><br><span class="line"> uint size;</span><br><span class="line"> &#x2F;* 这部分为异常处理，略去 *&#x2F;</span><br><span class="line"> if ((nbytes - 1) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line"> &#x2F;* 当申请的内存大小小于等于256字节时的内存分配(第1层和第2层) *&#x2F;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;* 当申请的内存大小大于256字节时的内存分配(第0层) *&#x2F;</span><br><span class="line"> return (void *)malloc(nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-第1层-Python低级内存分配器"><a href="#10-4-第1层-Python低级内存分配器" class="headerlink" title="10.4 第1层 Python低级内存分配器"></a>10.4 第1层 Python低级内存分配器</h2><p>假设我们有这样一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in range(100):</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>这段代码会使用大量一次性的小字符串，如果调用malloc()和free()这显然是我们无法接受的。</p><p>所以第1层和第2层的内存分配器会进行处理</p><h3 id="10-4-1-内存结构"><a href="#10-4-1-内存结构" class="headerlink" title="10.4.1 内存结构"></a>10.4.1 内存结构</h3><p>根据所管理的内存空间的作用和大小不同，划分为三级结构从大到小为arena、pool、block，三者为包含关系。</p><h3 id="10-4-2-arena"><a href="#10-4-2-arena" class="headerlink" title="10.4.2 arena"></a>10.4.2 arena</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct arena_object &#123;</span><br><span class="line"> &#x2F;* malloc后的arena的地址</span><br><span class="line"> uptr address;</span><br><span class="line"> &#x2F;* 将arena的地址用于给pool使用而对齐的地址 *&#x2F;</span><br><span class="line"> block* pool_address;</span><br><span class="line"> &#x2F;* 此arena中空闲的pool数量 *&#x2F;</span><br><span class="line"> uint nfreepools;</span><br><span class="line"> &#x2F;* 此arena中pool的总数 *&#x2F;</span><br><span class="line"> uint ntotalpools;</span><br><span class="line"> &#x2F;* 连接空闲pool的单向链表 *&#x2F;</span><br><span class="line"> struct pool_header* freepools;</span><br><span class="line"> &#x2F;* 稍后说明 *&#x2F;</span><br><span class="line"> struct arena_object* nextarena;</span><br><span class="line"> struct arena_object* prevarena;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>arena的大小固定为<strong>256k字节</strong></p><p>这里有个有趣的点，arena_object结构体不仅保存了malloc后arena的地址，还保存了开头pool的地址，按照常理来说，<em>这两个地址应该是一样的啊？</em></p><p>arenas数组管理arena_object</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 将arena_object作为元素的数组 *&#x2F;</span><br><span class="line">static struct arena_object* arenas &#x3D; NULL;</span><br><span class="line">&#x2F;* arenas的元素数量 *&#x2F;</span><br><span class="line">static uint maxarenas &#x3D; 0;</span><br></pre></td></tr></table></figure><p>然后让我们来看看uptr到底是啥吧，宏定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t Py_uintptr_t;</span><br></pre></td></tr></table></figure><p>简单来说，这个类型是整数型的一个别名，用来存放指针，会根据c指针的大小而变成4字节或者8字节，防止溢出。</p><h3 id="10-4-3-pool"><a href="#10-4-3-pool" class="headerlink" title="10.4.3 pool"></a>10.4.3 pool</h3><p>pool的大小固定在<strong>4K字节</strong>，因为对几乎所有OS而言，虚拟内存的页面大小都是4K</p><p>这样的话，就能让OS以pool来管理内存</p><p>所以说~arena和第一个pool的地址不一定相同，<strong>因为pool开头地址需要进行4k字节的倍数进行对齐。</strong></p><p>看一哈结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct pool_header &#123;</span><br><span class="line"> &#x2F;* 分配到pool里的block的数量 *&#x2F;</span><br><span class="line"> union &#123; </span><br><span class="line"> block *_padding;</span><br><span class="line"> uint count; </span><br><span class="line"> &#125; ref;</span><br><span class="line"> &#x2F;* block的空闲链表的开头 *&#x2F;</span><br><span class="line"> block *freeblock;</span><br><span class="line"> &#x2F;* 指向下一个pool的指针（双向链表） *&#x2F;</span><br><span class="line"> struct pool_header *nextpool;</span><br><span class="line"> &#x2F;* 指向前一个pool的指针（双向链表） *&#x2F;</span><br><span class="line"> struct pool_header *prevpool;</span><br><span class="line"> &#x2F;* 自己所属的arena的索引（对于arenas而言） *&#x2F;</span><br><span class="line"> uint arenaindex;</span><br><span class="line"> &#x2F;* 分配的block的大小 *&#x2F;</span><br><span class="line">  uint szidx;</span><br><span class="line"> &#x2F;* 到下一个block的偏移 *&#x2F;</span><br><span class="line"> uint nextoffset;</span><br><span class="line"> &#x2F;* 到能分配下一个block之前的偏移 *&#x2F;</span><br><span class="line"> uint maxnextoffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-4-4-new-arena"><a href="#10-4-4-new-arena" class="headerlink" title="10.4.4 new_arena()"></a>10.4.4 new_arena()</h3><p>先整体看一下new_arena()的大体部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct arena_object*</span><br><span class="line">new_arena(void)</span><br><span class="line">&#123;</span><br><span class="line"> struct arena_object* arenaobj;</span><br><span class="line"> if (unused_arena_objects &#x3D;&#x3D; NULL) &#123;</span><br><span class="line"> &#x2F;* 生成arena_object *&#x2F;</span><br><span class="line"> &#x2F;* 把生成的arena_object 补充到arenas和unused_arena_objects里*&#x2F;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;* 把arena分配给未使用的arena_object *&#x2F;</span><br><span class="line"> &#x2F;* 把arena内部分割成pool *&#x2F;</span><br><span class="line"> return arenaobj; &#x2F;* 返回新的arena_object *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>*</span></span><br><span class="line"><span class="class"><span class="title">new_arena</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">uint excess;<span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PYMALLOC_DEBUG</span></span><br><span class="line"><span class="keyword">if</span> (Py_GETENV(<span class="string">"PYTHONMALLOCSTATS"</span>))</span><br><span class="line">_PyObject_DebugMallocStats();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="comment">/*unused_arena_objects 指的是现在未使用的 arena_object 的单向链表，含有新生成的arena_object和已经使用过的、已废弃的arena_object*/</span></span><br><span class="line">uint i;</span><br><span class="line">uint numarenas;</span><br><span class="line"><span class="keyword">size_t</span> nbytes;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">maxarenas表示的是 arenas（所有的 arena 的数组）现在的元素数量，在初始时被定义成0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Double the number of arena objects on each allocation.</span></span><br><span class="line"><span class="comment"> * Note that it's possible for `numarenas` to overflow.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line"><span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_SIZE_T &lt;= SIZEOF_INT</span></span><br><span class="line"><span class="keyword">if</span> (numarenas &gt; PY_SIZE_MAX / <span class="keyword">sizeof</span>(*arenas))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        <span class="comment">/* 在第1个参数为NULL时，realloc与malloc相同 */</span></span><br><span class="line">arenaobj = (struct arena_object *)<span class="built_in">realloc</span>(arenas, nbytes);</span><br><span class="line"><span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">arenas = arenaobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We might need to fix pointers that were copied.  However,</span></span><br><span class="line"><span class="comment"> * new_arena only gets called when all the pages in the</span></span><br><span class="line"><span class="comment"> * previous arenas are full.  Thus, there are *no* pointers</span></span><br><span class="line"><span class="comment"> * into the old array. Thus, we don't have to worry about</span></span><br><span class="line"><span class="comment"> * invalid pointers.  Just to be sure, some asserts:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">assert(usable_arenas == <span class="literal">NULL</span>);</span><br><span class="line">assert(unused_arena_objects == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Put the new arenas on the unused_arena_objects list. */</span></span><br><span class="line"><span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            <span class="comment">/* 标记尚未分配arena */</span></span><br><span class="line">arenas[i].address = <span class="number">0</span>;<span class="comment">/* mark as unassociated */</span></span><br><span class="line">            <span class="comment">/* 只在末尾存入NULL，除此之外都指向下一个指针 */</span></span><br><span class="line">arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">       &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update globals. */</span></span><br><span class="line">unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">maxarenas = numarenas;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们把新分配的 arena_object 作为“未被使用的 arena_object”连接到一个链表。这</span></span><br><span class="line"><span class="comment">时 arena_object 结构体的成员 nextarena 是作为单向链表使用的。</span></span><br><span class="line"><span class="comment">除此之外，我们同时把 0 加入 arena_object 的成员 address 中。成员 address 里通常</span></span><br><span class="line"><span class="comment">包含指向 arena 的指针，不过在 arena_object 不持有 arena 的时候，将其明确设置为 0，使</span></span><br><span class="line"><span class="comment">用 arena 未被保留的标志。</span></span><br><span class="line"><span class="comment">最终我们将用单向链表连接的 arena_object 开头的指针存入 unused_arena_objects 中。</span></span><br><span class="line"><span class="comment">另外，我们把更新后的数组 arenas 内的 arena_object 的数量存入 maxarenas 里。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 取出未被使用的arena_object */</span></span><br><span class="line">arenaobj = unused_arena_objects;</span><br><span class="line">unused_arena_objects = arenaobj-&gt;nextarena; <span class="comment">/* 取出 */</span></span><br><span class="line">assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 分配arena（256K字节） */</span></span><br><span class="line">arenaobj-&gt;address = (uptr)<span class="built_in">malloc</span>(ARENA_SIZE);</span><br><span class="line"><span class="keyword">if</span> (arenaobj-&gt;address == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* The allocation failed: return NULL after putting the</span></span><br><span class="line"><span class="comment"> * arenaobj back.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">unused_arena_objects = arenaobj;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">++narenas_currently_allocated;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PYMALLOC_DEBUG</span></span><br><span class="line">++ntimes_arena_allocated;</span><br><span class="line"><span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">narenas_highwater = narenas_currently_allocated;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* pool_address &lt;- 对齐后开头pool的地址</span></span><br><span class="line"><span class="comment"> nfreepools &lt;- 对齐后arena中pool的数量 */</span></span><br><span class="line">arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">assert(POOL_SIZE * arenaobj-&gt;nfreepools == ARENA_SIZE);</span><br><span class="line">excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line"><span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">--arenaobj-&gt;nfreepools;</span><br><span class="line">arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">&#125;</span><br><span class="line">arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结构体 arena_object 的成员 pool_address 中存有以 4K 字节对齐的 pool 的地址。</span></span><br><span class="line"><span class="comment">在此使用 POOL_SIZE_MASK 来对用 malloc() 保留的 arena 的地址进行屏蔽处理，计算超</span></span><br><span class="line"><span class="comment">过的量（excess）。</span></span><br><span class="line"><span class="comment">如果超过的量（excess）为 0，因为 arena 的地址刚好是 4K 字节（2 的 12 次方）的倍数，</span></span><br><span class="line"><span class="comment">所以程序会原样返回分配的 arena_object。这时候因为 arena 内已经被 pool 填满了，所以可以通过计算 arena 的大小或 pool 的大小来求出 arena 内 pool 的数量。</span></span><br><span class="line"><span class="comment">如果超过的量不为 0，程序就会计算“arena 的地址 ＋ 超过的量”，将其设置为成员</span></span><br><span class="line"><span class="comment">pool_address。此时 arena 内前后加起来会产生一个 pool 的空白，所以要减去这部分，将其</span></span><br><span class="line"><span class="comment">设置为 nfreepools。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CP10-2.jpg" alt=""></p><p>hhh,这里我要记录一个点，被自己蠢到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b ? b &lt;&lt; 1 : 16;</span><br></pre></td></tr></table></figure><p>这段代码的意思是b如果为0的话a=16，如果不为0的话，a=b*2，这里a=b的判断是b的值(胡言乱语中)</p><h4 id="10-4-5-usable-arenas和unused-arena-objects"><a href="#10-4-5-usable-arenas和unused-arena-objects" class="headerlink" title="10.4.5 usable_arenas和unused_arena_objects"></a>10.4.5 usable_arenas和unused_arena_objects</h4><p>直接看源码吧~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unused_arena_objects</span><br><span class="line"> 将现在未被使用的arena_object连接到单向链表。</span><br><span class="line"> （可以说arena还未得到保留）</span><br><span class="line"> arena_object是从new_arena()内列表的开头取的。</span><br><span class="line"> 此外，在PyObject_Free()时arena为空的情况下，arena_object会被追加到这个列表的开头。</span><br><span class="line"> 注意：只有当结构体arena_object的成员address为0时，才将其存入这个列表。</span><br><span class="line">usable_arenas</span><br><span class="line"> 这是持有arena的arena_object的双向链表，其中arena分配了可利用的pool。</span><br><span class="line"> 这个pool正在等待被再次使用，或者还未被使用过。</span><br><span class="line"> 这个链表按照block数量最多的arena的顺序排列。</span><br><span class="line"> （基于成员nfreepools升序排列）</span><br><span class="line"> 这意味着下次分配会从使用得最多的arena开始取。</span><br><span class="line"> 然后它也会给很多将几乎为空的arena返回系统的机会。</span><br><span class="line"> 根据我的测试，这项改善能够在很大程度上释放arena。</span><br></pre></td></tr></table></figure><p>在没有能用的 arena 时，我们使用 unused_arena_objects。如果在分配时没有 arena，就从这个链表中取出一个 arena_object，分配新的 arena。</p><p>在没有能用的 pool 时，则使用 usable_arenas。如果在分配时没有 pool，就从这个链表中取出 arena_object，从分配到的 arena 里取出一个 pool。</p><p><strong>unused_arena_objects 是单向链表，usable_arenas 是双向链表。</strong></p><p>当我们采用 unused_arena_objects 时，只能使用结构体 arena_object 的成员 nextarena；而当我们采用 usable_arenas 时，则可以使用成员 nextarena 和成员 prevarena。</p><h2 id="10-5-第2层-Python对象分配器"><a href="#10-5-第2层-Python对象分配器" class="headerlink" title="10.5 第2层 Python对象分配器"></a>10.5 第2层 <strong>Python</strong>对象分配器</h2><p>第二层管理的是block</p><h3 id="10-5-1-block"><a href="#10-5-1-block" class="headerlink" title="10.5.1 block"></a>10.5.1 block</h3><p>有几个比较有意思的点记录一下</p><p>block的大小一定是8的倍数，这点毋庸置疑，相应的地址也一定是8的倍数(因为pool是按照4K字节来对齐的)</p><p>为什么要将 block 按 8 的倍数对齐呢？这是因为这样一来 block 的地址在 64 位 CPU 和32 位 CPU 中都不会出现问题。</p><p>分配的字节数会根据申请的字节数自动调节至最接近的8字节的倍数(高于)。</p><h3 id="10-5-2-usedpools"><a href="#10-5-2-usedpools" class="headerlink" title="10.5.2 usedpools"></a>10.5.2 usedpools</h3><p>Python 的分配器采用 Best - fit 的分配战略，即极力让分配的 block 的大小接近申请的大小。</p><p>搜索 pool 的过程必须是高速的。因为在每次分配时都会进行这项搜索处理。</p><p>秘诀在于usedpools中</p><p><img src="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CP10-3.jpg" alt=""></p><h3 id="10-5-4-block的状态管理"><a href="#10-5-4-block的状态管理" class="headerlink" title="10.5.4 block的状态管理"></a>10.5.4 block的状态管理</h3><p>block只有一下三种状态</p><ol><li>已经分配</li><li>使用完毕</li><li>未使用</li></ol><p>所有使用完毕的 block 都会被连接到一个叫作 freeblock 的空闲链表进行管理。block是在释放的时候被连接到空闲链表的。因为使用完毕的 block 肯定经过了使用→释放的流程，所以释放时空闲链表开头的地址就会被直接写入作为释放对象的 block 内。之后我们将释放完毕的 block 的地址存入 freeblock 中。这个 freeblock 是由 pool_header 定义的。我们将freeblock 放在开头，形成 block 的空闲链表。</p><p>未使用的block直接通过偏移量分配</p><h3 id="10-5-5-PyObject-Malloc"><a href="#10-5-5-PyObject-Malloc" class="headerlink" title="10.5.5 PyObject_Malloc()"></a>10.5.5 PyObject_Malloc()</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收的算法与实现，实现篇目前先做python的，Dalvik和v8的当作个坑后续补&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Frida学习笔记</title>
    <link href="http://www.kittener.top/2021/03/17/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.kittener.top/2021/03/17/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-17T10:12:55.000Z</published>
    <updated>2021-04-14T11:12:43.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单Hook"><a href="#简单Hook" class="headerlink" title="简单Hook"></a>简单Hook</h1><h2 id="调用原来的函数"><a href="#调用原来的函数" class="headerlink" title="调用原来的函数"></a>调用原来的函数</h2><p>example：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    String obj = editText.getText().toString();</span><br><span class="line">    String obj2 = editText2.getText().toString();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(obj) || TextUtils.isEmpty(obj2)) &#123;</span><br><span class="line">    Toast.makeText(LoginActivity.<span class="keyword">this</span>.mContext, <span class="string">"username or password is empty."</span>, <span class="number">1</span>).show();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LoginActivity.a(obj, obj).equals(obj2)) &#123;</span><br><span class="line">LoginActivity.<span class="keyword">this</span>.startActivity(<span class="keyword">new</span> Intent(LoginActivity.<span class="keyword">this</span>.mContext, FridaActivity1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        LoginActivity.<span class="keyword">this</span>.finishActivity(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.makeText(LoginActivity.<span class="keyword">this</span>.mContext, <span class="string">"Login failed."</span>, <span class="number">1</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] bArr)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> sb.toString().toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: private */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(String str, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(str2.getBytes(), <span class="string">"HmacSHA256"</span>);</span><br><span class="line">            Mac instance = Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">            instance.init(secretKeySpec);</span><br><span class="line">            <span class="keyword">return</span> a(instance.doFinal(str.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.FLAVOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果LoginActivity.a这个函数的返回值等于obj2，则通过验证，obj2为输入框的第二栏，所以我们只要看到obj经过运算后的结果就可以了</p><p>hook code：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> LoginActivity = Java.use(<span class="string">"LoginActivity(类名)"</span>);</span><br><span class="line">       LoginActivity.a.overload(<span class="string">'java.lang.String'</span>,<span class="string">'java.lang.String'</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">str,str2</span>)</span>&#123; <span class="comment">//有两个a，所以要通过指明变量个数指明是哪个a函数</span></span><br><span class="line">           <span class="keyword">var</span> result = <span class="keyword">this</span>.a(str,str2);<span class="comment">//调用原来的函数</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"LoginActivity.a:"</span>,str,str2,result);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><h2 id="不调用原来的函数"><a href="#不调用原来的函数" class="headerlink" title="不调用原来的函数"></a>不调用原来的函数</h2><p>example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a(b(<span class="string">"请输入密码:"</span>)).equals(<span class="string">"R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL="</span>)) &#123;</span><br><span class="line">            CheckSuccess();</span><br><span class="line">            startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, FridaActivity2<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            finishActivity(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.CheckFailed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接修改a的返回值就可以通过check了</p><p>hook code</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> LoginActivity = Java.use(<span class="string">"LoginActivity(类名)"</span>);</span><br><span class="line">       LoginActivity.a.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">barr</span>)</span>&#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="string">"R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL="</span>;</span><br><span class="line">       &#125;; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><h2 id="主动调用函数"><a href="#主动调用函数" class="headerlink" title="主动调用函数"></a>主动调用函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> LoginActivity = Java.use(<span class="string">"LoginActivity(类名)"</span>);</span><br><span class="line">LoginActivity<span class="function">.<span class="keyword">function</span>(<span class="params"></span>); //调用静态函数</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">        <span class="title">Java</span>.<span class="title">choose</span>(<span class="params"><span class="string">"当前类路径，类似于com.example..."</span>,&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            onMatch: function(instance</span>)</span>&#123;</span><br><span class="line">                instance.funcution; <span class="comment">// 调用函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            onComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><h2 id="主动设置变量的值"><a href="#主动设置变量的值" class="headerlink" title="主动设置变量的值"></a>主动设置变量的值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> LoginActivity = Java.use(<span class="string">"LoginActivity(类名)"</span>);</span><br><span class="line">       LoginActivity.static_var.value = <span class="literal">true</span>; <span class="comment">//改变静态变量值</span></span><br><span class="line">        </span><br><span class="line">        Java.choose(<span class="string">"当前类路径，类似于com.example..."</span>,&#123;</span><br><span class="line">            onMatch: <span class="function"><span class="keyword">function</span>(<span class="params">instance</span>)</span>&#123;</span><br><span class="line">                instance.var = <span class="literal">true</span>;</span><br><span class="line">                instance._var = <span class="literal">true</span>; <span class="comment">//若变量与函数重名，则前面加下划线</span></span><br><span class="line">            &#125;</span><br><span class="line">            onComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><h2 id="HOOK内部类的函数"><a href="#HOOK内部类的函数" class="headerlink" title="HOOK内部类的函数"></a>HOOK内部类的函数</h2><p>逻辑代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FridaActivity</span> <span class="keyword">extends</span> <span class="title">BaseFridaActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是private内部类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_java</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> InnerClass = Java.use(<span class="string">"FridaActivity$InnerClass"</span>);  <span class="comment">//$后面跟内部类名</span></span><br><span class="line">       InnerClase.check1.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>但是如果有多个check()函数的话，这样太不方便了，有没有可以获取所有函数的方法呢，答案是肯定的</p><p><code>getDeclareMethods()</code> 可以帮助我们获取所有函数的方法</p><p>然后再进行字符串截取拼接就可以了</p><h2 id="HOOK-动态dex"><a href="#HOOK-动态dex" class="headerlink" title="HOOK 动态dex"></a>HOOK 动态dex</h2><p>example如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractC0000CheckInterface <span class="title">getDynamicDexCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.DynamicDexCheck == <span class="keyword">null</span>) &#123;</span><br><span class="line">        loaddex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.DynamicDexCheck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loaddex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File cacheDir = getCacheDir();</span><br><span class="line">    <span class="keyword">if</span> (!cacheDir.exists()) &#123;</span><br><span class="line">        cacheDir.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String str = cacheDir.getAbsolutePath() + File.separator + <span class="string">"DynamicPlugin.dex"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(str);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            copyFiles(<span class="keyword">this</span>, <span class="string">"DynamicPlugin.dex"</span>, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.DynamicDexCheck = (AbstractC0000CheckInterface) <span class="keyword">new</span> DexClassLoader(str, cacheDir.getAbsolutePath(), <span class="keyword">null</span>, getClassLoader()).loadClass(<span class="string">"com.example.androiddemo.Dynamic.DynamicCheck"</span>).newInstance();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.DynamicDexCheck == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"loaddex Failed!"</span>, <span class="number">1</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">        e2.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举加载的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java.enumerateClassLoaders(&#123;</span><br><span class="line">onMatch: function(loader)&#123;</span><br><span class="line"></span><br><span class="line">&#125;,onComplete: function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>frida是不能Java use接口的，要先找到接口实现的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;, &#123;</span><br><span class="line">    onMatch: function (instance) &#123;</span><br><span class="line">        console.log(instance.getDynamicDexCheck().$className); &#x2F;&#x2F;$可以显示名字</span><br><span class="line">    &#125;, onComplete: function () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>找到名字就可以hook这个实现类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java.enumerateClassLoaders(&#123;</span><br><span class="line">onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">loader</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (loader.findClass(<span class="string">"com.example.androiddemo.Dynamic.DynamicCheck"</span>)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(loader);</span><br><span class="line">Java.classFactory.loader = loader;      <span class="comment">//切换classloader</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后进行hook check函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DynamicCheck = Java.use(<span class="string">"com.example.androiddemo.Dynamic.DynamicCheck"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(DynamicCheck);</span><br><span class="line">DynamicCheck.check.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"DynamicCheck.check"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HOOK-不同class的函数"><a href="#HOOK-不同class的函数" class="headerlink" title="HOOK 不同class的函数"></a>HOOK 不同class的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_FridaActivity6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> Frida6Class0 = Java.use(<span class="string">"com.example.androiddemo.Activity.Frida6.Frida6Class0"</span>);</span><br><span class="line">        Frida6Class0.check.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> Frida6Class1 = Java.use(<span class="string">"com.example.androiddemo.Activity.Frida6.Frida6Class1"</span>);</span><br><span class="line">        Frida6Class1.check.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> Frida6Class2 = Java.use(<span class="string">"com.example.androiddemo.Activity.Frida6.Frida6Class2"</span>);</span><br><span class="line">        Frida6Class2.check.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单Hook&quot;&gt;&lt;a href=&quot;#简单Hook&quot; class=&quot;headerlink&quot; title=&quot;简单Hook&quot;&gt;&lt;/a&gt;简单Hook&lt;/h1&gt;&lt;h2 id=&quot;调用原来的函数&quot;&gt;&lt;a href=&quot;#调用原来的函数&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IdaPython手册</title>
    <link href="http://www.kittener.top/2021/03/02/IdaPython%E6%89%8B%E5%86%8C/"/>
    <id>http://www.kittener.top/2021/03/02/IdaPython%E6%89%8B%E5%86%8C/</id>
    <published>2021-03-02T09:52:37.000Z</published>
    <updated>2021-03-02T16:57:07.457Z</updated>
    
    <content type="html"><![CDATA[<p>全网的IdaPython完整手册好少，做个记录  </p><a id="more"></a><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>这篇文章是根据《The Beginner’s Guide to IDAPython》翻译的，如果侵权，请联系作者删除</p><p>因为本人英文水平有限，如果有理解错的地方，欢迎来联系我邮箱 <a href="mailto:xkittener@gmail.com">xkittener@gmail.com</a></p><h1 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h1><h2 id="idc-get-operand-type-ea-n"><a href="#idc-get-operand-type-ea-n" class="headerlink" title="idc.get_operand_type(ea,n)"></a>idc.get_operand_type(ea,n)</h2><p>获取操作数类型</p><p>ea：当前地址，n：参数(指第几个操作数)</p><p>返回值：</p><ul><li>如果没有操作数，返回0，如retn</li><li>如果为寄存器，返回1</li><li>如果为内存引用，返回2，如<code>ds:dword_A152B8</code></li><li>如果为变址或/和基址寄存器，返回3</li><li>如果为基址寄存器+立即数，返回4</li><li>如果为立即数，返回5</li><li>如果为远地址，返回6</li><li>如果为近地址，返回7</li></ul><h2 id="idc-op-plain-offset-ea-n-base"><a href="#idc-op-plain-offset-ea-n-base" class="headerlink" title="idc.op_plain_offset(ea, n, base)"></a>idc.op_plain_offset(ea, n, base)</h2><p>将操作数变为偏移</p><p>ea：当前地址，n：参数，base：当前基地址</p><h1 id="Ida基本块"><a href="#Ida基本块" class="headerlink" title="Ida基本块"></a>Ida基本块</h1><p>基本块是一个没有分支的代码序列，由单个入口点和单个出口点组成。</p><h2 id="idaapi-FlowChart-f-None-bounds-None-flags-0"><a href="#idaapi-FlowChart-f-None-bounds-None-flags-0" class="headerlink" title="idaapi.FlowChart(f=None, bounds=None, flags=0)"></a>idaapi.FlowChart(f=None, bounds=None, flags=0)</h2><p>f参数需要func_t类，用<code>idaapi.get_func(ea)</code>获得该类</p><p>bounds：传递一个元组，包括开始与结束</p><p>flags：在ida7.4版本中，如果前驱块被计算，flags必须设置为<code>idaapi.FC_PREDS</code></p><p>返回值：</p><p>包含ida_gdl.FlowChart，内部包含所有遍历块</p><p>每个块都包含以下属性：</p><ul><li><code>id</code>，每个块都有独一无二的id号，第一块的id为0</li><li><code>type</code>，类型<ul><li><code>fcb_normal</code> 一个普通块，代表值为0</li><li><code>fcb_indjump</code> 块结束时间接跳转，值为1</li><li><code>fcb_ret</code> 块结束时用return，值为2。<code>ida_gdl.is_ret_block(block.type)</code>也可以识别这种块</li><li><code>fcb_cndret</code> 有条件判断的return，值为3</li><li><code>fcb_noret</code> 没有return，值为4</li><li><code>fcb_enoret</code> 没有return并且不属于任何一个函数，值为5</li><li><code>fcb_extern</code> extern普通块，值为6</li><li><code>fcb_error</code>  is a block that passes execution past the function end(翻译不出来了，估计是通过函数传递执行)，值为7</li></ul></li><li><code>start_ea</code> 块开头</li><li><code>end_ea</code> 块结束</li><li><code>preds</code> 返回所有全部前驱地址的生成器</li><li><code>succs</code> 返回所有全部后驱地址的生成器</li></ul><p>ps:preds和succs在给的例子中，中间的block块都给出了前驱后驱</p><p><a href="P1.png"></a></p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="idc-add-default-til-name"><a href="#idc-add-default-til-name" class="headerlink" title="idc.add_default_til(name)"></a>idc.add_default_til(name)</h2><p>加载TIL表</p><p>TIL表是ida对于C/C++结构独有的文件头，可以按(SHIFT+F11)导入不同的TIL表</p><p>返回值：</p><p>是否加载成功</p><h2 id="idc-import-type-idx-type-name"><a href="#idc-import-type-idx-type-name" class="headerlink" title="idc.import_type(idx, type_name)"></a>idc.import_type(idx, type_name)</h2><p>加载不同的定义</p><p>idx：每种type都有自己的id，若值为-1，则表示该加载type列表中的最后一个。因为加载项每次不固定，所以-1使用的很常见</p><p>一般有三种 <code>_TEB</code>, <code>PEB</code> and <code>PEB_LDR_DATA</code></p><h2 id="idc-get-struc-id-string-name"><a href="#idc-get-struc-id-string-name" class="headerlink" title="idc.get_struc_id(string_name)"></a>idc.get_struc_id(string_name)</h2><p>获取加载type的ID</p><h2 id="idc-op-stroff-ea-n-strid-delta"><a href="#idc-op-stroff-ea-n-strid-delta" class="headerlink" title="idc.op_stroff(ea, n, strid, delta)"></a>idc.op_stroff(ea, n, strid, delta)</h2><p>参数：</p><p>ea：包含偏移的指令，即将被加载</p><p>n：操作数数量</p><p>strid：需要用于将偏移量转换为结构体的type id</p><p>delta： the delta between the structures base and the pointer into the structure.(意思应该是结构体基址和指针的中间量)</p><h2 id="idc-del-struc-sid"><a href="#idc-del-struc-sid" class="headerlink" title="idc.del_struc(sid)"></a>idc.del_struc(sid)</h2><p>删除结构体</p><h2 id="idc-add-struc-index-name-is-union"><a href="#idc-add-struc-index-name-is-union" class="headerlink" title="idc.add_struc(index, name, is_union)"></a>idc.add_struc(index, name, is_union)</h2><p>创建一个结构体</p><p>index：新结构体的序号，最好是-1</p><p>name：名字</p><p>is_union：判断是否是union</p><h2 id="idc-add-struc-member-sid-name-offset-flag-typeid-nbytes"><a href="#idc-add-struc-member-sid-name-offset-flag-typeid-nbytes" class="headerlink" title="idc.add_struc_member(sid, name, offset, flag, typeid, nbytes)"></a>idc.add_struc_member(sid, name, offset, flag, typeid, nbytes)</h2><p>添加结构体成员</p><p>offset：一般都是-1</p><p>flag：数据类型</p><p>typeid：更多更复杂的定义(作者没说)</p><p>nbytes：分配的空间，和flag相匹配</p><h1 id="已枚举的Types"><a href="#已枚举的Types" class="headerlink" title="已枚举的Types"></a>已枚举的Types</h1><p>对于已经strip的常量，可以重新赋名</p><h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全网的IdaPython完整手册好少，做个记录  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>csapp第八章笔记</title>
    <link href="http://www.kittener.top/2021/02/09/csapp%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.kittener.top/2021/02/09/csapp%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-09T10:22:16.000Z</published>
    <updated>2021-02-14T10:05:47.191Z</updated>
    
    <content type="html"><![CDATA[<p>csapp第八章 异常控制流</p><a id="more"></a>  <h1 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h1><p><strong>异常</strong>就是控制流中的突变，用来相应处理器状态中的某些变化。</p><p>当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个简介过程调用(异常)，到一个专门设计来处理这类事件的操作系统子程序(异常处理程序)。</p><p><strong>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号。</strong>其中一些号码是处理器的设计者分配的，其他的是操作系统内核的设计者分配的。</p><p>检测到异常后，通过异常表间接调用。</p><p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊cpu寄存器中。</p><p>要注意的几点是：</p><ol><li><p>除了返回地址，处理器状态也会被压到栈里，x86会将包含当前条件吗的EFLAGS寄存器和其他内容压入栈中</p></li><li><p>如果控制从用户程序转移到内核，这些所有项目都会被压入内核栈中</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2></li></ol><table><thead><tr><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在可恢复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>终止</td><td>不可恢复的错误</td><td>同步</td><td>不回返回</td></tr></tbody></table><p>处理器提供了“syscall n”指令，当用户请求服务时使用。</p><p>内核中的abort例程会终止故障的程序。</p><h1 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h1><p>进程提供了两个关键抽象：</p><ol><li>一个独立的逻辑控制流，好像程序独占地使用处理器</li><li>一个私有的地址空间，好像程序独占地使用内存系统</li></ol><p>处理器通常是用某个控制寄存器中的一个模式位(mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。一旦设置了模式位，则进程就运行在内核模式中。</p><p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。该过程为：</p><p>异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。当它返回用户程序代码时，再变为用户模式。</p><h1 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h1><h2 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的PID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回它的父进程的PID</span></span><br></pre></td></tr></table></figure><p>pid_t = int</p><h2 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h2><p>当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就停止，并且保存直到收到SIGCONT信号，再开始运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><p>创建子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回:子进程返回0，父进程返回子进程的PID，如果出错，则为-1</span></span><br></pre></td></tr></table></figure><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>,++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent : x=%d\n"</span>,--x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent : x&#x3D;0</span><br><span class="line">child : x&#x3D;2</span><br></pre></td></tr></table></figure><p>这个例子有几个点：</p><ul><li>调用一次，返回两次<ul><li>fork函数一次返回到父进程，一次返回到新创建的子进程</li></ul></li><li>并发执行<ul><li>父进程和子进程是并发运行的独立程序。内核能够以任意方式交替运行它们的逻辑控制流中的指令。</li></ul></li><li>相同但是独立的地址空间<ul><li>地址空间是相同的，例如相同的本地变量值、堆、全局变量值和代码</li><li>但父进程与子进程对x所做的改变都是独立的</li></ul></li><li>共享文件</li></ul><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span>;<span class="comment">//如果成功，返回子进程的PID，如果WNOHANG，则返回0，其他情况-1</span></span><br></pre></td></tr></table></figure><p>在默认情况下(当options=0时)，waitpid挂起调用进程的执行(这里说的是调用该函数的进程，纠结了我一会)，直到它<em>等待集合</em>中的一个子进程终止。</p><ol><li><p>判定等待集合的成员</p><p>等待集合的成员是由参数pid来确定的：</p><ul><li>如果pid&gt;0，那么等待集合就是一个单独的子进程，它的id等于pid</li><li>如果pid=-1，那么等待集合就是由父进程所有的子进程组成的</li></ul></li><li><p>修改默认行为</p><p>可以用|来组合</p><ul><li>WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li><li>WUNTRACED：挂起调用进程的执行，直到等待集合中的进程变成已终止或者被停止。返回的PID为<strong>导致返回</strong>的子进程的PID。</li><li>WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行</li></ul></li><li><p>检查已回收子进程的退出状态</p></li></ol><p><a href="https://blog.csdn.net/yiyi__baby/article/details/45539993" target="_blank" rel="noopener">https://blog.csdn.net/yiyi__baby/article/details/45539993</a> 这篇blog有些许补充</p><h2 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">const</span> <span class="keyword">char</span> *argv[],<span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;<span class="comment">//如果成功不返回，如果错误则返回-1</span></span><br></pre></td></tr></table></figure><p>记录一下老生常谈的问题</p><p>main函数有3个参数</p><ul><li>argc，给出argv[]数组中非空指针的数量</li><li>argv，指向argv[]数组中的第一个条目</li><li>envp，指向envp[]数组中的第一个条目</li></ul><p>Linux中给了几个函数来操作环境数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;<span class="comment">//若存在则返回指向value的指针，若无匹配的，则返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *newvalue,<span class="keyword">int</span> overwrite)</span></span>;<span class="comment">//若成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure><h1 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h1><p>信号就是小消息，它通知进程系统中发生了一个某种类型的事件。</p><p>一个发出而没有被接收的信号叫做待处理信号(pending signal)。在任何时候，一种类型至多只会有一个待处理信号。再来的直接被丢弃。</p><p>进程可以自行选择阻塞某种信号，信号被阻塞后依然可以被发送，但除非进程取消阻塞，否则一直不会被接收。</p><p>内核为每个进程在pending位向量中维护着待处理信号的集合，在blocked位向量中维护着被阻塞的信号集合。传送就设置，接收就清除。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的进程组PID</span></span><br></pre></td></tr></table></figure><p>一个子进程和它的父进程都属于一个进程组，一个进程可以通过使用setpgid函数来改变自己或其他进程的进程组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pig_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p>如果进程15213是调用进程，那么setpgid(0,0)则会创建一个新的进程组，进程组ID为15213，并把进程15213加入到这个新的进程组中。</p><p><strong>还可以用/bin/kill发送信号(Linux终端)</strong></p><p>用kill函数发送信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功返回0，若错误返回-1如果pid&gt;0：kill函数发送sig给进程pid</span></span><br></pre></td></tr></table></figure><p>如果pid=0：kill函数发送信号给调用进程所在进程组中的每个进程</p><p>如果pid&lt;0：kill函数发送信号给进程组|PID|(PID的绝对值中的每个进程)</p><p>用alarm发送信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;<span class="comment">//返回前一次闹钟剩余的描述，若没有设置闹钟，则返回0</span></span><br></pre></td></tr></table></figure><h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程p从内核模式切换到用户模式时，会检查p的未被阻塞的待处理信号的集合(pending &amp; ~blocked)。</p><p>每个信号都有默认行为，但是可以通过<em>signal函数</em>修改这种行为，但是，<strong>SIGSTOP和SIGKILL</strong>不能被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighander_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighander_t</span> handler)</span></span>;<span class="comment">//若成功返回指向前次处理程序的指针，若失败返回SIG_ERR</span></span><br></pre></td></tr></table></figure><ul><li>如果handler是SIG_IGN，那么忽略的类型为signum的信号</li><li>如果handler是SIG_DFL，那么类型为signum的信号行为恢复为默认行为</li><li>否则，handler就是用户定义的函数的地址，这个函数被称为<em>信号处理程序</em>，只要进程就收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做<em>设置信号处理程序</em>。调用信号处理程序被称为<em>捕获信号</em>。执行信号处理程序被称为<em>处理信号</em>。</li></ul><h2 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h2><p>应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，否则-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//若signum是set地成员则为1，不是则为0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>how的值可以为：</p><ul><li><p>SIG_BLOCK：把set中的信号添加到blocked中(blocked=blocked | set)。</p></li><li><p>SIG_UNBLOCK：把blocked中删除set中的信号(blocked=blocked &amp;~set)。</p></li><li><p>SIG_SETMASK：block=set</p></li></ul><p>各个函数的作用：</p><p>sigemptyset初始化set集合为空。</p><p>sigfillset函数把每个信号都添加到set中。</p><p>sigaddset函数把signum添加到set。</p><p>之后就是关于并发编程的了，看的模模糊糊的，准备看完12章再来复习一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csapp第八章 异常控制流&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Pwn堆的学习历程</title>
    <link href="http://www.kittener.top/2021/01/28/Pwn%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <id>http://www.kittener.top/2021/01/28/Pwn%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</id>
    <published>2021-01-28T00:59:47.000Z</published>
    <updated>2021-01-28T01:37:22.855Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于pwn堆的知识很多，但大多很杂乱，新手入门完全不知道如何去进行一个较为系统的学习，我在此记录一下我的学习历程，希望对看到这篇blog的你有所帮助</p><a id="more"></a><h1 id="0-关于Malloc和free"><a href="#0-关于Malloc和free" class="headerlink" title="0. 关于Malloc和free"></a>0. 关于Malloc和free</h1><p>在C语言中，分配内存是用malloc或者calloc函数进行分配，对于源码的掌握一定要很好</p><p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</a></p><p>这是一份源码网站，非常的不错</p><p>两个讲malloc和free的帖子，感觉还挺通俗易懂的(主要是有图)</p><p><a href="https://blog.csdn.net/vivitue/article/details/78266839" target="_blank" rel="noopener">https://blog.csdn.net/vivitue/article/details/78266839</a></p><p><a href="https://www.cnblogs.com/zzdbullet/p/9635318.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzdbullet/p/9635318.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于pwn堆的知识很多，但大多很杂乱，新手入门完全不知道如何去进行一个较为系统的学习，我在此记录一下我的学习历程，希望对看到这篇blog的你有所帮助&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://www.kittener.top/categories/CTF/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++复健行动</title>
    <link href="http://www.kittener.top/2020/11/17/C-%E5%A4%8D%E5%81%A5%E8%A1%8C%E5%8A%A8/"/>
    <id>http://www.kittener.top/2020/11/17/C-%E5%A4%8D%E5%81%A5%E8%A1%8C%E5%8A%A8/</id>
    <published>2020-11-17T13:42:52.000Z</published>
    <updated>2020-11-19T14:00:30.475Z</updated>
    
    <content type="html"><![CDATA[<p>代码能力越来越差了，刷leetcode复健一下，顺便记录一下C++ STL的一些用法</p><a id="more"></a>  <h1 id="2020-11-17"><a href="#2020-11-17" class="headerlink" title="2020-11-17"></a>2020-11-17</h1><h4 id="1030-距离顺序排列矩阵单元格-难度：简单"><a href="#1030-距离顺序排列矩阵单元格-难度：简单" class="headerlink" title="1030. 距离顺序排列矩阵单元格  难度：简单"></a><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">1030. 距离顺序排列矩阵单元格</a>  难度：简单</h4><p>题目描述</p><p>We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.</p><p>Additionally, we are given a cell in that matrix with coordinates (r0, c0).</p><p>Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.)</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0</span><br><span class="line">Output: [[0,0],[0,1]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1]</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2</span><br><span class="line">Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]</span><br><span class="line">There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</span><br></pre></td></tr></table></figure><p>Note:</p><p>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order" target="_blank" rel="noopener">https://leetcode-cn.com/problems/matrix-cells-in-distance-order</a></p><p>很简单的逻辑，用结构体随便写.jpg，但是这里要用到vector这个STL，不是很熟，写的很痛苦，贴一下官方题解吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; R; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; C; j++) &#123;</span><br><span class="line">                ret.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ret.begin(), ret.end(), [&#x3D;](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;</span><br><span class="line">            return abs(a[0] - r0) + abs(a[1] - c0) &lt; abs(b[0] - r0) + abs(b[1] - c0);</span><br><span class="line">        &#125;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里可以看到[=]进行了一次重载，我第一次见.jpg，拿小本本记录下来。是C11的新特性，参加<a href="https://www.jianshu.com/p/6482fbd3abdf" target="_blank" rel="noopener">这篇文章</a></p><p>原来vector可以放一个{i,j}进去，我也不知道，记下来。</p><p>vector的使用方法参见<a href="https://blog.csdn.net/weixin_41743247/article/details/90635931" target="_blank" rel="noopener">这篇blog</a></p><h2 id="2020-11-18"><a href="#2020-11-18" class="headerlink" title="2020-11-18"></a>2020-11-18</h2><h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码能力越来越差了，刷leetcode复健一下，顺便记录一下C++ STL的一些用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="WP" scheme="http://www.kittener.top/categories/WP/"/>
    
    
      <category term="刷题日记" scheme="http://www.kittener.top/tags/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养笔记</title>
    <link href="http://www.kittener.top/2020/11/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.kittener.top/2020/11/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-04T12:27:55.000Z</published>
    <updated>2020-12-02T14:42:31.827Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下elf文件的知识点</p><a id="more"></a><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>一个更实际的方法是将相同性质的段合并到一起，比如将所有输入文件的”.text”合并到输出文件的”.text”段，其他段相同。</p><h3 id="两步链接"><a href="#两步链接" class="headerlink" title="两步链接"></a>两步链接</h3><p><strong>第一步  空间与地址分配</strong>  扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这-一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p><p><strong>第二步  符号解析与重定位</strong>  使用上面第-步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。</p><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>ELF文件中，有一个叫<strong>重定位表</strong>的结构专门用来保存这些与重定位相关的信息，往往在ELF文件中是一个或多个段。</p><p>例如，代码段”.text”如有要被重定位的地方，那么会有一个相对应叫”.rel.text”的段保存了代码段的重定位表，可以使用objdump来查看</p><p><code>objdump -r a.o</code></p><p><img src="P1.png" alt="P1"></p><p>这个命令可以用来查看 “a.o” 里面要重定位的地方。 每个要被重定位的地方叫一个<strong>重定位入口</strong>( Relocation Entry)，我们可以看到 “a.o” 里面有两个重定位入口。重定位入口的<strong>偏移</strong>(Offset)表示该入口在要被重定位的段中的位置，“RELOCATION RECORDS FOR [.text]” 表示这个重定位表是<strong>代码段的重定位表</strong>，所以偏移表示代码段中须要被调整的位置。</p><p>对于32位的x86处理器来说，重定位表的结构也蛮简单的，是一个Elf32_Rel结构的数组，每个数组元素对应一个重定位入口。Elf32_Rel的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">Elf32_Addr  r_offset;</span><br><span class="line">Elf32_Word  r_info;</span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p><img src="P2.png" alt=""></p><h3 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h3><p>这个感觉还挺有意思的，记录一下</p><p>指令在寻址方面主要有以下区别：</p><ul><li>近址寻址或远址寻址</li><li>绝对寻址或相对寻址</li><li>寻址长度为8位，16位，32位或64位</li></ul><p>但是对于32位x86平台下的elf文件的重定位入口所修正的指令寻址方式只有两种：</p><ul><li>绝对近址32位寻址</li><li>相对近址32位寻址</li></ul><p>这两种重定位方式指令修正方式为<strong>每个被修正的位置的长度都为32位，即4个字节。</strong>重定位入口的r_info成员低8位表示重定位入口类型，如表所示。</p><p><img src="P3.png" alt=""></p><p>对照a.o的重定位信息</p><p><img src="P4.png" alt=""></p><p>对swap符号的引用类型是R_386_PC32，这是一条<strong>相对位移调用指令</strong>。shared是R_386_32类型的。它修正的是一条<strong>传输指令的源</strong>，该传输指令的源是一个立即数，即shared的绝对地址。</p><p>接下来让👴康康具体过程</p><p>这是a.o没有被修正的时候：</p><p><img src="P5.png" alt=""></p><p><strong>绝对寻址修正</strong>  </p><p>偏移为0x18的这条mov指令的修正，修正方式为R_386_32，即绝对地址修正，结果应该是S+A</p><ul><li>S是符号shared的实际地址，即0x3000</li><li>A是被修正位置的值，即0x00000000</li></ul><p>所以最后这个重定位入口修正后的地址为:<strong>0x3000+0x00000000=0x3000</strong></p><p><img src="P6.png" alt=""></p><p><strong>相对寻址修正</strong></p><p>偏移为0x26的这条call指令，修正方式为R_386_PC32，即相对寻址修正，结果应该为S+A-P</p><ul><li>S是符号swap的实际地址，即0x2000</li><li>A是被修正位置的值，即0xFFFFFFFC(-4)</li><li>P为被修正的位置，当链接成可执行文件时，这个值应该是被修正位置的虚拟地址，即0x1000+0x27</li></ul><p>所以最后这个重定位入口修正后地址为:<strong>0x2000+(-4)-(0x1000+0x27)=0xFD5</strong></p><p><img src="P7.png" alt=""></p><p>这条相对位移调用指令调用的地址是该指令下一条指令的起始地址加上偏移量，即:<strong>0x102b+0xFD5=0x2000</strong>,刚好是swap函数的地址。</p><p>从这两个例子可以看出来,绝对寻址修正和相对寻址修正的区别就是 </p><p><strong>绝对寻址修正后的地址为该符号的实际地址:相对寻址修正后的地址为符号距离被修正位置的地址差。</strong></p><h3 id="最”小“的程序"><a href="#最”小“的程序" class="headerlink" title="最”小“的程序"></a>最”小“的程序</h3><p><a href="http://www.ethernut.de/en/documents/arm-inline-asm.html" target="_blank" rel="noopener">GCC内嵌汇编手册</a></p><h4 id="ld链接脚本语法"><a href="#ld链接脚本语法" class="headerlink" title="ld链接脚本语法"></a>ld链接脚本语法</h4><h5 id="语句类型"><a href="#语句类型" class="headerlink" title="语句类型"></a>语句类型</h5><ul><li>命令语句</li><li>链接语句</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li><strong>语句之间使用分号”;”作为分割符</strong>    原则上讲语句之间都要以”;”作为分割符，但是对于命令语句来说也可以使用换行来结束该语句，对于赋值语句来说必须以”;”结束。</li><li><strong>表达式与运算符</strong>   脚本语言的语句中可以使用C语言类似的表达式和运算操作符，比如+、-、* 、l、+=、-=、*=等，甚至包括&amp;、l、&gt;&gt;、&lt;&lt;等这些位操作符。</li><li><strong>注释和字符引用</strong>    使用/**/作为注释。脚本文件中使用到的文件名、格式名或段名等凡是包含“;”或其他的分隔符的，都要使用双引号将该名字全称引用起来，如果文件名包含引号，则很不幸，无法处理。</li></ul><p>来个demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(nomain)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. &#x3D; 0x08048000 + SIZEOF_HEADERS;</span><br><span class="line">tinytext: &#123; * (.text) * (.data) * (.rodata)&#125;</span><br><span class="line">&#x2F;DISCARD&#x2F; : &#123; *( .cornment) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：</p><p>这是一个非常简单的链接脚本，<strong>第一行的 ENTRY(nomain)指定了程序的入口为nomain()函数</strong>，后面的<strong>SECTIONS命令一般是链接脚本的主体，这个命令指定了各种输入段到输出段的变换</strong>，SECTIONS后面紧跟着的一对大括号里面包含了SECTIONS变换规则，其中有三条语句，每条语句一行。第一条是赋值语句，后面两条是段转换规则，它们的含义分别如下:</p><ul><li><strong>. = Ox08048000 + SIZEOF_HEADERS</strong>  第一条赋值语句的意思是将当前虚拟地址设置成Ox08048000 + SIZEOF_HEADERS，SIZEOF_HEADERS为输出文件的文件头大小。“.”表示当前虚拟地址，因为这条语句后面紧跟着输出段“tinytext”，所以“tinytext”段的起始虚拟地址即为Ox08048000 + SIZEOF_HEADERS。它将当前虚拟地址设置成一个比较巧妙的值，以便于装载时页映射更为方便。</li><li><strong>tinytext : {  * (.text) * (.data)  *(.rodata)}</strong>  第二条是个段转换规则,它的意思即为所有输入文件中的名字为“.text”、”.data” 或 “.rodata” 的段依次合并到输出文件的“tinytext”。</li><li><strong>/DISCARD/ : { “(.comment)}</strong>  第三条规则为:将所有输入文件中的名字为 “.comment“的段丢弃，不保存到输出文件中。</li></ul><h5 id="常用的命令语句"><a href="#常用的命令语句" class="headerlink" title="常用的命令语句"></a>常用的命令语句</h5><p><img src="P8.png" alt=""></p><p><img src="P9.png" alt=""></p><h5 id="SECTIONS命令"><a href="#SECTIONS命令" class="headerlink" title="SECTIONS命令"></a>SECTIONS命令</h5><p>SECTIONS命令语句的最基本格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">secname : &#123; contents &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>secname表示输出段的段名</strong>，secname后面必须有一个空格符，这样使得输出段名不会有歧义，<strong>后面紧跟着冒号和一对大括号</strong>。大括号里面的contents描述了一套规则和条件，它表示符合这种条件的输入段将合并到这个输出段中。输出段名的命名方法必须符合输出文件格式的要求，比如，如果使用ld生产一个a.out格式的文件，<strong>那么输出段名就不可以使用除“.text”、”.data”和“.bss”之外的任何名字，因为a.out格式规定段名只允许这三个名字。</strong></p><p>有一个特殊的段名叫“/DISCARD/“，如果使用这个名字作为输出段名，那么所有符合后面contents所规定的条件的段都将被丢弃，不输出到输出文件中。</p><p>接着，我们最应该关心的是contents这个规则。contents中可以包含若干个条件，每个条件之间以空格隔开，如果输入段符合这些条件中的任意一个即表示这个输入段符合contents规则。条件的写法如下:</p><p><code>filename(sections)</code></p><p>filename表示输入文件名，sections表示输入段名，来几个栗子尝尝：</p><ul><li>file1.o(.data)表示输入文件中名为file1.o的文件中名叫.data的段符合条件。</li><li>file1.o(.data .rodata)或file1.o(.data，.rodata)表示输入文件中名为file1.o的文件中的名叫.data或.rodata的段符合条件。</li><li>file1.o如果直接指定文件名而省略后面的小括号和段名,则表示file1.o的所有段都符合条件。</li><li><em>(.data)所有输入文件中的名字为.data的文件符合条件。 * 是通配符，类似于正则表达式中的</em>，我们还可以使用正则表达式中的?、[]等规则。</li><li><code>[a-z]*(.text*[A-Z])</code>这个条件比较复杂，它表示所有输入文件中以小写字母a到z开头的文件中所有段名以.text开头，并且以大写字母A到Z结尾的段。从这个规则中你也许可以看到一些链接脚本功能的强大。</li></ul><h1 id="Windows-PE-COFF文件"><a href="#Windows-PE-COFF文件" class="headerlink" title="Windows PE/COFF文件"></a>Windows PE/COFF文件</h1><h2 id="COFF文件结构"><a href="#COFF文件结构" class="headerlink" title="COFF文件结构"></a>COFF文件结构</h2><p><img src="P10.png" alt=""></p><p>文件头里描述的COFF文件总体属性的映像头是一个”IMAGE_FILE_HEADER”的结构。这个结构以及相关常数定义在”VC\PlatformSDK\include\WinNT.h”里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER&#123;</span><br><span class="line">WORD  Machine;</span><br><span class="line">WORD  Numberofsections;</span><br><span class="line">DWORD TimeDatestamp;</span><br><span class="line">DWORD PointerToSymbolTable ;</span><br><span class="line">DWORD NumberOfSymbols;</span><br><span class="line">WORD  SizeOfOptionalHeader ;</span><br><span class="line">WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER，*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>后面紧跟着段表，它是一个类型为”IMAGE_SECTION_HEADER”结构的数组，数组中的每个元素代表一个段。</p><p>也被定义在WinNT.h里面:</p><p><img src="P11.png" alt=""></p><p>可以看到每个段所拥有的属性包括段名( Section Name )、物理地址( Physical address)、虚拟地址(Virtual address)、原始数据大小(Size of raw data)、段在文件中的位置(File pointer to raw data)、该段的重定位表在文件中的位置(File pointer to relocationtable )、该段的行号表在文件中的位置( File pointer to line numbers)、标志位( Characteristics）等。</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>VirtualSize</td><td>该段被加载至内存后的大小</td></tr><tr><td>VirtualAddress</td><td>该段被加载至内存后的虚拟地址</td></tr><tr><td>SizeOfRawData</td><td>该段在文件中的大小。注意:这个值有可能跟 VirtualSize的值不一样，比如.bss 段的SizeOfRawData是0，而VirtualSize值是.bss段的大小。另外涉及一些内存对齐等问题，这个值往往比 VirtualSize 小</td></tr><tr><td>Characteristics</td><td>段的属性，属性里包含的主要是段的类型（代码、数据、bss )、对齐方式及可读可写可执行等权限。段的属性是一些标志位的组合，这些标志位被定义在WinNT.h里，比如IMAGE_SCN_CNT_CODE ( Ox00000020）表示该段里面包含的是代码;IMAGE_SCN_MEM_READ ( Ox40000000)表示该段在内存中是可读的;IMAGE_SCN_MEM_EXECUTE ( Ox20000000 )表示该段在内存中是可执行的，等等</td></tr></tbody></table><p>符号表和ELF文件类似，不在赘述</p><h2 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h2><p>PE文件相较于COFF多了几个结构，主要的变化有两个：</p><p>第一个是文件最开始的部分不是COFF文件头，而是DOS MZ可执行文件格式的文件头和桩代码(DOS MZ File Header and Stub);</p><p>第二个变化是原来的 COFF文件头中的“IMAGE_FILE_HEADER”部分扩展成了PE文件文件头结构“IMAGE_NT_HEADERS”,这个结构包括了原来的“Image Header”及新增的PE扩展头部结构(PE Optional Header)。PE文件的结构如图5-2所示。</p><p><img src="P12.png" alt=""></p><p>“IMAGE_DOS_HEADER”结构唯一需要关心的就是”e_lfanew”成员，它表明了PE文件头(IMAGE_NT_HEADERS)在PE文件中的<strong>偏移</strong>。</p><p>“IMAGE_NT_HEADERS”是PE真正的文件头，它包含了一个<strong>标记</strong>和两个<strong>结构体</strong>。标记是一个常量，值为0x00004550，按照小端序，对应的是’P’、’E’、’\0’、’\0’这四个字符的ASCII码。文件头包含的两个结构分别是<strong>映像头</strong>(Image Header)、<strong>PE扩展头部结构</strong>。定义如下：</p><p><img src="P13.png" alt=""></p><p>映像头的结构如下：</p><p><img src="P14.png" alt=""></p><p><img src="P15.png" alt=""></p><h3 id="PE数据目录"><a href="#PE数据目录" class="headerlink" title="PE数据目录"></a>PE数据目录</h3><p>在 Windows系统装载PE可执行文件时,往往须要很快地找到一些装载所须要的数据结构，比如导入表、导出表、资源、重定位表等。这些常用的数据的位置和长度都被保存在了一个叫数据目录(Data Directory)的结构里面，其实它就是前面“IMAGE_OPTIONAL_HEADER”结构里面的“DataDirectory”成员。这个成员是一个“IMAGE_DATA_DIRECTORY”的结构数组，相关的定义如下:</p><p><img src="P16.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下elf文件的知识点&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架学习笔记</title>
    <link href="http://www.kittener.top/2020/11/03/SSM%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.kittener.top/2020/11/03/SSM%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-03T13:41:52.000Z</published>
    <updated>2020-11-30T14:21:15.159Z</updated>
    
    <content type="html"><![CDATA[<p>为了web大作业而学习的框架</p><a id="more"></a><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="ApplicationContext的三个常用实现类"><a href="#ApplicationContext的三个常用实现类" class="headerlink" title="ApplicationContext的三个常用实现类"></a>ApplicationContext的三个常用实现类</h2><ul><li>ClassPathXmLAppLicationlontext:它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。</li><li>FiLeSystemXmLApplicationContext:它可以加载磁盘任意路径下的配置文件(必须有访问权限)</li><li>AnnotationConfigApplicationContext:它是用于读取注解创建容器的。</li></ul><h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p>ApplicationContext:</p><p>​    它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。</p><p>BeanFactory:</p><p>​    它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</p><h2 id="Bean对象"><a href="#Bean对象" class="headerlink" title="Bean对象"></a>Bean对象</h2><h3 id="创建bean的三种方式"><a href="#创建bean的三种方式" class="headerlink" title="创建bean的三种方式"></a>创建bean的三种方式</h3><ol><li><p>使用默认构造函数创建</p><p>​    在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</p><p><code>&lt;bean id=&quot;instanceFactory(类名)&quot; class = &quot;com.itheima.factory.InstanceFactory(所在位置)&quot;&gt;&lt;/bean&gt;</code></p></li><li><p>使用普通工厂中的方法</p><p>​    使用某个类中的方法创建对象，并存入spring容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;instanceFactory(类名)&quot; class &#x3D; &quot;com.itheima.factory.InstanceFactory(所在位置)&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService(方法名)&quot; factory-bean&#x3D;&quot;instanceFactory(id指向的工厂)&quot; factory-method&#x3D;&quot;getAccountService(工厂中的方法)&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用工厂中的静态方法创建对象</p><p>​    使用某个类中的静态方法创建对象，并存入spring容器</p><p><code>&lt;bean id=&quot;instanceFactory(类名)&quot; class = &quot;com.itheima.factory.InstanceFactory(所在位置)&quot; factory-method=&quot;getAccountService(工厂中的方法)&quot;&gt;&lt;/bean&gt;</code></p></li></ol><h3 id="bean对象的作用范围"><a href="#bean对象的作用范围" class="headerlink" title="bean对象的作用范围"></a>bean对象的作用范围</h3><p>bean标签的scope属性:</p><p>​        作用:用于指定bean的作用范围</p><p>​        取值:</p><p>​                singleton: 单例的(默认值)</p><p>​                prototype：多例的</p><p>​                request：作用于web应用的请求范围</p><p>​                session：作用于web应用的会话范围</p><p>​                global-session：作用于集群环境的会话范围（全局会话范围)，当不是集群环境时，它就是session</p><p><code>&lt;bean id=&quot;instanceFactory(类名)&quot; class = &quot;com.itheima.factory.InstanceFactory(所在位置)&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</code></p><h3 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h3><h4 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h4><p>​        出生：当容器创建时对象出生</p><p>​        活着：只要容器还在，对象一直活着</p><p>​        死亡：容器销毁，对象消亡</p><p>​        总结：单例对象的生命周期和容器相同</p><h4 id="多例对象"><a href="#多例对象" class="headerlink" title="多例对象"></a>多例对象</h4><p>​        出生:当我们使用对象时spring框架为我们创建</p><p>​        活着:对象只要是在使用过程中就一直活着</p><p>​        死亡:当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收</p><h2 id="Spring中的依赖注入"><a href="#Spring中的依赖注入" class="headerlink" title="Spring中的依赖注入"></a>Spring中的依赖注入</h2><p>依赖注入：</p><p>​        Dependence Injection</p><p>IOC的作用：</p><p>​        降低程序间的耦合(依赖关系)</p><p>依赖关系的管理：</p><p>​        以后都交给spring来维护</p><p>在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明依赖关系的维护:</p><p>​        就称之为依赖注入</p><p>​        依赖注入:</p><p>​                        能注入的数据:有三类</p><p>​                                基本类型和String</p><p>​                                其他bean类型(在配置文件中或者注解配置过的bean)</p><p>​                                复杂类型/集合类型</p><p>​                        注入的方式:</p><p>​                                第一种:使用构造函数提供</p><p>​                                第二种:使用set方法提供</p><p>​                                第三种:使用注解提供</p><p><strong>如果是经常发生变化的数据，并不适用于注入</strong></p><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>使用的标签:constructor-arg</p><p>标签出现的位置:bean标签的内部</p><p>标签中的属性</p><p>​        type:用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</p><p>​        index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始</p><p>​        name:用于指定给构造函数中指定名称的参数赋值</p><p>===================以上三个用于指定给构造函数中哪个参数赋值======================</p><p>​        value:用于提供基本类型和String类型的数据</p><p>​        ref:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</p><p>优势：</p><p>​        在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</p><p>弊端:</p><p>​        改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</p><p>demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com. itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;泰斯特&quot;×&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置一个日期对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;now&quot; class&#x3D;&quot;java.util.Date&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>使用的标签:property</p><p>标签出现的位置:bean标签的内部</p><p>标签中的属性</p><p>​        name:用于指定注入时所调用的set方法名称</p><p>​        value:用于提供基本类型和String类型的数据</p><p>​        ref:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</p><p>优势:</p><p>​        创建对象时没有明确的限制，可以直接使用默认构造函数</p><p>弊端:</p><p>​        如果有某个成员必须有值，则set方法无法保证一定注入</p><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService2&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&gt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h4 id="复杂类型的注入-集合类型的注入"><a href="#复杂类型的注入-集合类型的注入" class="headerlink" title="复杂类型的注入/集合类型的注入"></a>复杂类型的注入/集合类型的注入</h4><p>用于给List结构集合注入的标签:</p><p>​        list array set</p><p>用于个Map结构集合注入的标签:</p><p>​        map props</p><p>结构相同，标签可以互换</p><p>demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService3&quot; class&#x3D;&quot;com. itheima.service.impl.AccountServiceImpl3&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;myStrs&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;myMap&quot;&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry key&#x3D;&quot;testA&quot; value&#x3D;&quot;aaaa&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">&lt;entry key&#x3D;&quot;testB&quot;&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;entry&gt;</span><br><span class="line">&lt;&#x2F;map&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;myProps&quot;&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;testC&quot;&gt;ccc&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;&#x2F;props&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="注解类型注入"><a href="#注解类型注入" class="headerlink" title="注解类型注入"></a>注解类型注入</h3><p>在使用之前需要<strong>告知spring在创建容器时要扫描的包．配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中</strong></p><p>&lt;context:component-scan base-package=”com.itheima”&gt;</context:component-scan ></p><h4 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h4><p>他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的</p><p>@Component:</p><p>​        作用：用于把当前类对象存入spring容器中。</p><p>​        属性：</p><p>​                value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母是改小写</p><p>@Controller:一般用在表现层</p><p>@Service:一般用在业务层</p><p>@Repository:一般用在持久层</p><p>以上三个注解的作用和Component是一摸一样的，他们三个是spring框架为我们提供明确的三层注解，使我们的三层对象更加清晰</p><h4 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h4><p>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的</p><p>@Autowired：</p><p>​        作用:自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功</p><p>​                如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错</p><p>​                如果ioc容器中有多个类型匹配时:</p><p>​                        先匹配类型，在匹配名称</p><p>​        出现位置：</p><p>​                可以是变量上，也可以是方法上</p><p>​        细节：</p><p>​                在使用注解注入时，set方法就不是必须的了</p><p>@Qualifier：</p><p>​        作用:在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以</p><p>​        属性：</p><p>​                value：用于指定注入bean的id</p><p>@Resource</p><p>​        作用:直接按照bean的id注入。它可以独立使用</p><p>​        属性:</p><p>​                name:用于指定bean的Id</p><p><strong>以上三个注入都只能注入其他bean类型的数据，而基本类型和string类型无法使用上述注解实现。另外，集合类型的注入只能通过ML来实现。</strong></p><p>@Value</p><p>​        作用:用于注入基本类型和String类型的数据</p><p>​        属性:</p><p>​                value:用于指定数据的值。它可以使用spring中SpEL(也就是spring的eL表达式)</p><p>​                        SpEL的写法：${表达式}</p><h4 id="用于改变作用范围的"><a href="#用于改变作用范围的" class="headerlink" title="用于改变作用范围的"></a>用于改变作用范围的</h4><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p><p>@Scope</p><p>​        作用:用于指定bean的作用范围</p><p>​        属性:</p><p>​                value:指定范围的取值。常用取值:singleton prototype</p><h4 id="和生命周期相关"><a href="#和生命周期相关" class="headerlink" title="和生命周期相关"></a>和生命周期相关</h4><p>他们的作用就和在bean标签中使用init-method和destroy-method的作用是一样的</p><p>@PreDestroy</p><p>​        作用:用于指定销毁方法</p><p>@PostConstruct</p><p>​        作用:用于指定初始化方法</p><h4 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h4><p>@Configuration</p><p>​        作用:指定当前类是一个配置类</p><p>​        细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</p><p>@ComponentScan</p><p>​        作用:用于通过注解指定spring在创建容器时要扫描的包</p><p>​        属性：</p><p>​                value：它和basePackages的作用是一样的．都是用于指定创建容器时要扫描的包。</p><p>​                            我们使用此注解就等同于在xmL中配置了:    </p><p>​                                    &lt;context:component-scan base-package=”com.itheima”&gt;&lt; /context:component-scan&gt;</p><p>@Bean</p><p>​        作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</p><p>​        属性：</p><p>​                name：用于指定bean的id。当不写时，默认值是当前方法的名称</p><p>​        细节：</p><p>​                当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的</p><p>@Import</p><p>​        作用：用于导入其他的配置类</p><p>​        属性：</p><p>​                value：用于指定其他配置类的字节码。</p><p>​                            当我们使用import的注解之后，有Import注解的类就是父配置类，而导入的都是子配置类</p><p>@PropertySource</p><p>​        作用：用于指定properties文件的位置</p><p>​        属性：</p><p>​                value：指定文件的名称和路径。</p><p>​                            关键字：classpath，表示类路径下</p><p>@Qualifier</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource)&#123;</span><br><span class="line">return new QueryRunner(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Junit单元测试Spring框架"><a href="#Junit单元测试Spring框架" class="headerlink" title="Junit单元测试Spring框架"></a>Junit单元测试Spring框架</h3><p>Spring控合junit的配置</p><ol><li><p>导入spring整合junit的jar(坐标)</p></li><li><p>使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的</p><p>​    @Runwith</p><p>​            告知spring的运行器，spring和ioc创建是基于xmL还是注解的，并且说明位置</p><p>​    @ContextConfiguration</p><p>​            Locations:指定xml文件的位置，加上classpath关键字,表示在类路径下</p><p>​            cLasses:指定注解类所在地位置</p></li></ol><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AccountServiceTest</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring的面向切片编程"><a href="#Spring的面向切片编程" class="headerlink" title="Spring的面向切片编程"></a>Spring的面向切片编程</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>特点:字节码随用随创建,随用随加载</p><p>作用:不修改源码的基础上对方法增强</p><p>分类:</p><p>​        基于接口的动态代理</p><p>​        基于子类的动态代理</p><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理:"></a>基于接口的动态代理:</h4><p>​        涉及的类:Proxy</p><p>​        提供者:JDK官方</p><p>如何创建代理对象:</p><p>​        使用Proxy类中的newProxyInstance方法</p><p>创建代理对象的要求:</p><p>​        被代理类最少实现一个接口，如果没有则不能使用</p><p>newProxyInstance方法的参数:</p><p>​        ClassLoader：类加载器</p><p>​                它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</p><p>​        class[]: 字节码数组</p><p>​                它是用于让代理对象和被代理对象有相同方法。固定写法</p><p>​        InvocationHandler:用于提供增强的代码</p><p>​                它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须</p><p>​                此接口的实现类都是谁用谁写。</p><p><img src="P1.png" alt=""></p><p><strong>但是，没有实现接口的类在没有第三方jar包的情况下无法动态代理</strong></p><h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><p>​        涉及的类:Enhancer</p><p>​        提供者:第三方cglib库</p><p>如何创建代理对象:</p><p>​        使用Enhancer类中的create方法</p><p>创建代理对象的要求:</p><p>​        被代理类不能是最终类</p><p>create方法的参数:</p><p>​        Class：字节码</p><p>​                它是用于指定被代理对象的字节码。</p><p>​        Callback:用于提供增强的代码</p><p>​                它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</p><p>​                此接口的实现类都是谁用谁写。</p><p>​                我们一般写的都是该接口的子接口实现类:MethodInterceptor</p><h3 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h3><p><strong>Joinpoint(连接点):</strong></p><p>​        所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。</p><p><strong>Pointcut(切入点):</strong></p><p>​        所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。</p><p><strong>Advice(通知/增强):</strong></p><p>​        所谓通知是指拦截到Joinpoint 之后所要做的事情就是通知。</p><p>​        通知的类型:前置通知,后置通知,异常通知,最终通知，环绕通知。</p><p>demo:</p><p><img src="P2.png" alt=""></p><p><strong>Introduction(引介):</strong></p><p>​        引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。</p><p><strong>Target(目标对象):</strong></p><p>​        代理的目标对象。</p><p><strong>weaving(织入):</strong></p><p>​        是指把增强应用到目标对象来创建新的代理对象的过程。</p><p>​        spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</p><p><strong>Proxy（代理):</strong></p><p>​        一个类被AoP织入增强后，就产生一个结果代理类。</p><p><strong>Aspect(切面):</strong></p><p>​        是切入点和通知（引介）的结合。</p><h4 id="spring中基于XML的AOP配置步骤"><a href="#spring中基于XML的AOP配置步骤" class="headerlink" title="spring中基于XML的AOP配置步骤"></a>spring中基于XML的AOP配置步骤</h4><ol><li><p>把通知Bean也交给spring来管理</p></li><li><p>使用aop:config标签表明开始AOP的配置</p></li><li><p>使用aop:aspect标签表明配置切面</p><p>id属性:是给切面提供一个唯一标识</p><p>ref属性:是指定通知类bean的Id。</p></li><li><p>在aop:aspect标签的内部使用对应标签来配置通知的类型</p><p>我们现在示例是让printLog方法在切入点方法执行之前之前:所以是前置通知</p><p>aop:before:表示配置前置通知</p><p>​        method属性:用于指定Logger类中哪个方法是前置通知</p><p>​        pointcut属性:用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</p><p>切入点表达式的写法:</p><p>​        关键字:execution(表达式)</p><p>​        表达式:</p><p>​                访间修饰符        返回值        包名.包名.包名…类名.方法名(参数列表)    </p><p>​        标准的表达式写法:</p><p>​                <code>public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</code></p></li></ol><p>demo:</p><p><img src="P3.png" alt=""></p><p>访问修饰符可以省略</p><p><code>void com.itheima.service.impl.AccountServiceImpl.saveAccount()</code></p><p>返回值可以使用通配符，表示任意返回值</p><p><code>* com.itheima.service.impl.AccountServiceImpl.saveAccount()</code></p><p>包名可以使用通配符，表示任意包，但是有几级包，就需要写几个*</p><p><code>* *.*.*.*.AccountServiceImpl.saveAccount()</code></p><p>包名可以使用..来表示当前包及其子包</p><p><code>* *..AccountServiceImpl.saveAccount()</code></p><p>类名和方法名都可以使用*来实现通配</p><p><code>* *..*.*()</code></p><p>参数列表:</p><p>​        可以直接写数据类型：</p><p>​                基本类型直接写名称                            int</p><p>​                引用类型写包名.类名的方式                java.lang.String</p><p>​        可以使用通配符，表示任意参数，但是必须有参数</p><p>​        可以使用..表示有无参数均可，有参数可以是任意类型</p><p>全通配写法：</p><p>​        <code>*  *..*.*(..)</code></p><p><strong>实际开发中切入点表达式的通常写法：</strong></p><p>​        切到业务层实现类下的所有方法</p><p>​                <code>*  com.itheima.service.impl.*.*(..)</code></p><p>环绕通知应该加入切入点，demo如下：</p><p><img src="P4.png" alt=""></p><h2 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h2><h3 id="Spring中基于XML的声明式事务控制配置步骤"><a href="#Spring中基于XML的声明式事务控制配置步骤" class="headerlink" title="Spring中基于XML的声明式事务控制配置步骤"></a>Spring中基于XML的声明式事务控制配置步骤</h3><ol><li><p>配置事务管理器</p><p>demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource .DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置事务的通知</p><p>此时需要导入事务的约束    tx名称空间和约束，同时也需要aop</p><p>是同tx:advice标签配置事务通知</p><p>​        属性:</p><p>​                id:给事务通知起一个唯一标识</p><p>​                transaction-manager:给事务通知提供一个事务管理器引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;trnansactionManager&quot;&gt;&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置AOP中的通用切入点表达式</p></li><li><p>建立事务通知和对应表达式的对应关系</p><p>demo:</p><p><img src="P5.png" alt=""></p></li><li><p>配置事务的属性</p><p>在事务的通知tx:advice标签的内部</p><p>属性：</p><ol><li>isolation:用于指定务的隔离级别。默认见是DEFAULT，表示使用数据库的默认隔离级别。</li><li>propagation:用于指定事务的传播行为。默认值是REQUTRED，表示一定会有辜务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only:用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。</li><li>rollback-for:用干指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for:用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ol></li></ol><h3 id="Spring中基于注解的声明式事务控制配置"><a href="#Spring中基于注解的声明式事务控制配置" class="headerlink" title="Spring中基于注解的声明式事务控制配置"></a>Spring中基于注解的声明式事务控制配置</h3><ol><li><p>配置事务管理器</p></li><li><p>开启Spring对注解事物的的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager-&quot;transactionManager&quot;&gt;&lt;&#x2F;tx: annotation-driven&gt;</span><br></pre></td></tr></table></figure></li><li><p>在需要事务支持的地方使用@Transactional注解</p></li></ol><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><h3 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h3><h4 id="出现位置："><a href="#出现位置：" class="headerlink" title="出现位置："></a>出现位置：</h4><p>类上：</p><p>​        请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。</p><p>​        它出现的目的是为了使我们的URL可以按照模块化管理：</p><p>​        例如：</p><p>​                账户模块：</p><p>​                                /account/add</p><p>​                                /account/update</p><p>​                                /account/delete</p><p>​                                …</p><p>​                订单模块：</p><p>​                                /order/add</p><p>​                                /order/update</p><p>​                                /order/delete</p><p>​                第一部分就是把RequestMapping写在类上，使我们的URL更加精细。</p><p>方法上：</p><p>​        请求URL的第二级访问目录</p><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><p>​        value:用于指定请求的URL。它和path属性的作用是一样的。</p><p>​        method:用于指定请求的方式。</p><p>​        params:用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样。</p><p>​                例如：</p><p>​                        params = { “accountName”}，表示请求参数必须有accountName</p><p>​                        params = { “moeny!100”}，表示请求参数中money不能是100。</p><p>​        headers:用于指定限制请求消息头的条件。</p><p>​        以上属性出现两个或以上的时候是与的关系</p><h3 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>​        把请求中指定名称的参数给控制器中的形参赋值。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><p>​        value:请求参数中的名称。</p><p>​        required:请求参数中是否必须提供此参数。默认值: true。表示必须提供，如果不提供将报错。</p><h3 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h3><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p>​        用于获取请求体内容。直接使用得到是key=value&amp;key=value…结构的数据。</p><p>​        get请求方式不适用。</p><h4 id="属性：-1"><a href="#属性：-1" class="headerlink" title="属性："></a>属性：</h4><p>​        required:是否必须有请求体。默认值是:true。当取值为true时, get 请求方式会报错。如果取值为false，get请求得到是null。</p><h3 id="PathVairable"><a href="#PathVairable" class="headerlink" title="PathVairable"></a>PathVairable</h3><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><p>​        用于绑定url中的占位符。例如:请求url中/delete/{id}，这个{ id}就是url占位符。</p><p>​        url支持占位符是spring3.0之后加入的。是springmvc支持 rest风格URL的一个重要标志。</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性:"></a>属性:</h4><p>​        value:用于指定url中占位符名称。</p><p>​        required:是否必须提供占位符。</p><h3 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h3><h4 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a>作用：</h4><p>​        1.出现在方法上:表示当前方法会在控制器方法执行前线执行。</p><p>​        2.出现在参数上:获取指定的数据给参数赋值。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​        1.当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</p><p>​        例如:</p><p>​        我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null，此时就可以使用此注解解决问题。</p><h3 id="SessionAttribute注解"><a href="#SessionAttribute注解" class="headerlink" title="SessionAttribute注解"></a>SessionAttribute注解</h3><h4 id="作用：-4"><a href="#作用：-4" class="headerlink" title="作用："></a>作用：</h4><p>​        用于多次执行控制器方法间的参数共享。</p><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性:"></a>属性:</h4><p>​        value:用于指定存入的属性名称</p><p>​        type:用于指定存入的数据类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了web大作业而学习的框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点" scheme="http://www.kittener.top/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Diary</title>
    <link href="http://www.kittener.top/2020/11/02/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>http://www.kittener.top/2020/11/02/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2020-11-02T11:40:58.111Z</published>
    <updated>2020-12-19T12:12:32.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个记录学习生活的日记本"><a href="#这是一个记录学习生活的日记本" class="headerlink" title="这是一个记录学习生活的日记本"></a>这是一个记录学习生活的日记本</h1><h2 id="督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信"><a href="#督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信" class="headerlink" title="督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值(确信)"></a><del>督促自己学习</del>为了让以后的自己看看摸鱼的自己增加悔恨值(确信)</h2><ul><li><a id="more"></a></li></ul><p>重开新坑，冲冲冲~</p><h2 id="2020-11"><a href="#2020-11" class="headerlink" title="2020-11"></a>2020-11</h2><h3 id="2020-11-02"><a href="#2020-11-02" class="headerlink" title="2020-11-02"></a>2020-11-02</h3><p>继续学习SSM框架，我直接跳过了mybatics部分了，进入正题Spring</p><h3 id="2020-11-03"><a href="#2020-11-03" class="headerlink" title="2020-11-03"></a>2020-11-03</h3><p>因为一些杂事耽误了学习，没学多少东西，还把腰给坐伤了QAQ，明天核酸检测，把平板带回去看书吧</p><h3 id="2020-11-04"><a href="#2020-11-04" class="headerlink" title="2020-11-04"></a>2020-11-04</h3><p>今天进度很多，Spring-Day1看完了，程序员自我修养继续阅读，注意了一下坐姿，感觉好多了，能坚持完了</p><p>四级过了超级激动，该准备六级啦，upup！</p><h3 id="2020-11-05"><a href="#2020-11-05" class="headerlink" title="2020-11-05"></a>2020-11-05</h3><p>Spring-Day2完成50%，补充了一下elf笔记，效率还可以感觉（茶）</p><p>之后每天争取再复现一道re吧！（话说鸽了好久的pwn学习什么时候才能捡回来！</p><h3 id="2020-11-08"><a href="#2020-11-08" class="headerlink" title="2020-11-08"></a>2020-11-08</h3><p>今天打铁三了！但是没有re题所以我摁混了一天QAQ，第一道pwn以为是个简单rop没想到是<strong>ret2_dll_runtime_resolve</strong>，并不会2333，用Sakura的blog的exp也打不通，记录一下，有空学</p><p>Spring Day2完成√ </p><h3 id="2020-11-09"><a href="#2020-11-09" class="headerlink" title="2020-11-09"></a>2020-11-09</h3><p>今天太倒霉了…逃课被抓，还忘了晚上有课</p><p>被一些事情耽误了学习QAQ，勉勉强强看完了Spring Day3的任务，但是elf没来得及看(茶)</p><p>好像大家对于成功的定义都挺狭隘的，唉，我也有点被迫卷的味道了(悲)</p><p>明天加油</p><h3 id="2020-11-10"><a href="#2020-11-10" class="headerlink" title="2020-11-10"></a>2020-11-10</h3><p>今天好水，课有点多… Spring Day3没看完，elf倒是看了一点。</p><p>令我高兴的是午觉睡醒得知网鼎杯进线下了(唔)，好像是前面好多队伍不去了0.0</p><p>终于能去线下了，冲冲冲！</p><h3 id="2020-11-11"><a href="#2020-11-11" class="headerlink" title="2020-11-11"></a>2020-11-11</h3><p>单身节快乐（雾</p><p>苹果今天发布了M1芯片，看起来针布戳，如果Win-arm完善的可以的话真的冲了</p><p>SpringDay3完结撒花！明天开始Day4了，考虑到网鼎的事情，问了问imagin师傅awd的事情，准备这两周恶补一下，免得到时候两眼一抹黑</p><h3 id="2020-11-12"><a href="#2020-11-12" class="headerlink" title="2020-11-12"></a>2020-11-12</h3><p>Spring Day4看完一半了，elf也看了很多，nice</p><p>话说我的西湖论剑还剩了两道题…老拖延症了淦</p><h3 id="2020-11-14"><a href="#2020-11-14" class="headerlink" title="2020-11-14"></a>2020-11-14</h3><p>自闭了…上海市大学生ctf的算法好难逆，我一开始听信队友的是个vm，发现并不是，这个是个伪vm，会根据输入来调整算法路径，浪费了很多时间和精力</p><p>到最后逆出来的时候已经写不出脚本了，裂开</p><p>发现代码能力真是越来越差了，复健复健</p><h3 id="2020-11-15"><a href="#2020-11-15" class="headerlink" title="2020-11-15"></a>2020-11-15</h3><p>辣鸡京东，rnm，退钱！刚要打算复健，接了个外包，冲冲冲</p><h3 id="2020-11-16"><a href="#2020-11-16" class="headerlink" title="2020-11-16"></a>2020-11-16</h3><p>Spring完结撒花！开始学习Spring MVC 昨晚肝到好晚，但还是完成了第一单外包，快乐</p><h3 id="2020-11-17"><a href="#2020-11-17" class="headerlink" title="2020-11-17"></a>2020-11-17</h3><p>复健计划启动！</p><h3 id="2020-11-18"><a href="#2020-11-18" class="headerlink" title="2020-11-18"></a>2020-11-18</h3><p>感觉时间好少…随便学学框架，刷一道leetcode就到很晚了</p><p>明天课有点多，冲冲冲</p><h3 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020-11-19"></a>2020-11-19</h3><p>SpringMVC Day1完结撒花~</p><p>今天做的leetcode水的不行，不贴了</p><h2 id="2020-12"><a href="#2020-12" class="headerlink" title="2020-12"></a>2020-12</h2><h3 id="2020-12-19"><a href="#2020-12-19" class="headerlink" title="2020-12-19"></a>2020-12-19</h3><p>懒狗本狗…忘记更新了，上个月去了次深圳之后我就忘记这件事情了，现在突然想起来。</p><p>今天下午玩了一下午docker，对这个东西有了些自己的理解了。明天看看能不能搭上服务</p><p>最近期末考，复习吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这是一个记录学习生活的日记本&quot;&gt;&lt;a href=&quot;#这是一个记录学习生活的日记本&quot; class=&quot;headerlink&quot; title=&quot;这是一个记录学习生活的日记本&quot;&gt;&lt;/a&gt;这是一个记录学习生活的日记本&lt;/h1&gt;&lt;h2 id=&quot;督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信&quot;&gt;&lt;a href=&quot;#督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值-确信&quot; class=&quot;headerlink&quot; title=&quot;督促自己学习为了让以后的自己看看摸鱼的自己增加悔恨值(确信)&quot;&gt;&lt;/a&gt;&lt;del&gt;督促自己学习&lt;/del&gt;为了让以后的自己看看摸鱼的自己增加悔恨值(确信)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
    
      <category term="diary" scheme="http://www.kittener.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术(三)</title>
    <link href="http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/"/>
    <id>http://www.kittener.top/2020/07/13/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%B8%89/</id>
    <published>2020-07-13T04:42:35.000Z</published>
    <updated>2020-07-23T03:18:58.189Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(三)  </p><a id="more"></a>  <h1 id="流程控制语句的识别"><a href="#流程控制语句的识别" class="headerlink" title="流程控制语句的识别"></a>流程控制语句的识别</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句只能判断两种情况:“0”为假值，“非0”为真值。如果为真值，则进人语句块内执行语句;如果为假值，则跳过if语句块，继续运行程序的其他语句。要注意的是，if语句转换的条件跳转指令与if语句的判断结果是相反的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：if语句结构组成</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">printf(&quot;%d \r\n&quot;, argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;如果argc &#x3D; 0的情况，为真</span><br><span class="line">if( argc &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F;使用cmp指令，将ebp+8地址的4字节和0相减</span><br><span class="line">&#x2F;&#x2F;结果argc不改变，淡水会改变CF,ZF,OF,AF和PF</span><br><span class="line">00401028cmpdword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;JNE看ZF，如果等于0跳转，表示现在的argc不等于0</span><br><span class="line">&#x2F;&#x2F;跳转到0x40103F</span><br><span class="line">&#x2F;&#x2F;这个地址为if的结束地址，之后跳转出if</span><br><span class="line">0040102Cjnemain+2F(0040103f)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;函数返回</span><br><span class="line">return 0;</span><br><span class="line">0040103Fxoreax,eax</span><br></pre></td></tr></table></figure><p>出现这种情况是因为汇编语言的条件跳转是满足某条件则跳转，绕过某些代码块，这一点是与C语言<strong>相反</strong>的，而C语言编译器不将else语句块提到if语句块前面是因为C语言是根据<strong>代码行的位置来决定编译后的二进制代码的地址高低的</strong>，也就是说，低行数对应低地址，高行数对应高地址</p><p>根据这一特性，如果将if语句中的比较条件 “argc==0” 修改为 “if(argc &gt; 0)”，则其对应的汇编语言所使用的条件跳转指令会是“小于等于0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if语句大于0比较</span><br><span class="line">if( argc &gt; 0 )&#123;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码</span><br><span class="line">&#x2F;&#x2F;C++源码对比，如果参数argc大于0，结果为真，进入执行语句</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">&#x2F;&#x2F;使用cmp，将ebp+8地址的4字节数据和0进行减法</span><br><span class="line">0040103Fcmp dword ptr [ebp+8],0</span><br><span class="line">00401043jleMyIf + 42h (00401052)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">&#125;</span><br><span class="line">00401052pop edi</span><br></pre></td></tr></table></figure><p>在分析过程中，表达式短路(上一篇blog的内容)和if语句这两种分支结构的实现结构都是一样的，蛮难区分的</p><p><strong>总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">；先执行各类影响标志位的指令</span><br><span class="line">；其后是各种条件跳转指令</span><br><span class="line">jxxxxxx</span><br></pre></td></tr></table></figure><p>如果遇上以上指令序列，大概率是一个if语句组成的单分支结构</p><h2 id="if···else···语句"><a href="#if···else···语句" class="headerlink" title="if···else···语句"></a>if···else···语句</h2><p>if和if···else···的流程对比</p><p><img src="P1.jpg" alt="结构对比"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明: if  else</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">printf(&quot;argc &#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;argc !&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">004010B8cmpdword ptr [ebp+8],0 &#x2F;&#x2F;相减</span><br><span class="line">004010BCjneIfElse+2Dh(004010cd)&#123;</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">&#125;</span><br><span class="line">004010CBjmpIfElse+3Ah (004010da)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;进入else</span><br><span class="line">004010CDpush offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">004010D2call printf (00401150)</span><br><span class="line">004010D7addesp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结束</span><br><span class="line">004010DApop edi</span><br></pre></td></tr></table></figure><p>将上述代码稍作改动，改为符合条件表达式转换方式1的形式，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，if...else..模拟条件表达式转换方式</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">argc &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">argc &#x3D; 6;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc); &#x2F;&#x2F;防止argc被优化处理</span><br><span class="line">&#x2F;&#x2F;对应汇编，debug版，无优化</span><br><span class="line">if(argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">00401098cmpdword ptr [ebp+8],0</span><br><span class="line">0040109cjnemain+27h(004010a7)</span><br><span class="line">argc &#x3D; 5;</span><br><span class="line">0040109Emovdword ptr [ebp+8],5</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">004010A5jmpmain+2Eh(004010ae)</span><br><span class="line">argc &#x3D; 6;</span><br><span class="line">004010A7mov dword ptr [ebp+8],6</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d \r\n&quot;,argc);</span><br><span class="line">&#x2F;&#x2F;略</span><br><span class="line">004010AE...</span><br></pre></td></tr></table></figure><p>还是挺简单的，总结一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">总结结构：</span><br><span class="line">&#x2F;&#x2F;产生修改标志位的指令</span><br><span class="line">jxx else_begin</span><br><span class="line">if begin:</span><br><span class="line">&#x2F;&#x2F;执行if中的内容</span><br><span class="line">if end:</span><br><span class="line">jmp else end</span><br><span class="line">else begin:</span><br><span class="line">&#x2F;&#x2F;执行else的内容</span><br><span class="line">else end</span><br></pre></td></tr></table></figure><p>这两个跳转指令就是辨识的关键，不过和条件表达式差不多，所以反推的时候看个人习惯</p><p>上面那份代码是debug版，下面给个O2优化的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取到的参数数据放在edx中</span><br><span class="line">movedx,[esp+argc_0]</span><br><span class="line">&#x2F;&#x2F;将eax清0</span><br><span class="line">xoreax,eax</span><br><span class="line">&#x2F;&#x2F;对edx和edx进行想与的操作，结果不影响edx</span><br><span class="line">test edx,edx</span><br><span class="line">&#x2F;&#x2F;检查ZF的标记位，edx不等于0的时候，我们的al &#x3D; 1，等于0 我们的al &#x3D; 0</span><br><span class="line">setnz al</span><br><span class="line">add eax,5 &#x2F;&#x2F;这里可能是5&#x2F;6，看al了，我们不等于0，那么就是6，我们等于0，那么就是5</span><br><span class="line">push eax</span><br><span class="line">push offset Format ; &quot;%d \r\n&quot;</span><br><span class="line">call _printf</span><br><span class="line">addesp,8</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>可以看到优化了很多，做了一个流水线优化，还是蛮难还原回去的</p><h2 id="用if构成的多分支流程"><a href="#用if构成的多分支流程" class="headerlink" title="用if构成的多分支流程"></a>用if构成的多分支流程</h2><p>多分支结构就是if···else if···else if···else···这种结构，直接看代码吧，这是debug版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，多分支结构</span><br><span class="line">void IfElseIf(int argc)&#123;</span><br><span class="line">if (argc &gt; 0)&#123;</span><br><span class="line">printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (argc &#x3D;&#x3D; 0)&#123;</span><br><span class="line">printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;argc &lt;&#x3D; 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">if(argc &gt; 0)</span><br><span class="line">00401108cmpdword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;相减 argc-0 之后使用小于等于跳转的条件,jle</span><br><span class="line">0040110CjleIfElseIf+2Dh(0040111d) &#x2F;&#x2F;到else位置，目测那边是一个cmp 一个jne&#123;</span><br><span class="line">printf(&quot;argc &gt; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">0040110Epush offset string &quot;argc &gt; 0&quot;(00420f9c)</span><br><span class="line">00401113call printf(00401150)</span><br><span class="line">00401118addesp,4</span><br><span class="line">&#125;</span><br><span class="line">else if ( argc &#x3D;&#x3D; 0 )</span><br><span class="line">0040111BjmpIfElseIf+4Fh(0040113f)</span><br><span class="line">&#x2F;&#x2F;if比较转换，和我上面目测的差不多一个cmp，一个jne</span><br><span class="line">0040111Dcmpdword ptr [ebp+8],0</span><br><span class="line">00401121jneIfElseIf+42h(00401132) &#x2F;&#x2F;到下一个else的位置，直接就是执行了</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &#x3D;&#x3D; 0&quot;);</span><br><span class="line">&#x2F;&#x2F;printf 略</span><br><span class="line">00401123push offset string &quot;argc &#x3D;&#x3D; 0&quot;(0042003c)</span><br><span class="line">00401128call printf(00401150)</span><br><span class="line">0040112Dadd esp,4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳转到多分支结构结束地址</span><br><span class="line">00401130jmpIfElseIf+4Fh(0040113f)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argc &lt; &#x3D; 0&quot;);&#x2F;&#x2F;上面都不满足，无条件执行</span><br><span class="line">&#x2F;&#x2F;printf略</span><br><span class="line">00401132push offset string &quot;argc !&#x3D; 0&quot; (00420030)</span><br><span class="line">00401137call printf (00401150)</span><br><span class="line">0040113Caddesp,4</span><br><span class="line">&#125;</span><br><span class="line">0040113Fpopedi</span><br></pre></td></tr></table></figure><p>debug版的代码看着还是舒适，就是一个很简单的cmp+跳转指令，来个总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else if begin</span><br><span class="line">if begin:</span><br><span class="line">...</span><br><span class="line">if end:</span><br><span class="line">jmp end</span><br><span class="line">else if begin:</span><br><span class="line">&#x2F;&#x2F;影响标志位</span><br><span class="line">jxx else begin</span><br><span class="line">...</span><br><span class="line">else if end:</span><br><span class="line">jmp end</span><br><span class="line">else begin</span><br><span class="line">...</span><br><span class="line">end:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在编译期间，永远不可抵达的分支将被优化掉而不参与编译处理，在写代码的时候，可以在每个else if的代码块里加个return，这样就可以减少分支比较。</p><p>看一下开启O2优化的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 sub_401000proc near ; CODE XREF: _main+5p</span><br><span class="line">&#x2F;&#x2F;arg_0为函数参数</span><br><span class="line">.text:00401000 arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;取出参数数据，放入eax，进行第一次if比较</span><br><span class="line">.text:00401000mov eax,[esp+arg_0]</span><br><span class="line">.text:00401004test eax,eax</span><br><span class="line">&#x2F;&#x2F;比较后进行转移，目测jle</span><br><span class="line">.text:00401006jleshort loc_401016</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">.text:00401008push offset Format ; &quot;argc &gt; 0&quot;</span><br><span class="line">.text:0040100Dcall _printf</span><br><span class="line">.text:00401012add esp,4</span><br><span class="line">&#x2F;&#x2F;使用retn指令返回，结束函数调用</span><br><span class="line">.text:00401015retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代表此处代码被符号sub_401000地址加6的地方引用</span><br><span class="line">.text:00401016 loc_401006: ;CODE XREF: sub_401000+6j</span><br><span class="line">&#x2F;&#x2F;这里目测因为有test的问题 直接jne就可以</span><br><span class="line">.text:00401018push offset aArgc0_0 ; &quot;argc &#x3D;&#x3D; 0&quot;</span><br><span class="line">.text:0040101Dcall _printf</span><br><span class="line">.text:00401022add esp,4</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">.text:00401025retn</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前两次失败没返回直接执行此处</span><br><span class="line">.text:00401026loc_401026: ; CODE XREF: sub_401000:loc_401016j</span><br><span class="line">.text:00401026push offset aArgc0_1; &quot;argc &lt;&#x3D; 0&quot;</span><br><span class="line">.text:0040102Bcall _printf</span><br><span class="line">.text:00401030pop ecx</span><br><span class="line">.text:00401031retn</span><br><span class="line">.text:00401031sub_401000endp</span><br></pre></td></tr></table></figure><p>有内味了，看来现在的出题人都喜欢开O2优化</p><h2 id="switch的真相"><a href="#switch的真相" class="headerlink" title="switch的真相"></a>switch的真相</h2><p>看一下3条case语句的switch跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">switch (nIndex&#125; &#123;&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF00movecx, dword ptr [ebp-4]</span><br><span class="line">;取出变量nIndex的值并放到ecx中，再将ecx放入临时变量ebp - 8中</span><br><span class="line">0040DF03movdword ptr [ebp-8] , ecx</span><br><span class="line">;将临时变量和1进行比较</span><br><span class="line">0040DF06cmpdword ptr [ebp-8] ,1</span><br><span class="line">;条件跳转比较，等于1则跳转到地址0x0040DF1A处</span><br><span class="line">0040DF0A jeSwitchIf+4Ah (0040df1a)</span><br><span class="line">;将临时变量和3比较</span><br><span class="line">0040DFOCcmpdword ptr [ebp-8] ,3</span><br><span class="line">;条件跳转比较，等于3则跳转到地址0x0040DF29处</span><br><span class="line">0040DF10jeSwitchIf+59h (0040df29)</span><br><span class="line">;将临时变量和100比较</span><br><span class="line">0040DF12cmpdword ptr [ebp-8] , 64h</span><br><span class="line">;条件跳转比较，等于100则跳转到地址0x0040DF38处</span><br><span class="line">0040DF16jeSwitchIf+68h (0040df38)</span><br><span class="line">0040DF18jmpSwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 1:    &#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;  &#x2F;&#x2F;源码对比</span><br><span class="line">0040DF1Apushoffset string &quot;nIndex &#x3D;&#x3D; 1&quot; (00421024)</span><br><span class="line">0040DF1Fcallprintf (004014b0)</span><br><span class="line">0040DF24addesp,4</span><br><span class="line">break;&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF27jmpSwitchIf+75h (0040df45)</span><br><span class="line"></span><br><span class="line">case 3:&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF29pushoffset string &quot;nIndex &#x3D;&#x3D; 3&quot; (004210d8)</span><br><span class="line">0040DF2Ecallprintf (004014b0)</span><br><span class="line">0040DF33addesp,4</span><br><span class="line"></span><br><span class="line">case 100:&#x2F;&#x2F;源码对比</span><br><span class="line">printf (&quot;nIndex &#x3D;&#x3D; 100&quot;); &#x2F;&#x2F; 源码对比</span><br><span class="line">0040DF38pushoffset string &quot;nIndex &#x3D;&#x3D; 100&quot; (0042004c)</span><br><span class="line">0040DF3Dcallprintf (004014b0)</span><br><span class="line">0040DF42addesp,4</span><br><span class="line">break;</span><br><span class="line">&#125;&#125;&#x2F;&#x2F;源码对比</span><br><span class="line">0040DF45popedi</span><br></pre></td></tr></table></figure><p>可以看到与if···else差距还是挺大的，if···else是跳转后跟着语句块，而switch结构则将所有的条件跳转都放在了一起。这样就实现了C语法的要求，在case语句块中没有break语句时，可以顺续执行后续case语句块</p><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">movreg, mem;取出switch中考察的变量</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxxxxxx; 跳转到对应case语句块的首地址</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxxxxxx</span><br><span class="line">; 影响标志位的指令</span><br><span class="line">jxxxxxx</span><br><span class="line">jmpEND; 跳转到switch的结尾地址处</span><br><span class="line">......; case语句块的首地址</span><br><span class="line">jmpEND; case语句块结束，有break则产生这个jmp</span><br><span class="line">&#x2F;&#x2F;下同</span><br><span class="line">END:; switch结尾</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这是switch分支数小于4的情况下，VC++ 6.0采用的策略，当分支数大于3时，并且case的判定值存在明显线性关系组合时，switch的优化特性便可以凸显出来，如代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++示例代码</span><br><span class="line">int nIndex &#x3D; 0;</span><br><span class="line">scanf (&quot;%d&quot;, &amp; nIndex) ;</span><br><span class="line">switch (nIndex) &#123;</span><br><span class="line">case 1: printf (&quot;nIndex &#x3D;&#x3D; 1&quot;) ;break;</span><br><span class="line">case 2: printf (&quot;nIndex &#x3D;&#x3D; 2&quot;) ;break;</span><br><span class="line">case 3: printf (&quot;nIndex &#x3D;&#x3D; 3&quot;) ;break;</span><br><span class="line">case 5: printf (&quot;nIndex &#x3D;&#x3D; 5&quot;) ;break;</span><br><span class="line">case 6: printf (&quot;nIndex &#x3D;&#x3D; 6&quot;) ;break;</span><br><span class="line">case 7: printf (&quot;nIndex &#x3D;&#x3D; 7&quot;) ;break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;debug版</span><br><span class="line">switch (nIndex)&#123;&#x2F;&#x2F;源码对比</span><br><span class="line">;将变量nIndex内容放入ecx中</span><br><span class="line">00401110movecx, dword ptr [ebp-4]</span><br><span class="line">;取出ecx的值并放入临时变量ebp-8中</span><br><span class="line">00401113movdword ptr [ebp-8] , ecx </span><br><span class="line">;取临时变量的值放入edx中，这几句代码的功能看似没有区别</span><br><span class="line">;只有在Debug版下才会出现</span><br><span class="line">00401116movedx, dword ptr [ebp-8]</span><br><span class="line">;对edx减1,进行下标平衡</span><br><span class="line">00401119subedx, 1</span><br><span class="line">;将减1后的临时变量放回</span><br><span class="line">0040111C movdword ptr [ebp-8] , edx</span><br><span class="line">;判断临时变量是否大于6</span><br><span class="line">0040111Fcmpdword ptr [ebp-8] ,6</span><br><span class="line">;大于6跳转到0x00401187处</span><br><span class="line">00401123 ja$L556+0Dh (00401187)</span><br><span class="line">;取出临时变量的值放到eax中</span><br><span class="line">00401125moveax, dword ptr [ebp-8] </span><br><span class="line">;以eax为下标，0x00401198为基址进行寻址，跳转到该地址处</span><br><span class="line">;注意:地址0x00401198就是case地址数组</span><br><span class="line">00401128jmpdword ptr [eax*4+401198h]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将case语句块的首地址保存在一个数组中，并且数组下标以0为起始，在进入switch后会先进行一次比较，检查输入的值是否大于case的最大值。case地址数组如下：</p><p><img src="P2.jpg" alt="有序线性case地址表"></p><p>如果每两个case值之间的差值小于等于6，并且case语句数大于等于4,编译器中就会形成这种线性结构。在编写代码的过程中无需有序排列case值，编译器会在编译过程中对case线性地址表进行排序，如case的顺序为3、2、1、 4、5，在case线性地址表中，会将它们的语句块的首地址进行排序，将case 1语句块的首地址放在case线性地址表的第0项上,case 2语句块首地址放在表中第1项，以此类推，将首地址变为一个有序的表格进行存放，如图</p><p><img src="P3.jpg" alt="模拟图"></p><p>给出release版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;取出switch语句的参数值并放入ecx中</span><br><span class="line">00401018movecx, dword ptr [esp+8]</span><br><span class="line">0040101Caddesp, 8;平衡scanf函数的参数</span><br><span class="line"></span><br><span class="line">;将ecx减1后放入eax中，因为最小的case 1存放在case地址表中下标为0处，需要调整对齐到0下标，便于直接查表</span><br><span class="line">0040101Fleaeax, [ecx-1]</span><br><span class="line">;与6进行比较，有了这两步操作可以初步假设这里的代码是一个switch结构</span><br><span class="line">;无符号比较，大于6时跳转到地址0x00401086处</span><br><span class="line">00401022cmpeax,6</span><br><span class="line">00401025ja00401086</span><br><span class="line"></span><br><span class="line">;下面的指令体现了switch的第二个特性;查表(case地址表)</span><br><span class="line">;可以确认这是一个switch结构</span><br><span class="line">;上一步的跳转地址00401086就是switch结尾或者是default语句块的首地址</span><br><span class="line">;下面指令中的地址0x00401088便是case线性地址表的首地址</span><br><span class="line">00401027jmpdword ptr [eax* 4+401088h]</span><br><span class="line">;地址0x0040706C为字符串&quot;nIndex &#x3D;&#x3D; 1&quot;的首地址</span><br><span class="line">;此处为第一个case语句块的地址</span><br><span class="line">0040102Epush40706Ch</span><br><span class="line">&#x2F;&#x2F;调用printf函数</span><br><span class="line">00401033call004012F0</span><br><span class="line">;平衡printf函数破坏的栈空间</span><br><span class="line">00401038addesp,4</span><br><span class="line">;还原esp</span><br><span class="line">0040103Bpopecx</span><br><span class="line">;返回，在Release版中，煸译器发现switch后什么也没做就直接返回，所以</span><br><span class="line">;将每句break优化为了return</span><br><span class="line">;到此处，第一-个case语句块结束，顺序向下为第二个case语句块</span><br><span class="line">0040103Cret</span><br><span class="line"></span><br><span class="line">;第二个case语句块</span><br><span class="line">;地址0x00407060为字符串&quot;nIndex m&#x3D; 2&quot;的首地址</span><br><span class="line">0040103Dpush407060h</span><br><span class="line">00401042call004012F0</span><br><span class="line">00401047addesp,4</span><br><span class="line">0040104Apopecx</span><br><span class="line">0040104Bret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面代码类似，不写了</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movreg,mem;取变量</span><br><span class="line">;对变量进行运算，对齐case地址表的0下标，非必要</span><br><span class="line">;上例中的eax也可用其他寄存器替换，这里也可以是其他类型的运算</span><br><span class="line">leaeax,[reg+xxxx]</span><br><span class="line"></span><br><span class="line">;影响标志位的指令，迸行范围检查</span><br><span class="line">jxxDEFAULT_ADDR</span><br><span class="line">jmpdword ptr [eax*4+xxxx]; 地址xxxx为case地址表的首地址</span><br></pre></td></tr></table></figure><p>当遇到这样的代码块时，可获取某一变量的信息并对其进行范围检查，如果超过case的最大值，则跳转条件成立，跳转目标指明了switch语句块的末尾或者是default块的首地址。条件跳转后紧跟jmp指令，并且是相对比例因子寻址方式，且基址为地址表的首地址，说明此处是线性关系的switch分支结构</p><h2 id="难以构成跳转表的switch"><a href="#难以构成跳转表的switch" class="headerlink" title="难以构成跳转表的switch"></a>难以构成跳转表的switch</h2><p>对于两个case值间隔较大时，编译器用索引表来优化，索引表优化需要两张表：一张为case语句块地址表，另一张为case语句块索引表。</p><p>地址表中的每一项保存一个case语句块的首地址，有几个case语句块就有几项。default语句块也在其中，如果没有则保存一个switch结束地址。这个结束地址在地址表中只会保存一份，不会像有序线性地址表那样，重复保存switch的结束地址。</p><p>索引表中保存地址表的编号，它的大小等于最大case值和最小case值的差。当差值大于255时，这种优化方案也会浪费空间，可通过树方式优化，这里就只讨论差值小于或等于255的情况。表中的每- -项为- 一个字节大小，保存的数据为case语句块地址表中的索引编号。</p><p>首先将所有case语句块的首地址保存在-一个地址表中，<strong>地址表</strong>中的表项个数会根据程序中case分支来决定。有多少个case分支，地址表就会有多少项。<strong>索引表</strong>，中保存了地址表中的下标值。索引表中最多可以存储256项，每- -项的大小为 1字节，这决定了case值不可以超过1字节的最大表示范围(0~255)， 因此索引表也只能存储256项索引编号。</p><p><img src="P4.jpg" alt="索引表结构模拟图"></p><p>具体的参考这个<a href="https://www.cnblogs.com/ye-ming/articles/7942472.html" target="_blank" rel="noopener">blog</a>吧，写的很好</p><h2 id="do-while-for的比较"><a href="#do-while-for的比较" class="headerlink" title="do/while/for的比较"></a>do/while/for的比较</h2><p>do循环是向上跳转例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DO_BEGIN</span><br><span class="line">······；循环语句块</span><br><span class="line">cmp xxxx&#x2F;test xxxx&#x2F;sub xxxx&#x2F;·····；影响标记位的指令</span><br><span class="line">jxx DO_BEGIN   ; 向上跳转</span><br></pre></td></tr></table></figure><p>while循环是先进行判断，向下跳转，到单次循环结束时，向上跳转，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE_BEGIN:</span><br><span class="line">; 影响标记位的指令</span><br><span class="line">jxxWHILE_END; 条件成立跳转到循环语句块结尾处</span><br><span class="line">······; 循环语句块</span><br><span class="line">jmpWHILE_BEGIN; 跳转到取出条件比较数据处</span><br><span class="line">WHILE_END;</span><br></pre></td></tr></table></figure><p>for循环由赋初值、设置循环条件、设置循环步长这三条语句组成</p><p>for循环比较复杂，看一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int LoopFor (int nCount&#125; &#123;</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;初始计数器变量、设置循环条件、设置循环步长</span><br><span class="line">for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount; nIndex++) &#123;</span><br><span class="line">nSum +&#x3D; nIndex;</span><br><span class="line">&#125;</span><br><span class="line">return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇煸代码讲解</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">0040B818movdword ptr [ebp-4] ,0</span><br><span class="line">&#x2F;&#x2F; C++源码对比，for语句</span><br><span class="line">for (int nIndex &#x3D; 0; nIndex &lt;&#x3D; nCount;nIndex++)</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 初始化计数器变量--nIndex1.赋初值部分</span><br><span class="line">0040B81Fmovdword ptr [ebp-8] ,0</span><br><span class="line">; 跳转到地址0x0040B831处，跳过步长操作</span><br><span class="line">00408826jmpLoopFor+31h (0040b831)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">; 取出计数器变量，用于循环步长2.步长计算部分</span><br><span class="line">0040B828moveax, dword ptr [ebp-8]</span><br><span class="line">; 对计数器变量执行加1操作，步长值为1</span><br><span class="line">0040B82Baddeax,1</span><br><span class="line">;将加1后的步长值放回计数器变量一nIndex</span><br><span class="line">0040B82Emovdword ptr [ebp-8] ，eax</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;取出计数器变量nIndex放入ecx3.条件比较部分</span><br><span class="line">0040B831movecx, dword ptr [ebp-8]</span><br><span class="line">; ebp+8地址处存放数据为参数nCount, 见C++源码说明</span><br><span class="line">0040B834cmpecx, dword ptr [ebp+8]</span><br><span class="line">; 比较nIndex与nCount, 大于则跳转到地址0x0040B844处，结柬循环</span><br><span class="line">0040B837jdLoopFor+44h (0040b844)</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; for循环内执行语句块4.循环体代码</span><br><span class="line">nSum +&#x3D; nIndex;</span><br><span class="line">movedx, dword ptr [ebp-4]</span><br><span class="line">0040B83Caddedx, dword ptr [ebp-8]</span><br><span class="line">0040B83Fmovdword ptr [ebp-4] , edx</span><br><span class="line">&#125;</span><br><span class="line">;跳转到地址0x0040B828处，这是一个向上跳</span><br><span class="line">0040B842jmpLoopFor+28h (0040b828)</span><br><span class="line">return nSum;</span><br><span class="line">&#x2F;&#x2F;设置返回值eax为ebp-4， 即nSum</span><br><span class="line">0040B844moveax, dword ptr [ebp-4]</span><br></pre></td></tr></table></figure><p>以上，可以看到代码分为四个部分，总结一下就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">movmem&#x2F; reg, xxx;賦初值</span><br><span class="line">jmpFOR_CMP;跳到循环条件判定部分</span><br><span class="line">FOR_STEP:;步长计算部分</span><br><span class="line">;修改循环变量Step</span><br><span class="line">movreg,Step</span><br><span class="line">addreg,xxxx ;修改循环变量的计算过程，在实际分析中，视算法不同而不同</span><br><span class="line">movStep,eax</span><br><span class="line">FOR_CMP:;循环条件判定部分</span><br><span class="line">movecx, dword ptr Step</span><br><span class="line">;判定循环变量和循环终止条件StepEnd 的关系，满足条件则逞出for循环</span><br><span class="line">cmpecx,StepEnd</span><br><span class="line">jxxFOR_END;条件成立则结柬循环</span><br><span class="line">·····</span><br><span class="line">jmpFOR_STEP;向上跳转，修改流程回到步长计算部分</span><br><span class="line">FOR_END;</span><br></pre></td></tr></table></figure><p>这种结构是for循环独有的，在计数器变量被赋初值后，利用jmp跳过第一次步长计算。然后，可以通过三个跳转指令还原for循环的各个组成部分:第一个jmp指令之前的代码为初始化部分;从第一个jmp指令到循环条件比较处( 也就是上面代码中FOR_ _CMP 标号的位置)之间的代码为步长计算部分;在条件跳转指令jxx之后寻找一个jmp指令，这jmp指令必须是向上跳转的，且其目标是到步长计算的位置，在jxx和这个jmp(也就是上面代码中省略号所在的位置)之间的代码即为循环语句块。</p><h2 id="编译器对循环结构的优化"><a href="#编译器对循环结构的优化" class="headerlink" title="编译器对循环结构的优化"></a>编译器对循环结构的优化</h2><p>while和for循环在O2优化中，都会被优化成do的形式，而结构被优化后，细节上还能被再次优化</p><ol><li><p>代码外提</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明:for循环完成整数累加和</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">int nIndex &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">nSum +&#x3D; nIndex;</span><br><span class="line">nIndex++ ;</span><br><span class="line">&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">&#125; while (nIndex &lt; nCount - 1) ;</span><br><span class="line">return nSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;经过优化后的反汇编代码</span><br><span class="line">. text : 00401000 sub_ 401000proc near; CODE XREF:_ main+21↑p</span><br><span class="line">. text :00401000 arg_ 0&#x3D; dword ptr 4</span><br><span class="line">;荻取参数到edx中</span><br><span class="line">. text : 00401000movedx，[esp+arg_0]</span><br><span class="line">. text : 00401004xoreax,eax</span><br><span class="line">. text : 00401006xorecx,ecx</span><br><span class="line">;代码外提，对edx执行自减1操作</span><br><span class="line">. text : 00401008decedx</span><br><span class="line">;进入循环体，在循环体内直接对保存参数的edx进行比较，没有任何减1操作</span><br><span class="line">. text : 00401009 loc 401009:: CODE XREF: sub_ 401000+E↑j</span><br><span class="line">. text : 00401009addeax, ecx </span><br><span class="line">. text : 0040100Bincecx</span><br><span class="line">. text : 0040100C cmpecx,edx</span><br><span class="line">. text : 0040100E   jlshort loc_401009</span><br><span class="line">. text : 00401010retn</span><br><span class="line">. text : 00401010 sub_401000endp</span><br><span class="line"></span><br><span class="line">也就是被优化成了</span><br><span class="line">int CodePick (int nCount) &#123;</span><br><span class="line">int nSum &#x3D; 0;</span><br><span class="line">int nIndex &#x3D; 0;</span><br><span class="line">nCount -&#x3D; 1;</span><br><span class="line">do &#123;</span><br><span class="line">nSum +&#x3D; nIndex;</span><br><span class="line">nIndex++ ;</span><br><span class="line">&#x2F;&#x2F;此处代码每次都要判断nCount一1, nCount并没有自减，仍然为一个固定值</span><br><span class="line">&#x2F;&#x2F;可在循环体外先对nCount进行减等于1操作，再进入循环体</span><br><span class="line">&#125; while (nIndex &lt; nCount) ;</span><br><span class="line">return nSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.强度削弱</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:强度削弱</span><br><span class="line">int main(int argc) &#123;</span><br><span class="line">int t&#x3D;0;</span><br><span class="line">int i&#x3D;0;</span><br><span class="line">while (t &lt; argc) &#123;</span><br><span class="line">t &#x3D; i * 99; &#x2F;&#x2F;强度削弱后，这里将不会使用乘法运算</span><br><span class="line">i++;&#x2F;&#x2F;此处转换后将为  t &#x3D; i; i +&#x3D; 99</span><br><span class="line">&#125;&#x2F;&#x2F;利用加法运算替换掉了指令周期长的乘法运算</span><br><span class="line">printf(&quot;%d&quot;,t);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;优化后的反汇编代码</span><br><span class="line">. text : 00401020 arg_0&#x3D; dword ptr 4</span><br><span class="line">;将参数信息保存到edx中</span><br><span class="line">. text : 00401020movedx, [esp+arg_0]</span><br><span class="line">. text : 00401024xoreax,eax; 清空eax</span><br><span class="line">. text : 00401026testedx,edx</span><br><span class="line">. text : 00401028jleshort loc_401035</span><br><span class="line">. text : 0040102Axorecx,ecx; 清空ecx</span><br><span class="line">. text : 0040102C</span><br><span class="line">;循环语句玦首地址</span><br><span class="line">. text : 0040102C loc_ 40102C:; CODE XREF: sub_ 401020+13↑j</span><br><span class="line">. text : 0040102Cmoveax,ecx; 将ecx传入eax中</span><br><span class="line">;ecx自加63h，即十进制99，等价于ecx每次加1乘以99.</span><br><span class="line">. text : 0040102Eaddecx,63h</span><br><span class="line">. text : 00401031cmpeax,edx</span><br><span class="line">. text : 00401033jlshort loc_40102C; eax小于edx则执行跳转</span><br><span class="line">. text : 00401035</span><br><span class="line">. text : 00401035 loc_401035:; CODE XREF: sub_ 401020+8↑j</span><br><span class="line">;printf函数调用处略</span><br><span class="line">. text : 00401043retn</span><br><span class="line">. text :00401043 sub_401020endp</span><br></pre></td></tr></table></figure><h1 id="函数工作原理"><a href="#函数工作原理" class="headerlink" title="函数工作原理"></a>函数工作原理</h1><h2 id="栈帧的形成和关闭"><a href="#栈帧的形成和关闭" class="headerlink" title="栈帧的形成和关闭"></a>栈帧的形成和关闭</h2><p>当栈顶指针esp小于栈底指针ebp时，就形成了栈帧</p><p><strong>栈平衡</strong>：</p><p>​    不同的两次函数调用，所形成的栈帧也不相同。当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的栈帧。当这个函数结束调用时，需要清除掉它所使用的栈空间，关闭栈帧，我们把这一过程称为栈平衡。</p><p>给一个小demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:一个空函数</span><br><span class="line">int main() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应的汇编代码讲解</span><br><span class="line">int main()&#123;</span><br><span class="line">; 以下是进入函数时的代码</span><br><span class="line">00401010pushebp;进入函数后的第一件事，保存栈底指针ebp</span><br><span class="line">00401011movebp,esp;调整当前栈底指针位置到栈顶</span><br><span class="line">00401013subesp,40h ;抬高栈顶esp,此时开辟栈空间0x40，作为局部变量的存储空间</span><br><span class="line">00401016pushebx;保存寄存器ebx</span><br><span class="line">00401017pushesi;保存寄存器esi</span><br><span class="line">00401018pushedi;保存寄存器edi</span><br><span class="line">00401019leaedi, [ebp-40h] ;取出此函数可用栈空间首地址</span><br><span class="line">0040101Cmovecx,10h ;设置ecx为0x10</span><br><span class="line">00401021moveax, 0CCCCCCCCh ;将局部变量初始化为0CCCCCCCCh</span><br><span class="line"></span><br><span class="line">;根据ecx的值，将eax中的内容，以4字节为单位写到edi指向的内存中</span><br><span class="line">00401026rep stos dword ptr [edi]</span><br><span class="line"></span><br><span class="line">;以下是用户编写的函数实现代码</span><br><span class="line">return 0;</span><br><span class="line">0040102Axoreax,eax;设置返回值为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;以下是函数退出时的代码</span><br><span class="line">0040102Cpopedi ;还原寄存器edi</span><br><span class="line">0040102Dpopesi;还原寄存器esi</span><br><span class="line">0040102Epopebx ;还原寄存器ebx</span><br><span class="line">0040102Faddesp,40h ;降低栈顶esp,此时局部变量空间被释放</span><br><span class="line">00401032cmpebp,esp ;检测栈平衡，如ebp与esp不等，则不平衡</span><br><span class="line">00401034call_chkesp (00401050);进入栈平衡错误裣测函数</span><br><span class="line">00401039movesp,ebp ;还原esp</span><br><span class="line">0040103Bpopebp</span><br><span class="line">0040103Cret</span><br></pre></td></tr></table></figure><h2 id="各种调用方式"><a href="#各种调用方式" class="headerlink" title="各种调用方式"></a>各种调用方式</h2><p>由于函数自身无法对不定参数执行平衡操作，所以有了函数的调用约定：</p><ul><li>_cdecl : CIC++默认的调用方式，调用方平衡栈，不定参数的函数可以使用。</li><li>_stdcall : 被调方平衡栈，不定参数的函数无法使用。</li><li>_fastcall : 寄存器方式传参，被调方平衡栈，不定参数的函数无法使用。</li></ul><p>_cdecl  与 _stdcall 的对比，debug版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_cdecl、_stdcall 两种调用方式的区别</span><br><span class="line">void _stdcall Showstd (int nNumber)&#123;&#x2F;&#x2F; 使用_stdca1l 调用方式，被调方平衡栈</span><br><span class="line">printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">void _cdecl ShowCde (int nNumber)&#123;&#x2F;&#x2F; 使用_ _cdecl 调用方式，调用方平衡栈</span><br><span class="line">printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">ShowStd(5);&#x2F;&#x2F;不会有平衡栈操作</span><br><span class="line">ShowCde(5);&#x2F;&#x2F;函数调用结柬后，对esp平衡4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码于对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++源码对比，_stdcall调用方式</span><br><span class="line">void _stdcall ShowStd (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">00401059ret4 ;结柬后平衡栈顶4，等价esp +&#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，_cdecl 调用方式</span><br><span class="line">void _cdec1 ShowCde (int nNumber)</span><br><span class="line">;略去部分代码</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;printf 函数实现略</span><br><span class="line">printf(&quot;%d \r\n&quot;,nNumber);</span><br><span class="line">&#125;</span><br><span class="line">;略去部分代码</span><br><span class="line">004010A9ret;没有平衡操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用 _stdcall方式调用函数Showstd</span><br><span class="line">ShowStd(5) ;</span><br><span class="line">0040B7C8push5 ;函数传参，使用push指令esp-4</span><br><span class="line">0040B7CAcall@ILT+10 (show) (0040100f) ;没有对esp操作的指令</span><br><span class="line">&#x2F;&#x2F; C++源码对比，使用_cdecl方式调用函数ShowCde</span><br><span class="line">ShowCde(5) ;</span><br><span class="line">0040B7CFpush5 ;函数传参，使用push指令esp-4</span><br><span class="line">0040B7D1call@ILT+15 (ShowCde) (00401014) </span><br><span class="line">0040B7D6addesp,4;esp +&#x3D; 4,平衡栈顶</span><br></pre></td></tr></table></figure><p>虽然区别明显，但是不能当作区分依据，因为汇编语言可能会在其他地方平衡栈~</p><p><strong>在O2优化下，_cdecl会采取复写传播优化，将每次参数平衡的操作进行归并，一次性平衡栈顶指针esp。</strong></p><p>_cdecl  调用方式的函数在同一作用域内多次使用， 会在效率上比  _stdcal l 高一点，这是因为  __cdecl 可以使用复写传播，而 _ stdcall 都在函数内平衡参数，无法使用复写传播这种优化方式。在这三种调用方式中， _ fastcall 调用方式的效率最高，其他两种调用方式都是通过栈传递参数，唯独 _ fastcall 可以利用寄存器传递参数。但由于寄存器数目很少，而参数相比可以很多，只能量力而行，故 _fastcall 调用方式只使用了ecx和edx,分别传递第-一个参数和第二个参数，其余参数传递则转换成栈传参方式。</p><p>来份_fastcall代码康康~：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:_fastcall调用方式</span><br><span class="line">vold _fastcall ShowFast (int nOne，int nTwo，int nThree, int nFour) &#123;</span><br><span class="line">printf(&quot;%d%d%d%d \r\n&quot;, nOne, nTwo， nThree, nFour) ;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">ShowFast(1,2,3,4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F; C++ 源码对比， 函数调用</span><br><span class="line">ShowFast (1，2，3，4) ;</span><br><span class="line">004012A8push4;使用栈方式传递参数</span><br><span class="line">004012AA push3;使用栈方式传递参数</span><br><span class="line">004012ACmovedx,2;使用edx传递第二个参数2</span><br><span class="line">004012B1movecx,1;使用ecx传递第一个参数1</span><br><span class="line">004012B6call@ILT+15 (ShowFast) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对比，函数说明</span><br><span class="line">void fastcall ShowFast(int nOne，int nTwo, int nThree, int nFour) &#123;</span><br><span class="line">004010F0pushebp</span><br><span class="line">004010F1movebp,esp</span><br><span class="line">004010F3subesp,48h</span><br><span class="line">004010F6pushebx</span><br><span class="line">004010F7pushesi</span><br><span class="line">004010F8pushedi</span><br><span class="line">;由于ecx即将被赋值作为循环计数器使用，在此将ecx原值保存</span><br><span class="line">004010F9pushecx</span><br><span class="line">004010FAleaedi,[ebp-48h]</span><br><span class="line">004010FDmovecx,12h</span><br><span class="line">00401102moveax, 0CCCCCCCCh</span><br><span class="line">00401107rep stos dword ptr [edi]</span><br><span class="line">00401109popecx;还原ecx</span><br><span class="line">;使用临时变量保存edx (参数2)</span><br><span class="line">0040110Amovdword ptr [ebp-8] , edx</span><br><span class="line">;使用临时变量保存ecx (参数1)</span><br><span class="line">0040110Dmovdword ptr [ebp-4] , ecx</span><br><span class="line">&#x2F;&#x2F; C++源码对比，printf 函数调用</span><br><span class="line">printf(&quot; %d%d%d%d \r\n&quot;, nOne，nTwo, nThree, nFour) ;</span><br><span class="line">;使用ebp相对寻址取得参数4</span><br><span class="line">00401110moveax, dword ptr [ebp+0Ch]</span><br><span class="line">00401113pusheax;将eax压栈，作为参数</span><br><span class="line">;使用ebp相对寻址取得参数3</span><br><span class="line">00401114movecx, dword ptr [ebp+8]</span><br><span class="line">00401117pushecx;将ecx压栈， 作为参数</span><br><span class="line">;在ebp-8中保存edx，即参数2</span><br><span class="line">00401118movedx,dword ptr [ebp-8]</span><br><span class="line">0040111Bpushedx;将edx压栈， 作为参数</span><br><span class="line">;在ebp-4中保存ecx，即参数1</span><br><span class="line">0040111Cmoveax, dword ptr [ebp-4]</span><br><span class="line">0040111Fpusheax;将eax压栈， 作为参数</span><br><span class="line">00401120pushoffset string &quot;%d %d %d %d \r\n&quot; (00422024)</span><br><span class="line">00401125callprintf(004012e0)</span><br><span class="line">0040112Aadd esp,14h;平衡pirntf 使用的5个参数</span><br><span class="line">&#125;</span><br><span class="line">0040113Dret8;此函数有4个参数，ret指令对其平衡</span><br></pre></td></tr></table></figure><h2 id="使用ebp或esp寻址"><a href="#使用ebp或esp寻址" class="headerlink" title="使用ebp或esp寻址"></a>使用ebp或esp寻址</h2><p>由于局部变量使用栈空间进行存储，因此进入函数后的第一件事就是开辟函数中局部变量所需的栈空间大小，变量随着进入函数体开始生命，函数执行的时候结束</p><p>在大多数情况下，使用ebp寻址局部变量只能在非O2选项中产生，这样做是为了方便调试和检测栈平衡，使目标代码可读性更高。而在O2编译选项中，只要栈顶是稳定的，就可以不再使用ebp, 利用esp直接访问局部变量，可以节省一个寄存器资源。来个小demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明:通过esp访问局部变量</span><br><span class="line">void InNumber() &#123;</span><br><span class="line">int nInt &#x3D; 1;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;nInt);</span><br><span class="line">char cChar &#x3D; 2;</span><br><span class="line">scanf(&quot;%c&quot;, &amp;cChar);</span><br><span class="line">printf(&quot;%d %c\r\n&quot;,nInt,cChar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数在main函数中被调用</span><br><span class="line">void main()&#123;</span><br><span class="line">InNumber();</span><br><span class="line">&#125;</span><br><span class="line">;在Release版下，反汇蝙代码信息</span><br><span class="line">;函数定义，由于在main函数中只有一句函数调用代码，因此IDA为其取名 _main_0， 而不是使用地址做标号</span><br><span class="line">_main_0 proc near</span><br><span class="line">var_5 &#x3D; byte ptr -5; IDA定义的局部变量标号，IDA环境下局部变量用var_ 开头</span><br><span class="line">var_4 &#x3D; dword ptr -4; IDA定义的局部变量标号</span><br><span class="line">;为局部变量开辟8字节栈空间，这里在没有了那些繁琐的操作</span><br><span class="line">subesp,8</span><br><span class="line">;这句指令等价于; esp+8-4,标号var_4等于-4， IDA自动识别出访问的变量地址，并调整显示方式，省去了计算偏移量这个过程，类似于高级语言中为变量命名，使代码显示起来更具可读性</span><br><span class="line">leaeax,[esp+8+var_4]</span><br><span class="line">mov[esp+8+var_4], 1 ; 初始化var_ 4变量为1</span><br><span class="line">pusheax; eax中保存[esp+8-4]的值，将eax作为参数入栈</span><br><span class="line">pushoffset aD ; &quot;%d&quot;</span><br><span class="line">call_scanf</span><br><span class="line"></span><br><span class="line">;在分析指令的时候，IDA会根据代码上下文归纳出影响栈顶的指令，以确定esp相对寻址所访问的目标。</span><br><span class="line">;于是IDA识别出以下相对寻址指令的目标是该函数中的局部变量var_5， 之前执行了两次push指令，</span><br><span class="line">;所以esp指向的栈顶地址存在-8的差值，而且本函数第一条指令sub esp，8也影响栈顶。综合以</span><br><span class="line">;上信息，IDA为了表达出此时访问的局部变量为var_5， 并且将var_5定义为-5， 需要对esp相对寻址进行调整，先求解[esp+X+var_5]中的X，此处求解的X值为10h, 然后就可以表达为; [esp+10h+var_ 5]， 以加强代码的可读性。</span><br><span class="line">leaecx，[esp+10h+var_5]</span><br><span class="line">mov[esp+10h+var_5] ,2; 为var_5处的局部变量赋值2</span><br><span class="line">pushecx; esp -&#x3D; 4</span><br><span class="line">pushoffset aC; &quot;%c&quot;,esp -&#x3D; 4</span><br><span class="line">call_scanf</span><br><span class="line">;由于又执行了两次push指令，并且没有平衡钱，所以需要再次调整esp的相对偏移值，这里的调整值为18h。注意，在这里的movsx指令处点一下Q键，可以得到movsx edx， byte ptr [esp+13h]， 按K键可还原,名称。这里的movsx指令显示var_5 的类型为有符号类型，byte ptr 说明长度为单字节，对应C语言中的定义应该是char.当然读者也可以考察使用变量作参数的函数，如果函数功能是已知的，那么参数类型也就已知了，进而推导出变量的类型。</span><br><span class="line">movsxedx, [esp+18h+var_5]</span><br><span class="line">moveax, [esp+18h+var_4]</span><br><span class="line">pushedx</span><br><span class="line">pusheax</span><br><span class="line">pushoffset Format</span><br><span class="line">call_printf</span><br><span class="line"></span><br><span class="line">;经过优化后的代码，一次性平衡了栈顶esp.在此函数中，共执行了7次push操作，而函数scanf和printf函数使用相同的调用方式，即_ cdecl 调用方式，因此函数内没有平衡钱，需要调用者来平衡栈顶指针esp，又因为在退出函数前，还需释放局部变量的日个字节(见函数入口指令)空间，所以esp需要加(7*4+8&#x3D;)36转换成十六进制后为24h</span><br><span class="line">addesp,24h</span><br><span class="line">retn</span><br><span class="line">_main_0  endp</span><br></pre></td></tr></table></figure><p>每次访问变量都需要计算，如果在函数执行过程中esp发生了改变，再次访问变量就需要重新计算偏移。为了省去对偏移量的计算，方便分析，IDA在分析过程中事先将函数中的每个变量的偏移值计算出来，得出了一个固定偏移值，使用标号记录。这里有两个方案，正数标号法和负数标号法</p><ul><li><p>正数标号法：以调整后的esp作为基址来计算局部变量的偏移值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var_0 &#x3D; 4 ;定义第一个变量偏移量，所在地址为0x0012FFEC</span><br><span class="line">var_1 &#x3D; 0  ;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp, 8 ;申请变量栈空间，esp保存地址变为0x0012FFE8</span><br><span class="line">lea eax, [esp+var_0];寻址第一个变量地址为0x0012FFE8+4 &#x3D; 0x0012FFEC</span><br><span class="line">push eax;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">lea eax [esp+4+var_1];由于esp被减4，需要对基址esp进行加4,调整后再加上标号</span><br></pre></td></tr></table></figure></li><li><p>负数标号法：以调整前的esp作为基址来计算局部变量的偏移值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var_0 &#x3D; -4;定义第一个变量偏移量，所在地址为0X0012FFEC</span><br><span class="line">var_1 &#x3D; -8;定义第二个变量偏移量，所在地址为0x0012FFE8</span><br><span class="line">sub esp,8 ;申请变量栈空间，esp 保存地址变为0x0012FFE8</span><br><span class="line">;使用申请变量栈空间前的esp作为基扯，就需要调整esp,将其加8</span><br><span class="line">lea eax, [esp+8+var_0]</span><br><span class="line">push eax;执行push指令，esp被减4，esp地址变为0x0012FFE4</span><br><span class="line">;由于esp被减4，需要对基址esp进行二次调整，加8后再加4，因此得到数值0x0C</span><br><span class="line">lea eax [esp+0Ch+var_1]</span><br></pre></td></tr></table></figure></li></ul><p>显然ida选择了后者，下一节分析</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>参数也是函数中的一个变量，采用正数标号法来表示局部变量偏移标号时，函数的参数标号和局部变量的标号值都是正数，无法区分，不利于分析。如果使用负数标号法表示，则可以将两者区分，正数表示参数，而负数则表示局部变量，0值表示返回地址。</p><p>不放代码了，挺简单的</p><p>C\C++将不定长参数的函数定义为：</p><ul><li>至少要有一个参数</li><li>所有不定长的参数类型传入时都是dword类型</li><li>需在某一个参数中描述参数总个数或将最后一个参数赋值为结尾标记</li></ul><p>根据参数的传递特性，只要确定第一个参数的地址，对其地址值做加法，就可访问到此参数的下一个参数所在的地址。获取参数的类型是为了解释地址中的数据。.上面提到的第三点是为 了获取参数的个数，其目的是正确访问到最后一个参数的地址，以防止访问参数空间越界。</p><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>call指令被执行后，该指令同时还会做另一件事：<strong>将下一条指令所在的地址压入栈中</strong></p><p>ret指令读取栈中地址传送给EIP寄存器，使程序回到call的下一条指令</p><p>函数的返回值是由EAX寄存器来保存，但是只能保存<strong>四字节</strong>数据，大于四字节的需要使用其他方法保存，来个demo代码(DEBUG版)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明</span><br><span class="line">&#x2F;&#x2F; 函数功能:获取当前函数的返回地址</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">&#x2F;&#x2F;获取参数地址，减1后得到返回地址在栈中的地址</span><br><span class="line">int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">return nAddr;&#x2F;&#x2F;将返回地址作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">int GetAddr (int nNumber) &#123;</span><br><span class="line">; Debug保护环境初始化部分略</span><br><span class="line">int nAddr &#x3D;*(int*) (&amp;nNumber - 1) ;</span><br><span class="line">; ebp加法与esp加法原理相同，都是取参数，但是这里为什么是加8呢?</span><br><span class="line">;在Debug版下进入函数后，首先保存ebp会执行push ebp的操作，这样esp将执行压栈减4操作,随后执行mov ebp， esp的操作，由于栈顶esp之前被修改，所以ebp需要加4调整到最初的栈底位置,因此ebp+4 可以得到返回地址，ebp+8将会寻址第一个参数</span><br><span class="line">;以下代码将第一个参数的地址传入eax中</span><br><span class="line">0040DB78leaeax,[ebp+8]</span><br><span class="line">;执行eax自减4操作，执行后eax等价于ebp+4, 得到函数返回地址所在栈中的地址</span><br><span class="line">0040DB7Bsubeax,4</span><br><span class="line">;取出函数返回地址传入ecx中</span><br><span class="line">0040DB7Emovecx, dword ptr [eax]</span><br><span class="line">;使用ecx赋值局部变量</span><br><span class="line">0040DB80movdword ptr [ebp-4] , ecx</span><br><span class="line">return nAddr;</span><br><span class="line">;取出局部变量数据传入eax中，用做函数返回值</span><br><span class="line">0040DB83moveax, dword ptr [ebp-4]</span><br><span class="line">&#125;</span><br><span class="line">; Debug恢复环境，平衡栈、栈平衡检测部分略</span><br><span class="line">0040DB8Cret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">int nAddr &#x3D; Getaddr (1) ;</span><br><span class="line">0040DAF8 push1;压栈传参，传入参数1</span><br><span class="line">0040DAFAcall@ILT+30(ss) (00401023);函数调用</span><br><span class="line">0040DAFFaddesp,4;_cdec1调用方式，平衡栈</span><br><span class="line">0040DB02movdword ptr [ebp-4] , eax;取得返回值</span><br></pre></td></tr></table></figure><p>再来个结构体的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明:结构体类型作为返回值</span><br><span class="line">struct tagTEST &#123;&#x2F;&#x2F;结构体定义</span><br><span class="line">int m_nOne;</span><br><span class="line">int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回值为结构体类型的函数</span><br><span class="line">tagTEST RetStruct () &#123;</span><br><span class="line">tagTEST testRet ; </span><br><span class="line">testRet.m_nOne &#x3D; 1;</span><br><span class="line">testRet.m_nTwo &#x3D; 2;</span><br><span class="line">return testRet ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用函数，并将返回值赋值到结构体实例test中</span><br><span class="line">void main()&#123;</span><br><span class="line">tagTEST test;</span><br><span class="line">test &#x3D; RetStruct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇蝙代码讲解</span><br><span class="line">tagTEST RetStruct() &#123;</span><br><span class="line">; Debug保存环境、初始化部分略</span><br><span class="line">tagTEST testRet;</span><br><span class="line">testRet.m_nOne &#x3D; 1;</span><br><span class="line">004012A8movdword ptr [ebp-8] ,1;对结构体成员变量赋值</span><br><span class="line">testRet.m_nTwo &#x3D; 2;</span><br><span class="line">004012AFmovdword ptr [ebp-4] ,2;对结构体成员变量赋值</span><br><span class="line">return testRet ;</span><br><span class="line">004012B6moveax, dword ptr [ebp-8];取结构体成员变量数据传入eax中</span><br><span class="line">004012B9moveax, dword ptr [ebp-4];取结构体成员变量数据传入eax中</span><br><span class="line">&#125;</span><br><span class="line">;Debug恢复环境略</span><br><span class="line">004012C2ret;执行ret指令结束函数调用</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数调用处</span><br><span class="line">tagTEST test; </span><br><span class="line">test &#x3D; RetStruct () ;</span><br><span class="line">0040DC38call@ILT+35 (RetStruct) (00401028);调用函数RetStruct</span><br><span class="line">; eax中保存函数Retstruct中结构体testRet成员m_nOne的数据</span><br><span class="line">0040DC3Dmovdword ptr [ebp-10h] ,eax ; ebp-10h 为临时变量</span><br><span class="line">; edx中保存函数Retstruct中结构体testRet成员m_nTwo的数据</span><br><span class="line">0040DC3Dmovdword ptr [ebp-0ch] ,edx ; ebp-0ch 为临时变量</span><br><span class="line"></span><br><span class="line">;经过几次数据传递，最终将返回结果存入结构体实例test的两个成员所在地址处</span><br><span class="line">0040DC43moveax, dword ptr [ebp-10h]</span><br><span class="line">0040DC46movdword ptr [ebp-8] ,eax</span><br><span class="line">0040DC49movecx, dword ptr [ebp-0Ch]</span><br><span class="line">0040DC4Cmovdword ptr [ebp-4] ，ecx</span><br></pre></td></tr></table></figure><p>结构体只有两个成员，所以用了eax和edx来传递返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》(三)  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术(二)</title>
    <link href="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/"/>
    <id>http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%8C/</id>
    <published>2020-06-19T15:40:25.000Z</published>
    <updated>2020-07-13T04:21:26.436Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(二)</p><a id="more"></a>  <h1 id="第四章-各种表达式的求值过程"><a href="#第四章-各种表达式的求值过程" class="headerlink" title="第四章 各种表达式的求值过程"></a>第四章 各种表达式的求值过程</h1><p>单独的算术运算虽然可以编译通过，但是并不会生成代码。因为只进行计算而没有传递结果的运算不会对程序结果有任何影响，此时编译器将其视为无效语句，与空语句等价，不会有任何编译处理  </p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>VC++ 6.0有两种常用的优化方案  </p><ul><li>O1方案，生成文件占用空间最小</li><li>O2方案，执行效率最快</li></ul><p>在VC++ 6.0中，Release编译选项组的默认选项为<em>O2选项</em>，在Debug编译选项组中，使用的是<em>Od+ZI选项</em>，此选项使编译器产生的一切代码都以便于调试为最根本的前提，甚至为了便于单步调试，以及源码和目标代码块的对应阅读  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：加法运算</span><br><span class="line">&#x2F;&#x2F;无效语句，不参与编译</span><br><span class="line">15+20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; 0;</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量加常量的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个常量加法的加法运算</span><br><span class="line">nVarOne &#x3D; 1 + 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个变量相加的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwo</span><br><span class="line">printf(&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量赋值</span><br><span class="line">int nVarOne &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将立即数0，传入地址ebp-0x4中，即变量nVarOne所在的地址</span><br><span class="line">00401028 mov dword ptr [ebp-4],0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量赋值</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line">0040102F mov dword ptr [ebp-8],0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 + 常量</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出变量nVarOne数据放入eax中</span><br><span class="line">00401036 mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对eax执行加等于1运算</span><br><span class="line">00401039 add eax,1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果返回变量nVarOne中，完成加法运算</span><br><span class="line">0040103C mov dword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，常量 + 常量</span><br><span class="line">nVarOne &#x3D; 1 + 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里编译器直接计算出了两个常量相加后的结构，放入变量nVarOne中</span><br><span class="line">0040103F mov dword ptr [ebp-4],3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 + 变量</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ecx存放变量nVarOne</span><br><span class="line">00401046 mov ecx,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ecx对变量nVarTwo执行加等于操作</span><br><span class="line">00401049 add ecx,dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果存入地址ebp-4处，即变量nVarOne</span><br><span class="line">0040104C mov dword ptr [ebp-4],ecx</span><br></pre></td></tr></table></figure><p>由上方代码可得：  </p><ul><li>在两常量相加的情况下，编译器在编译期间就计算出两常量相加后的结果，将这个结果值作为立即数参与运算，减少了程序在运行期的计算</li><li>当有变量参与加法运算时，会先取出内存中的数据，放入通用寄存器中，再通过加法指令来完成计算过程得到结果，最后存回到变量所占用的内存空间中</li></ul><p>在开启O2选项后，编译出来的汇编代码会由于效率优先的编译选项而发生很大变化，编译器会将无用代码去除，并将可合并代码进行归并处理。例如，在代码清单4-1中，“nVarOne =<br>nVarOne+1;”这样的代码将被删除，因为在其后又重新对变量nVarOne进行了赋值操作，而在此之前没有对变量nVarOne的任何访问，所以编译器判定此句代码是可被删除的  </p><p>O2选项后Release版代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; int _cdecl main(int argc, const char **argu, const char **enup)</span><br><span class="line">__main proc near</span><br><span class="line">push    3</span><br><span class="line">push    offset format   ;&quot;nVarOne &#x3D; %d \r\n&quot;</span><br><span class="line">call    __printf</span><br><span class="line">add     esp,8</span><br><span class="line">xor     eax,eax</span><br><span class="line">retn</span><br><span class="line">__main endp</span><br></pre></td></tr></table></figure><ul><li>常量传播</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    int nVar &#x3D; 1;</span><br><span class="line">    printf(&quot;nVarOne &#x3D; %d  \r\n&quot;, nVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量nVar是一个在编译期间可以计算出结果的变量。因此，在程序中所有引用到nVar的地方都会直接使用常量1来代替，于是代码等价于:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    printf &#123;&quot;nVarOne &#x3D; %d \r\n&quot;，1) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常量折叠  </li></ul><p>当计算公式中出现多个常量进行计算的情况时，且编译器可以在编译期间计算出结果时，这样源码中所有的常量计算都将被计算结果代替，如下面的代码所示:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    int nVar &#x3D; 1 + 5 - 3 * 6;</span><br><span class="line">    printf(&quot;nVarOne &#x3D; %d \r\n&quot;,nVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这串算式被编译后会直接转化成常量-12，即”int nVar = -12;”  </p><p>在给出的加法代码中，变量nVarOne和nVarTwo的初始化值是-一个常量， VC++编译器在开启02优化方案后，会尝试使用常量替换掉变量。如果在程序的逻辑中，声明的变量没有被修改过，而且上下文中不存在针对此变量的取地址和间接访问操作，那么这个变量也就等价于常量，编译器就认为可以删除掉这个变量，直接用常量代替。使用常量的好处是可以生成立即数寻址的目标代码，常量作为立即数成为指令的一-部分，从而减少了内存的访问次数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int nVarOne &#x3D; 0;    &#x2F;&#x2F;常量化以后: int nVarOne &#x3D; 0; nVarOne 用0代替了</span><br><span class="line">int nVarTwo &#x3D; 0;    &#x2F;&#x2F; int nVarTwo &#x3D; 0; 同上，这句也没有了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量加常量的加法运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 1;      &#x2F;&#x2F;nVarOne&#x3D;0+1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相加的加法运算</span><br><span class="line">nVarOne &#x3D; 1 + 2;    &#x2F;&#x2F;nVarOne&#x3D;1+2;</span><br><span class="line">nVarOne &#x3D; nVarOne + nVarTwO;    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + 0;</span><br><span class="line">printf (&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne);</span><br></pre></td></tr></table></figure><p>经过转化后，直接变成”printf(“nVarOne = %d \r\n”);”<br>将代码修改为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    int nVarOne &#x3D; argc;      &#x2F;&#x2F;修改处</span><br><span class="line">    int nVarTwo &#x3D; argc;      &#x2F;&#x2F;修改处</span><br><span class="line"></span><br><span class="line">    nVarOne &#x3D; nVarOne + 1 ;</span><br><span class="line">    nVarOne &#x3D; 1 + 2;</span><br><span class="line">    nVarOne &#x3D; nVarOne + nVarTwo;</span><br><span class="line">    printf &#123;&quot;nVarOne &#x3D; %d \r\n&quot;， nVarOne) ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化nVarOne和nVarTwo的时候用命令行参数argc，故在编译期间无法确定，程序中的变量就不会被常量替换掉，汇编代码为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; int_ cdec1 main(int argc, const char **argu, const char **envp)</span><br><span class="line">__main proc near  </span><br><span class="line"></span><br><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line"></span><br><span class="line">mov  eax, [esp+arg_0]</span><br><span class="line">add  eax, 3  </span><br><span class="line">push  eax  </span><br><span class="line">push  offset Format     ; &quot;nVarOne &#x3D; 0 \r\n&quot;</span><br><span class="line"></span><br><span class="line">call  printf</span><br><span class="line">add  esp,8</span><br><span class="line">xor  eax, eax</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">__main endp</span><br></pre></td></tr></table></figure><p>这里还是被删除了一个变量，优化过程如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    &#x2F;&#x2F; int nVarOne &#x3D; argc;在后面的代码中被常量代替</span><br><span class="line">    &#x2F;&#x2F; int nVarTwo &#x3D; argc;虽然不能用常量代替，但是由于之后没有对nVarTwo进行修改，所以引用nVarTwo等价于引用argc, nVarTwo 则被删除掉，这种方法称为”复写传播”</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + 1;其后即刻重新对nVarOne赋值，这句被删除了</span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; 1+2;常量折叠，等价于nVarOne&#x3D;3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; nVarOne &#x3D; nVarOne + nVarTwo; 常量传播和复写传播，等价于nVarOne &#x3D; 3 + argc ;</span><br><span class="line">    &#x2F;&#x2F; printf (&quot;nVarOne &#x3D; %d \r\n&quot;, nVarOne) ;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;其后nVar0ne没有被访问，可以用3 + argc代替</span><br><span class="line">    printf (&quot;nVarOne &#x3D; %d \r\n&quot;, 3 + argc) ;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法运算对应于汇编指令sub，计算机是通过补码将减法转变为加法形式来完成转换，有公式  </p><p>设有二进制数Y，其反码记为Y(反)，假定其二进制长度为8位，有:  </p><ul><li>Y + Y(反) = 1111 1111B  </li><li>Y + Y(反) + 1 = 0(进位丢失)  </li></ul><p>根据以上两点，可推出  </p><ul><li>Y(反) + 1 = 0 - Y&lt;==&gt;Y(反) + 1 = -Y &lt;==&gt; Y(补} = -Y  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：减法运算</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取变量nVarTwo的数据，使用scanf防止被常量化</span><br><span class="line">scanf(&quot;%d&quot;,&amp;nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量减常量的减法运算</span><br><span class="line">nVarOne &#x3D; nVarOne - 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;减法与加法混合运算</span><br><span class="line">nVarOne &#x3D; nVarOne + 5 - nVarTwo;</span><br><span class="line">printf(&quot;nVarOne &#x3D; %d \r\n&quot;,nVarOne);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 - 常量</span><br><span class="line">nVarOne &#x3D; nVarOne - 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取变量nVarOne的数据到eax中</span><br><span class="line">00401125moveax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是用减法指令sub，对eax执行减等于100操作</span><br><span class="line">00401128subeax,64h</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将结果赋值回nVarOne中</span><br><span class="line">0040112Bmov dword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，减法与加法混合运算</span><br><span class="line">nVarOne &#x3D; nVarOne +5 - nVarTwo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按照自左向右顺序依次执行</span><br><span class="line">0040112Emovecx,dword ptr [ebp-4]</span><br><span class="line">00401131addecx,5</span><br><span class="line">00401134subecx,dword ptr [ebp-8]</span><br><span class="line">00401137movdword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;printf函数调用显示略</span><br></pre></td></tr></table></figure><p>Release与加法相同，就不赘述了  </p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法运算对应的汇编指令有有符号<strong>imul</strong>和无符号<strong>mul</strong>两种，由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换成加法，或使用移位等周期较短的指令。当它们都不可转换时，才会使用乘法指令  </p><p><strong>乘法转换——Debug版</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，乘法运算</span><br><span class="line">&#x2F;&#x2F;防止被视为无效代码，将每条运算作为printf参数使用</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量乘常量(常量为非2的幂)</span><br><span class="line">printf(&quot;nVarOne*15 &#x3D; %d \r\n&quot;,nVarOne * 15);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量乘常量(常量值为2的幂)</span><br><span class="line">printf(&quot;nVarOne*16 &#x3D; %d&quot;,nVarOne * 16);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相乘</span><br><span class="line">printf(&quot;2*2 &#x3D; %d&quot;,2 * 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;混合运算</span><br><span class="line">printf(&quot;nVarTwo *4 +5 &#x3D; %d&quot;,nVarTwo * 4 + 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两变量相乘</span><br><span class="line">printf(&quot;nVarOne * nVarTwo &#x3D; %d&quot;,nVarOne * nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 * 常量</span><br><span class="line">printf(&quot;nVarOne*15 &#x3D; %d \r\n&quot;,nVarOne * 15);</span><br><span class="line">0040B8A4movedx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;直接使用有符号乘法指令imul</span><br><span class="line">0040B8A7imuledx,edx,0Fh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比 常量*常量(常量值为2的幂)</span><br><span class="line">printf(&quot;nVarOne*16 &#x3D; %d&quot;,nVarOne * 16)</span><br><span class="line">0040B8B8moveax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;使用左移运算代替乘法运算</span><br><span class="line">0040B8BBshleax,4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，常量*常量</span><br><span class="line">printf(&quot;2*2 &#x3D; %d&quot;,2 * 2);</span><br><span class="line">&#x2F;&#x2F;在编译期间计算出2*2的结果，将表达式转换为常量值</span><br><span class="line">0040B8CCpush 4</span><br><span class="line">0040B8CEpush offest string &quot;2 * 2 &#x3D; %d&quot;(0041ffac)</span><br><span class="line">0040B8D3call printf(0040B750)</span><br><span class="line">0040B8D8add esp,8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，变量*常量+常量(组合运算)</span><br><span class="line">printf(&quot;nVarTwo *4 +5 &#x3D; %d&quot;,nVarTwo * 4 + 5);</span><br><span class="line">0040B8DBmovecx,dword ptr [ebp-8]</span><br><span class="line">&#x2F;&#x2F;利用lea指令完成组合运算</span><br><span class="line">0040B8DEleaedx,[ecx*4+5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，变量*变量</span><br><span class="line">printf(&quot;nVarOne * nVarTwo &#x3D; %d&quot;,nVarOne * nVarTwo);</span><br><span class="line">0040B90Amovecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;直接使用有符号乘法指令</span><br><span class="line">0040B90Dimul ecx,dword ptr [ebp-8]</span><br></pre></td></tr></table></figure><p>代码使用编译选项为Od+ZI。在这种侧重调试的编译方式下，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法<strong>imul</strong>指令。当常量值为2的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令,而若乘数不等于2的幂次方，则会先拆分后用<strong>imul</strong>指令进行编译  </p><p><strong>各类型的乘法转换示例——Release版</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;IDA直接将参数作为局部变量使用</span><br><span class="line">arg_0 &#x3D; dword ptr 4  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存环境</span><br><span class="line">push esi</span><br><span class="line">&#x2F;&#x2F;取出参数变量存入esi中</span><br><span class="line">mov esi,[esp+4+arg_0]</span><br><span class="line">&#x2F;&#x2F;经过优化后，将nVarOne*15先转化为 乘2加自身，相当于乘3</span><br><span class="line">&#x2F;&#x2F;eax &#x3D; esi*2+esi &#x3D; 3*esi</span><br><span class="line">leaeax,[esi+esi*2]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将上一步操作结果乘4加自身，等同于乘15</span><br><span class="line">&#x2F;&#x2F;eax &#x3D; eax * 4 + eax &#x3D; 5 * eax &#x3D; 5 * (3*esi)</span><br><span class="line">leaeax,[eax+eax*4]</span><br><span class="line">push eax</span><br><span class="line">push offset aNvaronel15D; &quot;nVarOne * 15 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; esi中的数据传送到ecx，esi中保存的为参数数据</span><br><span class="line">movecx,esi</span><br><span class="line">&#x2F;&#x2F;将ecx中的数据左移4为，ecx乘以2^4</span><br><span class="line">shlecx,4</span><br><span class="line">push ecx</span><br><span class="line">push offset aNvarone15D; &quot;nVarOne * 16 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两常量相乘直接转换常量值</span><br><span class="line">push 4</span><br><span class="line">push offset a22D;&quot;2*2 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;这句话等等同于lea edx,[esi*4+5]都是混合运算</span><br><span class="line">leaedx,ds:5[esi*4]</span><br><span class="line">push edx</span><br><span class="line">push offset aNvartwo45D;&quot;nVarTwo * 4 +5 &#x3D;%d&quot;</span><br><span class="line">call _printf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此处为乘数不等于2 4 8 情况，编译优化9进行分解：(nVarTwo*1+nVarTwo*8),这样就可以使用lea了</span><br><span class="line">lea eax,[esi+esi*8+5]</span><br><span class="line">push eax</span><br><span class="line">push _offset aNvartwo95D;&quot;nVarTwo * 9 +5 &#x3D;%d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;此处为两个变量相乘，都是未知数，无忧化</span><br><span class="line">movecx,esi</span><br><span class="line">imul ecx,esi</span><br><span class="line">push ecx</span><br><span class="line">push offest aNvaroneNvartwo;&quot;nVarOne * nVarTwo &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">addesp,30h</span><br><span class="line">popesi</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ul><li>向下取整：所谓对x向下取整，就是取得往-∞方向最接近x的整数值，换而言之也就是取得不大于x的最大整数  </li></ul><p>在标准C语言的math.h中，定义了floor函数，其作用就是向下取整，也有人称之为“地板取整”  </p><ul><li>向上取整：所谓对x向上取整，就是取得往+∞方向最接近x的整数值，换而言之也就是取得不小于x的最小整数  </li></ul><p>在标准C语言的math.h中有定义ceil函数，其作用就是向上取整，也有人称之为“天花板取整”</p><ul><li>向0取整：所谓对x向零取整，就是取得往0方向最接近x的整数值，换而言之也就是放弃小数部分  </li></ul><p>C语言是向0取整  </p><p><img src="P1.PNG" alt="定义">  </p><p><img src="P2.PNG" alt="定义">  </p><p>VC++6.0对除数为整型常量的除法会进行优化:如果除数是变量，则只能使用除法指令。如果除数为常量，就有了优化的余地。根据除数值的相关特性，编译器有对应的处理方式。  </p><p><strong>各类型除法转换——Debug版</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：除法运算</span><br><span class="line">&#x2F;&#x2F;变量定义</span><br><span class="line">intnVarOne &#x3D; argc;</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个变量做除法</span><br><span class="line">printf(&quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot;, nVarOne &#x2F; nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以常量，常量为2的1次方</span><br><span class="line">printf(&quot;nVarOne &#x2F; 2 &#x3D; %d&quot;, nVarOne &#x2F; 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以非2的幂</span><br><span class="line">printf(&quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;, nVarTwo &#x2F; 7);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量对非2的幂取模</span><br><span class="line">printf(&quot;nVarTwo % 7 &#x3D; %d&quot;, nVarTwo % 7);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量除以常量，常量为2的3次方</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;, nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量定义</span><br><span class="line">int nVarOne &#x3D; argc;</span><br><span class="line">0040B7E8moveax,dword ptr [ebp+8]</span><br><span class="line">0010B7EBmovdword ptr [ebp-4],eax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量定义</span><br><span class="line">int nVarTwo &#x3D; argc;</span><br><span class="line">0040B7EEmovecx,dword ptr [ebp+8]</span><br><span class="line">0040B7F1movdword ptr [ebp-8],ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;除法运算转换特性</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 变量</span><br><span class="line">printf(&quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot;, nVarOne &#x2F; nVarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax中</span><br><span class="line">0040B7F4moveax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展高位(EDX:EAX,这里表示EDX，EAX连用表示64位数 )</span><br><span class="line">0040B7F7cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两变量相除，直接使用有符号除法指令idiv</span><br><span class="line">0040B7F8idiveax,dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;eax保存商值，作为参数压栈，调用函数printf</span><br><span class="line">0040B7FBpush eax</span><br><span class="line">0040B7FCpush offset string &quot;nVarOne &#x2F; nVarTwo &#x3D; %d&quot; (00420034)</span><br><span class="line">0040B801call printf (0040B750)</span><br><span class="line">0040B806addesp,8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量 (常量值为2的1次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 2 &#x3D; %d&quot;, nVarOne &#x2F; 2);</span><br><span class="line">0040B809moveax,dword ptr [ebp-4]</span><br><span class="line">0040B80Ccdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自身减去扩展高位</span><br><span class="line">0040B80Dsubeax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;和乘法运算类似，乘法是左移</span><br><span class="line">0040B80Fsareax,1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量 (非2的幂)</span><br><span class="line">printf(&quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;, nVarTwo &#x2F; 7);</span><br><span class="line">0040B81Fmov eax,dword ptr [ebp-8]</span><br><span class="line">00040B22cdq</span><br><span class="line">0040B823movecx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;无忧化直接使用有符号除法指令idiv</span><br><span class="line">0040B828idiv eax,ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 % 常量</span><br><span class="line">printf(&quot;nVarTwo % 7 &#x3D; %d&quot;, nVarTwo % 7);</span><br><span class="line">0040B838moveax,dword ptr [ebp-8]</span><br><span class="line">0040B83Bcdq  &#x2F;&#x2F;执行 CDQ 后， CDQ 把第 31 bit 复制至 EDX 所有 bit</span><br><span class="line">0040B83Cmov ecx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;无忧化，直接使用有符号指令idiv</span><br><span class="line">0040B841idiv eax,ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;除法指令过后，余数保存在扩展为edx中</span><br><span class="line">0040B843push edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;printf 函数说明略</span><br><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量(常量值为2的3次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;,nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax</span><br><span class="line">0040B851mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展eax高位到edx</span><br><span class="line">0040B854cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果eax为负数</span><br><span class="line">0040B855and edx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用eax加edx，若eax为负数则加7，反之加0</span><br><span class="line">0040B858addeax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将eax右移3位</span><br><span class="line">0040B85Asareax,3</span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br></pre></td></tr></table></figure><p>这里只对除数为2的幂的情况进行了优化处理：<br>这里运用了推导7的结论：(x+(2^n-1)) &gt;&gt; n  </p><p><strong>除数为2的幂</strong>  </p><p>上述代码中的0040B80C的cdq是符号扩展到高位edx,如果eax的最高位(符号位)为1,那么edx的值为0xFFFFFFFF，也就是-1，否则为0。0040B80D地址处的sub eax,edx指令执行的操作是将eax减去高位edx，实际上就是被除数为负数的情况下，由于除数为正数(+2的幂)，故除法的商为负数。移位运算等价于向下取整，C语言的除法是向零取整，因此需要对商为负的情况做加1调整(见推导7)，减去-1等同于加1。eax不为负则减0，等于没处理。最后sar右移完成除法。这样的设计可以避免分支结构的产生  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码对比，变量 &#x2F; 常量(常量值为2的3次方)</span><br><span class="line">printf(&quot;nVarOne &#x2F; 8 &#x3D; %d&quot;,nVarOne &#x2F; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出被除数放入eax</span><br><span class="line">0040B851mov eax,dword ptr [ebp-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展eax高位到edx</span><br><span class="line">0040B854cdq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果eax为负数</span><br><span class="line">0040B855and edx,7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用eax加edx，若eax为负数则加7，反之加0</span><br><span class="line">0040B858addeax,edx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将eax右移3位</span><br><span class="line">0040B85Asareax,3</span><br><span class="line">&#x2F;&#x2F;printf函数说明略</span><br></pre></td></tr></table></figure><p>这里我要记录一下我的犯蠢时刻，计算机里负数的各项计算都是通过<strong>补码</strong>进行的，所以add eax，edx这句话就不会有问题，基础太差了呜呜  </p><p>0040B854的cdq是符号扩展到高位edx，在0040B855处对edx做位与运算，当被除数为负数时，edx的值为7，在0040B858处的add eax，edx就是被除数为负数时加上2^n-1，不为负数则加0，最后sar右移完成除法  </p><p><strong>除数非2的幂</strong><br>Release版中还对除数不为2的幂的情况做了优化：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;IDA中的参数标识，经过优化后，省去了局部变量，直接使用参数</span><br><span class="line">arg_0 &#x3D; dword ptr 4</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 变量 和Debug版相同，此处省略</span><br><span class="line">&#x2F;&#x2F;......</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 常量 (常量值为2的幂)和Debug版相同，此处省略</span><br><span class="line">&#x2F;&#x2F;.....</span><br><span class="line">&#x2F;&#x2F;变量 &#x2F; 常量 (常量值为非2的幂)，这里的汇编代码和Debug版的汇编代码差别很大</span><br><span class="line">&#x2F;&#x2F;将数值 92492493h放到eax中</span><br><span class="line">moveax,92492493h</span><br><span class="line">&#x2F;&#x2F;有符号乘法，用esi乘以eax，esi中保存被除数</span><br><span class="line">imul esi</span><br><span class="line">&#x2F;&#x2F;edx为扩展的高位</span><br><span class="line">addedx,esi</span><br><span class="line">&#x2F;&#x2F;右移2位</span><br><span class="line">saredx,2</span><br><span class="line">&#x2F;&#x2F;结果放回eax</span><br><span class="line">moveax,edx</span><br><span class="line">&#x2F;&#x2F;将eax右移31次</span><br><span class="line">shreax，1Fh</span><br><span class="line">&#x2F;&#x2F;加以右移结果，放入edx中</span><br><span class="line">addedx,eax</span><br><span class="line">push edx</span><br><span class="line">push offset aNvarTwo7D; &quot;nVarTwo &#x2F; 7 &#x3D; %d&quot;</span><br><span class="line">call _printf</span><br><span class="line">&#x2F;&#x2F;其余代码和Debug版类似，略</span><br><span class="line">&#x2F;&#x2F;......</span><br></pre></td></tr></table></figure><p>由于除法指令的周期比乘法要长出很多，所以release版的除法指令会被乘法和其他指令替代，这里出现了一个大数92492493，给出数学证明  </p><p><img src="P3.png" alt="证明">  </p><p>来个例子看一下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000_main proc near ; CODE XREF: start+AF p</span><br><span class="line">.text:00401000arg_0 &#x3D; dword ptr 4</span><br><span class="line">.text:00401000movecx,[esp+arg_0]</span><br><span class="line">.text:00401004moveax,38E38E39h</span><br><span class="line">.text:00401000  imul ecx&#x2F;&#x2F;ecx乘以参数</span><br><span class="line">.text:0040100Bsaredx,1&#x2F;&#x2F;有符号移位</span><br><span class="line">.text:0040100Dmov eax,edx</span><br><span class="line">.text:0040100Fshreax,1Fh&#x2F;&#x2F;无符号移位</span><br><span class="line">.text:00401012addedx,eax</span><br><span class="line">.text:00401014push edx</span><br><span class="line">.text:00401015push offset Format ; &quot;%d&quot;</span><br><span class="line">.text:0040101Acall _printf</span><br><span class="line">.text:0040101Fadd esp,8</span><br><span class="line">.text:00401022retn</span><br><span class="line">.text:00401022_main endp</span><br></pre></td></tr></table></figure><p>看到在地址.text: 00401004处，我们看到了mov eax, 38E38E39h，此后做了乘法和移位操作,最后直接使用edx显示。在乘法指令中，由于edx存放乘积数据的高4字节，因此直接使用edx就等价于乘积右移了32位，再算上.text:0040100B sar edx, 1，那就一共移动了33位。在地址.text: 0040100D 处，eax 得到了edx 的值，然后对eax右移了1Fh位，对应10进制也就是右移了31位，然后有个很奇怪的加法。其实这里移位的目的是得到有符号数的符号位，如果结果是正数，add edx, eax就是加0，等于什么都没干;如果结果是负数，由于其后面的代码直接使用edx作为计算结果，需要对除法的商调整加1。简单证明如下:  </p><p><img src="P4.png" alt="证明">  </p><p>于是可以推出C代码:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;,arg&#x2F;9);</span><br></pre></td></tr></table></figure><p>总结:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moveax,MagicNumber</span><br><span class="line">imul ...</span><br><span class="line">saredx,...</span><br><span class="line">movreg,edx</span><br><span class="line">shrreg,1Fh</span><br><span class="line">addedx,reg</span><br><span class="line">&#x2F;&#x2F;之后就直接用edx的值，eax的不用</span><br></pre></td></tr></table></figure><p>遇到上面你的指令序列的时候，基本可以判定是除法优化后的代码，除法的原型为<em>a/o</em>，<strong>imul</strong>是表明的有符号计算，操作数是优前的被除数a，右移的总次数确定n的值，用公式<strong>o= 2^n/c</strong>，将MagicNumber作为c代入公式求我们的除数o的近似值，四舍五入取整，就可以恢复除法原型！  </p><p>再来个例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080 _main proc near ; CODE xREF: start+AF p</span><br><span class="line">.text:00401080 arg_0 &#x3D; dword ptr 4</span><br><span class="line">.text:00401080mov ecx,[esp+arg_0]</span><br><span class="line">.text:00401084mov eax,24924925h</span><br><span class="line">.text:00401089mulecx</span><br><span class="line">.text:0040108Bsubecx,edx</span><br><span class="line">.text:0040108Dshrecx,1</span><br><span class="line">.text:0040108Faddecx,edx</span><br><span class="line">.text:00401091shrecx,2</span><br><span class="line">.text:00401094push ecx</span><br><span class="line">.text:00401095push offsetFormat</span><br><span class="line">.text:0040109Acall _printf</span><br><span class="line">.text:0040109Faddesp,8</span><br><span class="line">.text:004010A2xoreax,eax</span><br><span class="line">.text:004010A4retn</span><br><span class="line">.text:004010A4 _ma in endp</span><br></pre></td></tr></table></figure><p>手推：</p><p><img src="P5.png" alt="推导">  </p><p>于是，可以推出代码来:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;nVarTwO &#x2F; 7 &#x3D; %d\r\n&quot;, argc &#x2F; 7);</span><br></pre></td></tr></table></figure><p>计算得出MagicNumber后，如果其值超出4字节整数的表达范围，编译器会对其进行调整，如上个例子中的argc/7，计算MagicNumber时，编译器选择 2^35/7，其结果超出了4字节整数的表达范围，所以编译器调整MagicNumber的取值为2^35/7-2^32  </p><p>公式：a/o = [((a-a * c)/2^32)/2 + a * c/2^32]/2^(n-1)  </p><p>总结：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax,MagicNumber</span><br><span class="line">&#x2F;&#x2F;reg表示通用寄存器</span><br><span class="line">mul reg</span><br><span class="line">subreg,edx</span><br><span class="line">shrreg,1</span><br><span class="line">addreg,edx</span><br><span class="line">shrreg,A&#x2F;&#x2F;这句没有，那么n就是1，否则这里就是n-1的值</span><br></pre></td></tr></table></figure><p>如果遇到上面的指令序列，基本可以判定出发优化后的代码，其除法原型为a/常量o，mul代表的无符号计算，用公式o = 2^(32+n)/(2^32+c)将MagicNumber作为c值代入公式求解常数除数o，即可恢复除法原型  </p><p>现在再来看之前的代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; 92492493h疑似 2^n&#x2F;o</span><br><span class="line">. text:004010AA     mov eax, 92492493h</span><br><span class="line">;这里是流水线优化，esp和上次调用的call指令相关，和除法计算无关，可暂不理会  </span><br><span class="line">;关于流水线优化详见4.4.1小节  </span><br><span class="line">. text:004010AF     add esp,8  </span><br><span class="line"></span><br><span class="line">;有符号乘法，用esi乘以eax，esi中保存被除数</span><br><span class="line">. text:004010B2     imul esi</span><br><span class="line"></span><br><span class="line">;这里又多出一个诡异的加法</span><br><span class="line">. text:004010B4     add edx, esi</span><br><span class="line"></span><br><span class="line">;右移2位，也可看做除4</span><br><span class="line">. text:004010B6     sar edx, 2</span><br><span class="line"></span><br><span class="line">;结果给eax</span><br><span class="line">. text:004010B9     mov eax, edx</span><br><span class="line"></span><br><span class="line">;负数调整加1</span><br><span class="line">. text:004010BB     shr eax, 1Fh</span><br><span class="line">. text:004010BE     add edx，eax</span><br><span class="line">. text:004010C0     push edx</span><br><span class="line">. text:004010C1     push offset aNvartwo7D ; &quot;nVarTwo &#x2F; 7 &#x3D; td&quot; ;</span><br><span class="line">. text:004010C6     ca11 _printf</span><br></pre></td></tr></table></figure><p>这段代码在.text:004010B4处的加法显得很奇怪,其实这里的代码是上面介绍的除法转乘法公式的变化。在.text:004010B2处的指令是imul esi,这是个有符号数的乘法。请注意，编译器在计算MagicNumber时是作为<strong>无符号</strong>处理的，而代入除法转换乘法的代码中又是作为有符号乘数处理的。因为有符号数的<strong>最高位不是数值，而是符号位</strong>，所以，对应的有符号乘法指令是不会让最高位参与数值计算的，这会导致乘数的数学意义和MagicNumber不一致  </p><p>由于符号数和无符号数的存储问题，所以要将表达式调整一下  </p><p><img src="P6.png" alt="证明">  </p><p>总结  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov eax, MagicNumber (大于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">add edx, reg</span><br><span class="line">sar edx, ...</span><br><span class="line">mov reg, edx</span><br><span class="line">shr reg, 1Fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure><p>当遇到以上指令序列时，基本可判定是除法优化后的代码，其除法原型为a除以常量o,imul表明是有符号计算，其操作数是优化前的被除数a,接下来统计右移的总次数以确定公式中的n值，然后使用公式<strong>o=(2^n)/c</strong>,将MagicNumber作为c值代入公式求解常量除数o，即可恢复除法原型  </p><ul><li>除数为负的非2的幂(MagicNumber大于0x7fffffffh)  </li></ul><p>总结  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, MagicNumber (大于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">sar edx,···</span><br><span class="line">mov reg,edx</span><br><span class="line">shr reg,1fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure><p>如果遇到以上指令序列，则基本可判定是除法优化后的代码，其除法原型为a除以常量o, imul可表明是有符号计算，其操作数是优化前的被除数a,由于MagicNumber取值大于7fffffffh，而imul和sar之间未见任何调整代码，故可认定除数为负，且MagicNumber为补码形式。接下来统计右移的总次数以确定公式中的n值，然后使用公式|o|=2^n/((2^32)-c),MagicNumber作为c值代人公式求解常量除数|o|，即可恢复除法原型  </p><ul><li>除数为负的非2的幂(MagicNumber小于0x7fffffffh)  </li></ul><p>总结  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov eax, MagicNumber (小于等于7fffffffh)</span><br><span class="line">imul reg</span><br><span class="line">sub edx, reg</span><br><span class="line">sar edx, ...</span><br><span class="line">mov reg, edx</span><br><span class="line">shr reg, 1Fh</span><br><span class="line">add edx，reg</span><br><span class="line">;此后直接使用edx的值</span><br></pre></td></tr></table></figure><p>如果遇到以上指令序列，则基本可判定是除法优化后的代码，其除法原型为a除以常量o, imul可表明是有符号计算，其操作数是优化前的被除数a,由于MagicNumber取值小于7fffffffh，而imul和sar之间未见任何调整代码，故可认定除数为负，且MagicNumber为补码形式。接下来统计右移的总次数以确定公式中的n值，然后使用公式|o|=2^n/((2^32)-c),MagicNumber作为c值代人公式求解常量除数|o|，即可恢复除法原型  </p><ul><li>除法优化原则  </li></ul><p>这里我直接copy l0x1c师傅的blog了，没错，👴就是懒狗  </p><p>先给一些背景：</p><p>（1）比如 7 / 2 = 3 …… 1 -7 / 2 = -3 …… -1</p><p>比较重要的是，余数的绝对值小于除数的绝对值，并且余数和被除数同正负</p><p>（2）由于C语言中除法是向0取整，也就是“截断除法”</p><p>不难发现，正数除以正数时，截断除法相当于向下取整（3.5 -&gt; 3）；而负数除以正数时，截断除法相当于向上取整( -3.5 -&gt; -3 )</p><p>（3）除以2的k次幂通常会被优化成右移k位，这里考虑除以2时</p><p>用一个signed byte表示7，是00000111，右移一位变成00000011是3，是正确的</p><p>但是，考虑-7/2，-7是11111001，右移一位后变成11111100，这是-4，因为这是向下取整的结果，所以比正确的答案 -3少了1</p><p>代码中为了统一和效率，如果是32位的数字，会先右移31位扩展符号位。原先是正数则最高位是0，那么最后会变成32个0，也就是0,；原先是负数最高位是1，最后会变成32个1，也就是-1，暂且把这个扩展符号位后形成的数记作S,</p><p>那么，我们只需要把右移一位的结果，减去这个S，就可以得到正确的截断除法的值</p><p>7/2 = 7&gt;&gt;1 – (0) = 3 -7/2 == -7&gt;&gt;1 – (-1) = -3</p><p>( 这一点在例题代码中会再次提到 )</p><p>（4）当除以正数N，而N不是2的次幂时，编译器会生成一个magic_number（C），以使除法优化成乘法，提高效率</p><p>贴一道例题分析</p><p>![<a href="https://ctftime.org/task/5294?tdsourcetag=s_pcqq_aiomsg]" target="_blank" rel="noopener">https://ctftime.org/task/5294?tdsourcetag=s_pcqq_aiomsg]</a>  </p><ul><li>取模运算  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov reg,被除数</span><br><span class="line">and reg, 8000001F ;这里的立即数是去掉高位保留低位的掩码，其值由2^k决定</span><br><span class="line">jns LAB1</span><br><span class="line">dec reg</span><br><span class="line">or reg, FFFFFFE0</span><br><span class="line">inc reg</span><br><span class="line">LAB1 :</span><br></pre></td></tr></table></figure><p>当遇到以上指令序列时，基本可判定是取模代码，其取模原型为被除数(变量)对2^k(常量)执行取模运算，jns 可表明是有符号计算，考察“and reg,8000001F”这类去掉高位保留低位的代码，统计出一共保留了多少低位，即可得到k的值，代入求得2*的值后，可恢复取模代码原型  </p><p>对于x%(2^k)，有的编译器会得到以下代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;先求x&#x2F;2^5的商</span><br><span class="line">mov eax，被除数</span><br><span class="line">cdq</span><br><span class="line">and edx, 1F</span><br><span class="line">add eax, edx</span><br><span class="line">sar eax,5;这时eax已经得到了商</span><br><span class="line">;余数&#x3D;被除数-商*2^5</span><br><span class="line">shl eax,5</span><br><span class="line">sub 被除数，eax ;此时可以得到余数</span><br></pre></td></tr></table></figure><h2 id="算术结果溢出"><a href="#算术结果溢出" class="headerlink" title="算术结果溢出"></a>算术结果溢出</h2><ul><li><p>进位<br>无符号数超出存储范围叫做进位。因为没有符号位，不会破坏数据，而多出的1位数据会被进位标志位CF保存，数据产生了进位，只是进位后的1位数据1不在自身的存储空间中，而在标志位CF中。可通过查看进位标志位CF,检查数据是否进位  </p></li><li><p>溢出<br>有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位——符号位。只有有符号数才有符号位，所以溢出只针对有符号数。可查看益出标志位OF,检查数据是否溢出。OF的判定规则很简单，如果参与加法计算的数值符号一致，而计算结果符号不同，则判定OF成立，其他都不成立  </p></li></ul><h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2><p>VC++ 6.0使用“++”、“–” 来实现自增和自减操作。自增和自减有两种定义，一种为自增自减运算符在语句块之后，则先执行语句块，再执行自增自减;另一种恰恰相反，自增自减运算符在语句块之前，则先执行自增和自减，再执行语句块。通常，自增和自减是被拆分成两条汇编指令语句执行的  </p><p><strong>代码如下</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自增自减代码</span><br><span class="line">&#x2F;&#x2F;C++源码说明:除法运算</span><br><span class="line">&#x2F;&#x2F;变量定义并出初始化</span><br><span class="line">int nvarOne &#x3D; argc;</span><br><span class="line">int nvarTwo &#x3D; argc;</span><br><span class="line">&#x2F;&#x2F;变量后缀自增参与表达式运算</span><br><span class="line">nvarTwo &#x3D; 5 + (nvarOne++);</span><br><span class="line">&#x2F;&#x2F;变量前缀自增参与表达式运算</span><br><span class="line">nvarTwo &#x3D; 5 + (++nvarOne);</span><br><span class="line">&#x2F;&#x2F;变量后缀自减参与表达式运算</span><br><span class="line">nvarone &#x3D; 5 + (nvarTwo--);</span><br><span class="line">&#x2F;&#x2F;变量前缀自减参与表达式运算</span><br><span class="line">nvarone &#x3D; 5 + (--nvarTwo);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对应汇编</span><br><span class="line">&#x2F;&#x2F;变量对应初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后缀自增运算</span><br><span class="line">nvarTwo &#x3D; 5 + (nvarTwo++);</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne，保存在edx中</span><br><span class="line">0040BA34movedx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;讲edx执行加等于5</span><br><span class="line">0040BA37addedx,5</span><br><span class="line">&#x2F;&#x2F;讲edx赋值给变量nvarTwo，可以看到没有对变量nvarOne执行自增操作</span><br><span class="line">0040BA3Amovdword ptr [ebp-8],edx</span><br><span class="line">&#x2F;&#x2F;再次取出变量nvarOne数据存入eax中</span><br><span class="line">0040BA3Dmoveax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;执行eax加等于1</span><br><span class="line">0040BA40addeax,1</span><br><span class="line">将eax赋值给变量nvarOne,等同于对变量nvarOne执行自增1操作</span><br><span class="line">0040BA43movdword ptr [ebp-4],ecx</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c++源码对比，前缀自增运算</span><br><span class="line">nVarTwo &#x3D; 5 + (++nvarOne);</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne数据放入ecx中</span><br><span class="line">0040BA46movecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;对ecx执行加等于1的操作</span><br><span class="line">0040BA49addecx,1</span><br><span class="line">&#x2F;&#x2F;将ecx赋值给变量nvarOne，完成自增1操作</span><br><span class="line">0040BA4Cmovdword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;取出变量nvarOne放到edx中</span><br><span class="line">0040BA4Fmovedx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;对edx执行加等于5</span><br><span class="line">0040BA52addedx,5</span><br><span class="line">&#x2F;&#x2F;将结果edx赋值给变量nvarTwo</span><br><span class="line">0040BA55movdword ptr [ebp-8],edx</span><br><span class="line">&#x2F;&#x2F;自增和自减差不多相同，add替换成sub就可</span><br></pre></td></tr></table></figure><h2 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h2><ul><li>与运算(&amp;&amp;)  </li><li>或运算(||)</li><li>非运算(!)  </li></ul><p><strong>各种关系对应的条件跳转指令如表</strong>  </p><table><thead><tr><th align="center">指令助记符</th><th align="center">检查标记位</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">JZ</td><td align="center">ZF == 1</td><td align="center">等于0则跳转</td></tr><tr><td align="center">JE</td><td align="center">ZF == 1</td><td align="center">相等则跳转</td></tr><tr><td align="center">JNZ</td><td align="center">ZF == 0</td><td align="center">不等于0则跳转</td></tr><tr><td align="center">JNE</td><td align="center">ZF == 0</td><td align="center">不相等则跳转</td></tr><tr><td align="center">JS</td><td align="center">SF == 1</td><td align="center">符号为负则跳转</td></tr><tr><td align="center">JNS</td><td align="center">SF == 0</td><td align="center">符号为正则跳转</td></tr><tr><td align="center">JP/JPE</td><td align="center">PF == 1</td><td align="center">“1”的个数为偶数则跳转</td></tr><tr><td align="center">JNP/JPO</td><td align="center">PF == 0</td><td align="center">“1”的个数为奇数则跳转</td></tr><tr><td align="center">JO</td><td align="center">OF == 1</td><td align="center">溢出则跳转</td></tr><tr><td align="center">JNO</td><td align="center">OF == 0</td><td align="center">无溢出则跳转</td></tr><tr><td align="center">JC</td><td align="center">CF == 1</td><td align="center">进位则跳转</td></tr><tr><td align="center">JB</td><td align="center">CF == 1</td><td align="center">小于则跳转</td></tr><tr><td align="center">JNAE</td><td align="center">CF == 1</td><td align="center">不大于等于则跳转</td></tr><tr><td align="center">JNC</td><td align="center">CF == 0</td><td align="center">无进位则跳转</td></tr><tr><td align="center">JNB</td><td align="center">CF == 0</td><td align="center">不小于则跳转</td></tr><tr><td align="center">JAE</td><td align="center">CF == 0</td><td align="center">大于则跳转</td></tr><tr><td align="center">JBE</td><td align="center">CF == 1或ZF == 1</td><td align="center">小于等于则跳转</td></tr><tr><td align="center">JNA</td><td align="center">CF == 1或ZF == 1</td><td align="center">不大于则跳转</td></tr><tr><td align="center">JNBE</td><td align="center">CF == 0或ZF == 0</td><td align="center">不小于等于则跳转</td></tr><tr><td align="center">JA</td><td align="center">CF == 0或ZF == 0</td><td align="center">大于则跳转</td></tr><tr><td align="center">JL</td><td align="center">SF != OF</td><td align="center">小于则跳转</td></tr><tr><td align="center">JNGE</td><td align="center">SF != OF</td><td align="center">不大于等于则跳转</td></tr><tr><td align="center">JNL</td><td align="center">SF == OF</td><td align="center">不小于则跳转</td></tr><tr><td align="center">JGE</td><td align="center">SF == OF</td><td align="center">不大于等于则跳转</td></tr><tr><td align="center">JLE</td><td align="center">ZF != OF或ZF == 1</td><td align="center">小于等于则跳转</td></tr><tr><td align="center">JNG</td><td align="center">ZF != OF或ZF == 1</td><td align="center">不大于则跳转</td></tr><tr><td align="center">JNLE</td><td align="center">SF == OF且ZF == 0</td><td align="center">不小于等于则跳转</td></tr><tr><td align="center">JG</td><td align="center">SF == OF且ZF == 0</td><td align="center">大于则跳转</td></tr></tbody></table><h2 id="表达式短路"><a href="#表达式短路" class="headerlink" title="表达式短路"></a>表达式短路</h2><p>表达式短路通过逻辑与运算和逻辑或运算使语句根据条件在执行时发生中断，从而不予执行后面的语句。是根据逻辑与和逻辑或运算的特性，如果是与运算，当运算符左边的语句块为假值时，则直接返回假值，不执行右边的语句;如果是或运算，当运算符左边的语句块为真值时，直接返回真值，不执行右边的语句块  </p><p><strong>汇编代码如下</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：递归函数，用于计算整数累计，nNumber为累加值</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">&#x2F;&#x2F;当nNumber等于0时，逻辑与运算符左边的值为假，不会执行右边的语句</span><br><span class="line">&#x2F;&#x2F;形成表达式短路，从而找到递归出口</span><br><span class="line">nNumber &amp;&amp; (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">return nNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应汇编</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">nNumber &amp;&amp; (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">&#x2F;&#x2F;这里为短路模式汇编代码，比较变量nNumber是否等于0</span><br><span class="line">0040BAA8cmpdword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;通过JE跳转，检查ZF标记位等于1跳转</span><br><span class="line">0040BAACjeAccumulation+35h (0040bac5)</span><br><span class="line">&#x2F;&#x2F;跳转失败，进入递归调用</span><br><span class="line">0040BAAEmoveax,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;对变量nNumber减1后，结果作为参数压栈</span><br><span class="line">0040BAB1subeax,1</span><br><span class="line">0040BAB4push eax</span><br><span class="line">&#x2F;&#x2F;继续调用自己，形成递归</span><br><span class="line">0040BAB5call @ILT+30(Accumulation) (00401023)</span><br><span class="line">0040BABAadd esp,4</span><br><span class="line">0040BABDmov ecx,dword ptr [ebp+8]</span><br><span class="line">0040BAC0add ecx,eax</span><br><span class="line">0040BAC2mov dword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;返回变量nNumber</span><br><span class="line">return nNumber</span><br><span class="line">0040BAC5mov eax,dword ptr [ebp+8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数的出口是逻辑式“&amp;&amp;”的左侧判断。逻辑运算“||”虽然与逻辑运算“&amp;&amp;”有些不同，但它们的构成原理相同，只需稍作修改就可以解决上方代码的问题，<strong>代码如下</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，和上面的类似</span><br><span class="line">int Accumulation (int nNumber)&#123;</span><br><span class="line">&#x2F;&#x2F;当nNumber等于0时，逻辑或运算符的左边如果为真就不执行右边的语句</span><br><span class="line">&#x2F;&#x2F;形成表达式短路，从而找到递归的出口</span><br><span class="line">(nNumber &#x3D;&#x3D; 0) || (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">return nNumber;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码</span><br><span class="line">int Accumulation(int nNumber)&#123;</span><br><span class="line">(nNumber &#x3D;&#x3D; 0) || (nNumber +&#x3D; Accumulation(nNumber - 1));</span><br><span class="line">00401618cmpdword ptr [ebp+8],0</span><br><span class="line">0040161Cje Acumulation+35h (00401635)</span><br><span class="line">0040161Emoveax,dword ptr [ebp+8]</span><br><span class="line">00401621subeax,1</span><br><span class="line">00401624push eax</span><br><span class="line">00401625call @ILT+30(Accumulation) (00401023)</span><br><span class="line">0040162Aaddesp,4</span><br><span class="line">0040162Dmov ecx,dword ptr [ebp+8]</span><br><span class="line">00401630addecx,eax</span><br><span class="line">00401632movdword ptr [ebp+8],ecx</span><br><span class="line">return nNumber</span><br><span class="line">00401635mov eax,dword ptr [ebp+8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>条件表达式也称为三目运算：<br>            表达式1 ? 表达式2 : 表达式3<br>这个意思是如果表达式1是真值，则执行表达式2，如果是假值，则执行表达式3  </p><p>表达式1，2，3都可以套用到条件表达式中。条件表达式被套用后，其执行顺序依然是由左向右，自内向外。当表达式2与表达3都为常量时，条件表达式可以被优化:而当表达式2或表达式3中的一个为变量时，条件表达式不可以被优化，会转换成分支结构。当表达式1为-一个常量值时，编译器会在编译期间得到答案，将不会有条件表达式存在，共有四套转换方案  </p><ul><li>表达式1为简单比较，而表达式2和表达式3两者的差值等于1  </li><li>表达式1为简单比较，而表达式2和表达式3两者的差值大于1  </li><li>表达式1为复杂比较，而表达式2和表达式3两者的差值大于1</li><li>表达式2和表达式3有一个为变量，于是无优化  </li></ul><p><strong>方案一具体代码</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，条件表达式</span><br><span class="line">int Condition(int argc , int n)&#123;</span><br><span class="line">&#x2F;&#x2F;比较参数argc是否等于5，真值返回5，假值返回6</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 5 : 6;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编比较</span><br><span class="line">&#x2F;&#x2F;清空eax</span><br><span class="line">00401678xor eax,eax</span><br><span class="line">0040167Acmpdword ptr [ebp+8],5</span><br><span class="line">&#x2F;&#x2F;setne检查ZF标记位，当ZF&#x3D;&#x3D;1，则赋值al为0，反之则赋值al为1</span><br><span class="line">0040167Esetne al</span><br><span class="line">&#x2F;&#x2F;若argc等于5则al&#x3D;&#x3D;0，反之al&#x3D;&#x3D;1，执行这句后，eax正好为5&#x2F;6</span><br><span class="line">00401681addeax,5</span><br></pre></td></tr></table></figure><p><strong>方案二具体代码</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;c++源码说明，条件表达式</span><br><span class="line">int Condition(int argc , int n)&#123;</span><br><span class="line">&#x2F;&#x2F;比较参数argc是否等于5，真值返回5，假值返回6</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 4 : 10;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编比较</span><br><span class="line">return argc &#x3D;&#x3D; 5 ? 4 : 10;</span><br><span class="line">00401678moveax,dword ptr [ebp+8]</span><br><span class="line">0040167Bsubeax,5</span><br><span class="line">0040167Enegeax</span><br><span class="line">00401680sbbeax,eax</span><br><span class="line">&#x2F;&#x2F;eax的取值只可能为0或者0xFFFFFFFF</span><br><span class="line">00401682andeax,6</span><br><span class="line">00401685addeax,4</span><br></pre></td></tr></table></figure><p>对于argc == 5这种等职的比较，VC++会使用减法和求补运算来判断是否为真值，如果我们的argc不为5，那么执行sub指令后的eax就不为0，neg的指令会将eax的符号位发生改变，也就是求补的运算，如果eax为0，也就是argc为5的话，那么0进行补+1，也是0，那么CF=0，我们现在假设CF=1的情况，那么执行sbb eax,eax 等同于了 eax-eax-CF 那么eax会变成0xFFFFFFFF，另一个情况就是0，使用eax与6进行与运算，如果eax数值为0xFFFFFFFF那么 想与就是6，相加4就是10，如果是0的情况那么直接就是0+4 = 4  </p><p><strong>总结</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">sub reg,A</span><br><span class="line">negreg</span><br><span class="line">sbb reg,reg</span><br><span class="line">and reg,B</span><br><span class="line">add reg,C</span><br><span class="line">&#x2F;&#x2F;reg &#x3D;&#x3D; A ? C : B</span><br></pre></td></tr></table></figure><p>如果表达式2大于表达式3,那么最后加的数字为一个负数。这是由表达式3减去表达式2得到的数值  </p><p><strong>方案三具体代码</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明，条件表达式</span><br><span class="line">int Condition(int argc,int n)&#123;</span><br><span class="line">return argc &lt; &#x3D; 8 ? 4 ：10；</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编代码</span><br><span class="line">return argc &lt; &#x3D; 8 ? 4 ：10；</span><br><span class="line">&#x2F;&#x2F;清空eax,与方案1类似</span><br><span class="line">00401678xoreax,eax</span><br><span class="line">0040167Acmpdword ptr [ebp+8],8</span><br><span class="line">&#x2F;&#x2F;根据变量与8进行比较的结果，使用setg指令，当标记位SF&#x3D;OF且ZF&#x3D;0赋值al为1</span><br><span class="line">符号标志位SF（Sign Flag），符号标志SF用来反映运算结果的符号位，他与运算结果的最高位相同</span><br><span class="line">溢出标志位OF（Overflow Flag）：比如有一个杯子，放水放满了再放就出去了，叫溢出，但是怎么区别看起来都是最高位的问题</span><br><span class="line">零标志位ZF（Zero Flag），零标志ZF用来反映运算结果是否为0，如果运算结果为0，则值为1，否则值为0，在判断运算结果是否为0时，可以用此标志位</span><br><span class="line">&#x2F;&#x2F;用于检查变量数据是否大于8，大于则赋值1，小于就赋值0</span><br><span class="line">0040167Esetg al</span><br><span class="line">&#x2F;&#x2F;此时al中只能为0或1，执行自减的操作，eax中为0xFFFFFFFF或0</span><br><span class="line">00401681dec eax</span><br><span class="line">&#x2F;&#x2F;使用al和0xFA做与运算，eax中是0xFFFFFFFA或者0</span><br><span class="line">&#x2F;&#x2F;2-3&#x3D;0xFFFFFFFA</span><br><span class="line">00401682andal,0FAh</span><br><span class="line">&#x2F;&#x2F;由于eax只能有两个结果0xFFFFFFFA(-6)或0，加0x0A后结果比然为4，10</span><br><span class="line">00401684addeax，0Ah</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先调整reg为0或者为-1</span><br><span class="line">and     reg, A</span><br><span class="line">add     reg, B</span><br></pre></td></tr></table></figure><p>遇到这样的代码块，需要重点考察and前的指令，以辨别真假逻辑的处理方式。对于上例中dec reg这样的指令，之前reg只能是0或者是1，因此这里的dec其实是对reg进行修正，如果原来reg为1, dec后修正为0，否则为ffffff，便于其后的and运算。这时候要根据and前的指令流程分析原来的判定在什么情况下会导致reg为0offfffff或者0，以便于还原。编译器这样做是为了避免产生分支语句。而对于顺序结构，处理器会预读下一条指令，以提高运行效率  </p><p><strong>无优化使用分支结果</strong>  </p><p>如果表达式2或者表达式3中的值为未知数时候，就无法使用之前的方案去优化，编译器会那招正常的语句流程进行比较和判断，选择对应的表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：条件表达式</span><br><span class="line">int Condition(int argc,int n)&#123;</span><br><span class="line">return argc ? 8 : n;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编代码</span><br><span class="line">return argc ? 8 : n;</span><br><span class="line">&#x2F;&#x2F;比较变量argc</span><br><span class="line">00401448cmpdword ptr [ebp+8],0</span><br><span class="line">&#x2F;&#x2F;使用JE跳转，检查变量argc是否等于0，跳转的地址为0x00401457位置</span><br><span class="line">004014CCje Condition+27 (00401457)</span><br><span class="line">&#x2F;&#x2F;跳转失败说明操作数1为真，将表达式1的值(立即数8)存入局部变量ebp-4中</span><br><span class="line">0040144Emov dword ptr [ebp-4],8</span><br><span class="line">&#x2F;&#x2F;跳转到返回值赋值处</span><br><span class="line">00401455jmp Condition+2Dh (00145d)</span><br><span class="line">&#x2F;&#x2F;参数2的数据存入eax中</span><br><span class="line">00401457moveax，dword ptr [ebp+0Ch]</span><br><span class="line">0040145Amov dword ptr [ebp-4],eax</span><br><span class="line">0040145Dmoveax,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;恢复现场</span><br><span class="line">00401466ret</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>&lt;&lt;</strong>:左移运算，最高位左移到CF中，最低位补零<br><strong>&gt;&gt;</strong>:右移运算，最高位不变，最低位右移到CF中<br><strong>|</strong>:位或运算，在两个数的相同位上，只要有一个为1，则结果为1<br><strong>&amp;</strong>:位与运算，在两个数的相同位上，只有同时个1，则结果为1<br><strong>^</strong>:异或运算，在两个数的相同位上，当两个值相同时为0，不同时为1<br><strong>~</strong>:取反运算  </p><p><strong>位运算——Debug版</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码对应汇编，位运算(有符号数)</span><br><span class="line">&#x2F;&#x2F;左移运算3次</span><br><span class="line">argc &#x3D; argc &lt;&lt; 3;</span><br><span class="line">00401498moveax,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;左移运算对应汇编指令SHL</span><br><span class="line">0040149Bshleax,3</span><br><span class="line">0040149Emovdword ptr [ebp+8],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，右移运算5</span><br><span class="line">argc &#x3D; argc &gt;&gt; 5;</span><br><span class="line">004014A1movecx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;右移运算对应汇编指令SAR</span><br><span class="line">004014A4sarecx,5</span><br><span class="line">004014A7movdword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，位或运算，变量argc低16位不变，高16位设置为1</span><br><span class="line">argc &#x3D; argc | 0xFFFF0000</span><br><span class="line">004014AAmov edx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;位或运算对应汇编指令OR</span><br><span class="line">004014ADoredx,0FFFF0000h</span><br><span class="line">004014B3movdword ptr [ebp+8],edx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，将变量argc低16位清0，高位不变</span><br><span class="line">argc &#x3D; argc &amp; 0xFFFF0000</span><br><span class="line">&#x2F;&#x2F;位与运算对应汇编指令AND</span><br><span class="line">004014B9and eax，0xFFFFh</span><br><span class="line">004014BEmovdword ptr [ebp+8],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量argc做异或运算</span><br><span class="line">argc &#x3D; argc ^ 0xFFFF0000</span><br><span class="line">004014C1movecx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;异或运算对应汇编指令XOR</span><br><span class="line">004014C4xor ecx,0FFFF0000h</span><br><span class="line">004014CAmovdword ptr [ebp+8],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，将argc按位取反</span><br><span class="line">argc &#x3D; ~argc;</span><br><span class="line">004014CDmovedx,dword ptr [ebp+8]</span><br><span class="line">&#x2F;&#x2F;取反运算对应汇编指令NOT</span><br><span class="line">004014D0notedx</span><br><span class="line">004014D2movdword ptr [ebp+8],edx</span><br></pre></td></tr></table></figure><p><strong>无符号数位移</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：无符号数位移</span><br><span class="line">int BitOperation(int argc)&#123;</span><br><span class="line">unsigned int nVar &#x3D; argc;</span><br><span class="line">nVar &lt;&lt;&#x3D; 3;</span><br><span class="line">nVar &gt;&gt;&#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码对应汇编代码讲解</span><br><span class="line">unsigned int nVar &#x3D; argc;</span><br><span class="line">004016C8moveax,dword ptr [ebp+8]</span><br><span class="line">004016CBmovdword ptr [ebp-4],eax</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量nVar左移3位</span><br><span class="line">nVar &lt;&lt;&#x3D; 3;</span><br><span class="line">004016CEmovecx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;和有符号数左移一样</span><br><span class="line">004016D1shlecx,3</span><br><span class="line">004016D4movdword ptr [ebp-4],ecx</span><br><span class="line">&#x2F;&#x2F;C++源码对比，对变量nVar右移5位</span><br><span class="line">004016D7movedx,dword ptr [ebp-4]</span><br><span class="line">&#x2F;&#x2F;使用shr进行右移位，最高位补0，最低位进CF</span><br><span class="line">004016DAshr edx,5</span><br><span class="line">004016DDmov dword ptr [ebp-4],edx</span><br></pre></td></tr></table></figure><p>符号数与无符号数的差别在右移运算，有符号数对应的指令为sar，可以保留符号位;无符号数不需要符号位，所以直接使用shr将最高位补0  </p><h2 id="编译器使用的优化技巧"><a href="#编译器使用的优化技巧" class="headerlink" title="编译器使用的优化技巧"></a>编译器使用的优化技巧</h2><p><strong>代码优化</strong>:是指为了达到某一种优化目的对程序代码进行变换。这样的变换有一个原则:<strong>变化前和变换后等价</strong>  </p><p>就优化目的而论，代码优化一般有四个方向：  </p><ul><li>执行速度优化</li><li>内存存储空间优化</li><li>磁盘存储空间优化</li><li>编译时间优化</li></ul><p>编译器的工作过程中可以分为几个阶段:预处理→词法分析→语法分析→语义分析→中间代码生成→目标代码生成。其中，优化的机会一般存在于中间代码生成和目标代码生成这两个阶段。尤其是在中间代码生成阶段所做的优化，这类优化不具备设备相关性，在不同的硬件环境中都能通用，因此编译器设计者广泛采用这类办法  </p><ul><li><p>常量折叠<br>x = 1 + 2<br>1和2都是常量，所以结果可以预见，直接生成x = 3  </p></li><li><p>常量传播<br>接上面的代码，其后代码为y = x + 3;由于上例最后生成了x = 3，其结果还是可以预见的，所以直接生成y = 6  </p></li><li><p>减少变量<br>假设一个 x = i * 2 y = j * 2 if(x&gt;y){}这里的x和y比较等价于i和j的比较，所以如果后面没有引用x，y，那么就会直接去掉x，y，生成 if(i&gt;j)</p></li><li><p>公共表达式<br>那么假设 x = i * 2，y = i * 2所以 i * 2 叫做公共表达式，可以归并为一个，x = i * 2，y = x  </p></li><li><p>复写传播<br>类似于常量传播，但是目标变成了变量，示例如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; a;</span><br><span class="line">……</span><br><span class="line">y &#x3D; x + c;</span><br></pre></td></tr></table></figure></li></ul><p>如果省略号表示的代码中没有修改变量x，则可以直接用变量a代替x：<br>y = a + c  </p><ul><li><p>剪去不可达分支<br>如果if作用域内的代码内容永远不会被执行，因此整个if代码块没有存在的理由  </p></li><li><p>还有顺序语句代替分支，强度削弱，数学变换，代码外提等等  </p></li></ul><h3 id="流水线优化"><a href="#流水线优化" class="headerlink" title="流水线优化"></a>流水线优化</h3><ol><li>取指令：CPU从高速缓存或内存中取机器码  </li><li>指令译码：分析指令的长度，功能和寻址方式</li><li>按寻址方式确定操作数：指令的操作数可以是寄存器，内存单元或者立即数，如果操作数在内存单元里，这一步就要计算出有效地址</li><li>取操作数：按操作数存放的位置获得数值，并存放在临时寄存器中</li><li>执行指令：由控制单元或者计算单元执行指令规则的操作</li><li>存放计算结果</li></ol><p>来个例子~  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行指令： addeax,dword ptr ds:[ebx+40DA44]</span><br><span class="line">对应的机器代码： 038344DA4000</span><br></pre></td></tr></table></figure><p>Intel处理器位小端序排列，数据的高位对应内存的高地址，低位对应内存的低地址  </p><p>步骤：取指令，得到第一个十六进制字节：0x03，并且eip+1，译码知道这个指令是加法，但是信息不够，于是乎将0x03放入处理器的指令队列缓存中，取指令得到第二个十六进制字节：0x83，机器码放入处理器的指令队列缓存中，eip+1，译码后知道这个寄存器相对寻址方法的加法，而且参与寻址的寄存器是ebx，存放的目标是eax，后面还有4字节的偏移，指令长度确定后，机器码放入处理器的指令队列，取地址，得到第三个十六进制字节：0x44，这是指令中包含的4字节地址偏移量信息的第一个字节，放入内部暂存区，ebx保存在ALU，准备计算有效的地址，eip+1，之后依次开始取指令0xDA 0x40 0x00 放入寄存器，eip依次+1，这时候eax的值传给ALU，调度MMU，得到内存单元，传送到ALU，计算结果，最后将计算结果存回eax中  </p><p><strong>流水线</strong>  </p><p>来个例子~  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004010AAmoveax,92492493h</span><br><span class="line">004010AFaddesp,8</span><br></pre></td></tr></table></figure><p>执行这段代码，不具备流水线的处理器先读取004010AA处的二进制指令，然后开始译码等操作，这–系列工作的每–步都是需要时间的，比如取指令，内存管理单元开始工作，其他部件闲置等待，等拿到了指令才进行下一步工作。于是，为了提高效率，Intel 公司从486开始就引入了流水线的机制  </p><p>引入流水线之后，在第一条流水线执行mov指令的过程中，第二条流水线就可以开始对add执行读取和译码了，Intel采用长流水线设计，把每条指令划分出很多阶段，使得每个步骤的工作内容简单，但这容易取指令错误的时候回滚操作过多，AMD厂商使用多流水线设计，回滚错误少，但电路设计复杂  </p><p><strong>注意点</strong>  </p><ul><li><p>指令相关性<br>对于顺序安排的两条指令，后一条指令的执行依赖前–条指令的硬件资源，这样的情况就是指令相关，如下面的代码所示:<br>add     edx,esi<br>sar     edx,2<br>由于以上两条代码都需要访问并设置edx，因此只能在执行完add edx,esi后才能执行sar edx, 2。这样的情况会存在寄存器的争用，影响并行效率，应尽量避免  </p></li><li><p>地址相关性  </p></li></ul><p>对于顺序安排的两条指令，前一条指令需要访问并回写到某一地址上，而后一条指令也需要访问这一-地址，这样的情况就是地址相关，如下面的代码所示:  </p><p>add     [00401234], esi<br>mov     eax, [00401234]  </p><p>由于第一条指令访问的是0x401234地址，那么只能第一条指令操作完后再去执行第二条语句，会影响效率，VC++的O2的release选项生成的代码会考虑流水线执行的工作方式</p><p>代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0040101Fpush eax</span><br><span class="line">00401020push offset aNvarone2D ; &quot;nVarOne &#x2F; 2 &#x3D; %d&quot;</span><br><span class="line">00401025call _printf</span><br><span class="line">0040102Amoveax,92492493h</span><br><span class="line">0040102Faddesp,8</span><br><span class="line">00401032imul esi</span><br><span class="line">00401034add edx,esi</span><br><span class="line">00401036sar edx,2</span><br><span class="line">00401039mov eax,edx</span><br><span class="line">0040103Bshr eax,1Fh</span><br><span class="line">0040103Eaddedx,eax</span><br></pre></td></tr></table></figure><p>恢复栈顶的指令add esp,8，中间有mov eax,92492493h指令，这里为流水线优化，因为后面的imul esi需要设置eax，把计算结果的低位放在eax中，那么中间换成add esp,8防止了寄存器争用，后面的这里的 add edx,esi 与 sar edx,2不能移动是因为，在后面的mov eax,edx 与 edx有关系，如果位置移动的话，我们会出现edx的一个的计算结果不正确，于是乎不能改变顺序  </p><h3 id="分支优化"><a href="#分支优化" class="headerlink" title="分支优化"></a>分支优化</h3><p>配合流水线的工作模式，处理器增加了一个分支目标缓冲器，在流水线的工作模式下，如果遇见分支结构，我们就可以利用分支目标缓冲器预测并且读取指令的目标地址，分支目标缓冲器在程序运行的时候将动态记录和调整转移指令的目标地址，可以记录多个地址，进行表格化的管理，当发生转移的时候秒如果分支目标缓冲器中有记录，下一条指令在取指令阶段就会将其作为目标地址，如果我们记录地址不等于实际目标地址，就会被流水线冲刷，用一个分支，多次与邪恶失败，就会更新记录目标地址，所以我们在编写多重循环的时候，要把大循环放在内层，可以增加分支预测的准确度  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i &lt; 10; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;下面每次循环会预测成功9999次</span><br><span class="line">&#x2F;&#x2F;第一次没有预测，最后退出循环的时候预测失败1次</span><br><span class="line">&#x2F;&#x2F;重复10次</span><br><span class="line">for(int j &#x3D; 0 ; j &lt; 10000 ; j++)&#123;</span><br><span class="line">a[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i &lt; 10000; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;下面每次循环会预测成功9次</span><br><span class="line">&#x2F;&#x2F;第一次没有预测，最后退出循环的时候预测失败1次</span><br><span class="line">&#x2F;&#x2F;重复10000次</span><br><span class="line">for(int j &#x3D; 0 ; j &lt; 9 ; j++)&#123;</span><br><span class="line">a[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高速缓存优化规则"><a href="#高速缓存优化规则" class="headerlink" title="高速缓存优化规则"></a>高速缓存优化规则</h3><ol><li><p>数据对齐<br>cache不会保存VA的二进制低位，对于Intel的32位处理器来说，如果访问的地址是4的倍数，则可以直接查询并提取之;如果不是4的倍数，则需要访问多次。因此，VC++编译器在设置变量地址时会按照4字节边界对齐  </p></li><li><p>数据集中<br>将访问次数多的数据或代码尽量安排在-起，一方面是cache在抓取命中数据时会抓取周围的其他数据;另- -方面是虚拟内存分页的问题，如果数据分散，保留到多个分页中，就会导致过多的虚拟地址转换，甚至会导致缺页中断频繁发生，这些都会影响效率  </p></li><li><p>减少体积<br>命中率高的代码段应该减少体积，尽量放入cache中，以提高效率  </p></li></ol><p>第四章记录完毕<del>~</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》(二)&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术(四)</title>
    <link href="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/"/>
    <id>http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E5%9B%9B/</id>
    <published>2020-06-19T15:40:25.000Z</published>
    <updated>2020-08-06T01:44:56.663Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(四)  </p><a id="more"></a>  <h1 id="变量在内存中的位置和访问方式"><a href="#变量在内存中的位置和访问方式" class="headerlink" title="变量在内存中的位置和访问方式"></a>变量在内存中的位置和访问方式</h1><ul><li><p>变量的作用域</p><p>指的是变量在源码中可以被访问到的范围。全局变量属于进程作用域，也就是说，在整个进程中都能够访问到这个全局变量;静态变量属于文件作用域，在当前源码文件内可以访问到:局部变量属于函数作用域，在函数内可以访问到;在“{}”语句块内定义的变量，属于块作用域，只能在定义变量的“{ }”块内访问到。</p></li><li><p>变量的生命周期</p><p>指的是变量所在的内存从分配到释放的这段时间。变量所在的内存被分配后，我们可以形象地将这比喻为变量的生命开始;变量所在的内存被释放后，我们可以将这比喻为变量的消亡。</p></li></ul><h2 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h2><p>在大多数情况下，在PE文件中的只读数据节中，常量的节属性被修饰为不可写，而全局变量和静态变量则在属性为可读写的数据节中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int g_nVariableType &#x3D; 117713190;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">008F19D0 55                   push        ebp  </span><br><span class="line">008F19D1 8B EC                mov         ebp,esp  </span><br><span class="line">008F19D3 81 EC C0 00 00 00    sub         esp,0C0h  </span><br><span class="line">008F19D9 53                   push        ebx  </span><br><span class="line">008F19DA 56                   push        esi  </span><br><span class="line">008F19DB 57                   push        edi  </span><br><span class="line">008F19DC 8D BD 40 FF FF FF    lea         edi,[ebp-0C0h]  </span><br><span class="line">008F19E2 B9 30 00 00 00       mov         ecx,30h  </span><br><span class="line">008F19E7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  </span><br><span class="line">008F19EC F3 AB                rep stos    dword ptr es:[edi]  </span><br><span class="line">008F19EE B9 26 C0 8F 00       mov         ecx,offset _DC5A83E8_main@cpp (08FC026h)  </span><br><span class="line">008F19F3 E8 33 F8 FF FF       call        @__CheckForDebuggerJustMyCode@4 (08F122Bh)  </span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;g_nVariableType);</span><br><span class="line">008F19F8 68 00 A0 8F 00       push        offset g_nVariableType (08FA000h)  </span><br><span class="line">008F19FD 68 30 7B 8F 00       push        offset string &quot;%d&quot; (08F7B30h)  </span><br><span class="line">008F1A02 E8 4D F7 FF FF       call        _scanf_s (08F1154h)  </span><br><span class="line">008F1A07 83 C4 08             add         esp,8  </span><br><span class="line">printf(&quot;%d \r\n&quot;, g_nVariableType);</span><br><span class="line">008F1A0A A1 00 A0 8F 00       mov         eax,dword ptr [g_nVariableType (08FA000h)]  </span><br><span class="line">008F1A0F 50                   push        eax  </span><br><span class="line">008F1A10 68 34 7B 8F 00       push        offset string &quot;%d \r\n&quot; (08F7B34h)  </span><br><span class="line">008F1A15 E8 2C F6 FF FF       call        _printf (08F1046h)  </span><br><span class="line">008F1A1A 83 C4 08             add         esp,8  </span><br><span class="line">&#125;</span><br><span class="line">008F1A1D 33 C0                xor         eax,eax  </span><br><span class="line">008F1A1F 5F                   pop         edi  </span><br><span class="line">008F1A20 5E                   pop         esi  </span><br><span class="line">008F1A21 5B                   pop         ebx  </span><br><span class="line">008F1A22 81 C4 C0 00 00 00    add         esp,0C0h  </span><br><span class="line">008F1A28 3B EC                cmp         ebp,esp  </span><br><span class="line">008F1A2A E8 06 F8 FF FF       call        __RTC_CheckEsp (08F1235h)  </span><br><span class="line">008F1A2F 8B E5                mov         esp,ebp  </span><br><span class="line">008F1A31 5D                   pop         ebp  </span><br><span class="line">008F1A32 C3                   ret</span><br></pre></td></tr></table></figure><p>通过对代码的分析可知，访问全局变量与访问常量类似——都是通过立即数来访问。由于全局变量在编译期就已经确定了具体的地址，因此编译器在编译的过程中可以计算出一个固定的地址值。而局部变量需要进入作用域内，通过申请栈空间存放，利用栈指针ebp或esp间接访问，其地址是-一个未知可变值，编译器无法预先计算。</p><p>全局变量在内存中的地址顺序是<strong>先定义的变量在低地址，后定义变量在高地址。</strong></p><p>全局变量的特征：</p><ul><li>所在地址为数据区，生命周期与所在模块一致</li><li>使用立即数间接访问</li></ul><p>局部变量的特征：</p><ul><li>所在地址为栈区，生命周期与所在的函数作用域一致</li><li>使用ebp或esp间接访问</li></ul><h2 id="局部静态变量的工作方式"><a href="#局部静态变量的工作方式" class="headerlink" title="局部静态变量的工作方式"></a>局部静态变量的工作方式</h2><p>静态变量分为全局静态变量和局部静态变量。</p><p>全局静态变量等价于<strong>编译器限制外部源码文件访问的全局变量。</strong></p><p>局部静态变量比较特殊，它不会随作用域的结束而消失，并且在未进人作用域之前就已经存在，其生命周期也和全局变量相同。<strong>局部静态变量会预先被作为全局变量处理，而它的初始化部分只是在做赋值操作。</strong></p><p>来个demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：全局变量的访问</span><br><span class="line">void ShowStatic(int nNumber)&#123;</span><br><span class="line">static int g_snNumber &#x3D; nNumber;&#x2F;&#x2F;定义局部静态变量，赋值为参数</span><br><span class="line">printf(&quot;%d \r\n&quot;,g_snNumber);&#x2F;&#x2F;显示静态变量</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">for(int i &#x3D; 0;i &lt; 5;i++)&#123;</span><br><span class="line">ShowStatic(i);&#x2F;&#x2F;循环调用显示局部静态变量的函数，每次传入不同值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ShowStatic 函数内实现过程</span><br><span class="line">void ShowStatic (int nNumber) &#123;</span><br><span class="line">;在Debug版下保存环境、开辟栈、初始化部分略</span><br><span class="line">static int g_snNumber &#x3D; nNumber;&#x2F;&#x2F;定义局部静态变量</span><br><span class="line">0040D9D8xoreax,eax;清空eax</span><br><span class="line">;取地址0x004257CC处1字节数据到al中</span><br><span class="line">0040D9DAmoval, [&#39; ShowStatic&#39; : :&#39;2&#39;: :$S1 (004257cc) ] </span><br><span class="line">;将eax与数值1做位与运算，eax最终结果只能是0或1</span><br><span class="line">0040D9DFandeax,1</span><br><span class="line">0040D9E2testeax,eax</span><br><span class="line">;比较eax， 不等于0则执行跳转，跳转到地址0x0040D9FE处</span><br><span class="line">0040D9E4jneShowStatic+3Eh (0040d9fe)</span><br><span class="line">;将之前比较是否为0值的地址取出数据到c1中</span><br><span class="line">0040D9E6movc1,byte ptr [&#39; ShowStatic&#39; ::&#39;2&#39;: :$S1 (004257cc)]</span><br><span class="line">;将c1与数值1做位或运算，cl的最低位将被置1，其他位不变</span><br><span class="line">0040D9ECorcl,1</span><br><span class="line">;再将置位后的cl存回地址0x004257CC处</span><br><span class="line">0040D9EFmovbyte ptr [&#39;ShowStatic&#39; ::&#39;2&#39;::SS1 (004257cc)],cl</span><br><span class="line">;取出参数信息放入edx中</span><br><span class="line">0040D9F5movedx, dword ptr [ebp+8]</span><br><span class="line">;将edx赋值到地址0x004257C8处，即将局部静态变量赋值为edx中保存的数据</span><br><span class="line">0040D9F8 movdword ptr [___sbh_sizeHeaderList+4 (004257c8)] , edx</span><br><span class="line">printf(&quot;%d \r\n&quot;, g_snNumber); &#x2F;&#x2F; 显示局部静态变量中的数据</span><br><span class="line">;局部静态变量的访问，和全局变量的访问方式一样</span><br><span class="line">0040D9FEmoveax,[__ sbh_sizeHeaderList+4 (004257c8)]</span><br><span class="line">;printf略</span><br></pre></td></tr></table></figure><p>地址0x004257CC中保存了局部静态变量的一个标志，这个标志占位1个字节。通过位运算，将标志中的一位数据置1，以此判断局部静态变量是否已经被初始化过。由于一个静态变量只使用了1位，而1个字节数据占8位，因此这个标志可以同时表示8个局部静态变量的初始状态。通常，在VC++6.0中，标志所在的内存地址在最先定义的局部静态变量地址的附近，如最先定义的整型局部静态变量在地址0x004257C0处，那么标记位通常在地址0x004257C4或0x004257BC处。当同一作用域内超过8个局部静态变量时，下一个标记位将会在第9个定义的局部静态变量地址附近。识别局部静态变量的标志位地址并不是目的，主要是根据这个标志位来区分全局变量与局部静态变量。</p><p>但是当局部静态变量被初始化为一个常量值时，这个局部静态变量<strong>在初始化过程中不会产生任何代码</strong>。</p><p>由于初始化的数值为常量，即多次初始化不会产生变化。这样无需再做初始化标志，编译器采用了<strong>直接以全局变量方式处理，</strong>优化了代码，提升了效率。虽然转换为了全局变量，但仍然不可以超出作用域访问。那么编译器是如何让其他作用域对局部静态变量不可见的呢?通过<strong>名称粉碎法</strong>，在编译期将静态变量重新命名。</p><p>来个总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; reg_flag表示存放初始化标志的寄存器r8，通常使用寄存器中的低位，如al等</span><br><span class="line">;INIT__FLAG表示初始化标记</span><br><span class="line">movreg_flag,INIT_FLAG</span><br><span class="line">; reg_data表示存放静态变量初值的寄存器</span><br><span class="line">movreg_data,mem; reg_data值为初值，其来源可能因程序不同而不同</span><br><span class="line">testreg_data,1\2\8..0x80;测试标志位</span><br><span class="line">jxxINIT_END;跳转成功，表示已经被初始化过</span><br><span class="line">orreg_flag, 1\2\8..0x80;修改标志寄存器中的数据</span><br><span class="line">; STATIC_DATA表示静态变量</span><br><span class="line">movSTATIC_DATA,reg_data;初始化静态变量</span><br><span class="line">movINIT_FLAG,reg_flag;修改该静态变量初始化标志位</span><br><span class="line">INIT_END;</span><br></pre></td></tr></table></figure><h2 id="堆变量"><a href="#堆变量" class="headerlink" title="堆变量"></a>堆变量</h2><p>new和malloc的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++ 源码说明(Debug 编译选项) ; new与malloc</span><br><span class="line">&#x2F;&#x2F; mal1oc 内部实现</span><br><span class="line">char * pCharMalloc &#x3D; (char*) malloc (10) ;</span><br><span class="line">_CRTIMP void * __cdecl malloc (</span><br><span class="line">size_t nSize</span><br><span class="line">)&#123;</span><br><span class="line">&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;new内部实现</span><br><span class="line">char * pCharNew &#x3D; new char [10] ;</span><br><span class="line">void * operator new( unsigned int cb ) &#123;</span><br><span class="line">return _nh_malloc( cb, 1 ) ;</span><br><span class="line">&#125;</span><br><span class="line">void *  __cdecl _nh_malloc (</span><br><span class="line">size_t nSize,</span><br><span class="line">int nhFlag</span><br><span class="line">)&#123;</span><br><span class="line">&#x2F;&#x2F;使用_nh_malloc_dbg申请堆空间</span><br><span class="line">return _nh_malloc_dbg (nSize,_newmode,_NORMAL_BLOCK, NULL, 0) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆空间的分配类似于商场中的商铺管理，malloc是从商场的空地中划分出一块作为商铺，而new则可以将划分好的商铺直接租用。由于malloc缺少商铺的营业范围规定，因此需要将申请好的堆强制转换以说明其类型方可使用，而new则无需这种操作，直接可以使用。</p><p>申请堆空间的过程中调用了函数 _ heap_ alloc_dbg， 其中使用 _CrtMemBlockHeader结构描述了堆空间中的各个成员。在内存中，堆结构的每个节点都是使用双向链表的形式存储的，在 _CrtMemBlockHeader 结构中定义了前指针pBlockHeaderPrev 和后指针pBlockHeaderNext，通过这两个指针就可遍历程序中申请的所有堆空间。成员lRequest记录了当前堆是第几次申请的，例如第10次申请堆操作对应的数值为0x0A; 成员gap为保存堆数据的数组，在Debug版下，这个数据的前后4个字节被初始化为0xFD,用于检测堆数据访问过程中是否有越界访问。 _CrtMemBlockHeader 结构的原型如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _CrtMemBlockHeader&#123;</span><br><span class="line">struct _CrtMemBlockHeader *pBlockHeaderNext ;&#x2F;&#x2F;下一块堆空间首地址(实际上指向的是前一次申请的堆信息)</span><br><span class="line">struct _CrtMemBlockHeader *pBlockHeaderPrev;&#x2F;&#x2F;上一块堆空间首地址(实际上指向的是后一次申请的堆信息)</span><br><span class="line">char  * szFileName;</span><br><span class="line">int nLine;</span><br><span class="line">size_tnDataSize;&#x2F;&#x2F;堆空间数据大小</span><br><span class="line">int  nBlockUse;</span><br><span class="line">long  lRequest;&#x2F;&#x2F;堆申请次数</span><br><span class="line">unsigned char  gap[nNoMansLandSize];&#x2F;&#x2F;堆空间数据</span><br><span class="line">&#125; _CrtMenBlockHeader;</span><br></pre></td></tr></table></figure><p>来个实操，我太懒了直接拿书上的图吧，嘻嘻嘻</p><p><img src="P1.jpg" alt="堆空间数据说明"></p><p>在图中，内存监视窗口的数据为使用malloc后申请的堆空间数据。new或malloc函数返回的地址为堆数据地址0x00431BF0，堆数据地址减4后，其数据为0xFDFDFDFD,这是往上越界的检查标志。堆数据地址减8后数据为0x2A,表示此堆空间为第0x2A次申请堆操作，说明在其之前多次申请过堆空间。堆数据空间的容量存储在地址0x00431BE0处，该堆空间占10个字节大小。地址0x00431BD0处为上一个堆空间首地址。地址0x00431BD4处的数据为0，表示没有下个一堆空间。在堆数据的末尾也加入了0xFDFDFDFD，这是往下越界的检查标志，这是程序编译方式为Debug版的重要特征之一。</p><h1 id="数组和指针的寻址"><a href="#数组和指针的寻址" class="headerlink" title="数组和指针的寻址"></a>数组和指针的寻址</h1><h2 id="数组在函数内"><a href="#数组在函数内" class="headerlink" title="数组在函数内"></a>数组在函数内</h2><p>对于数组的识别，判断数据在内存中是否连续并且类型是否一致，均符合即可将此段数据视为数组。</p><p>在C++中，字符串本身就是数组，根据约定，该数组的最后-一个数据统一使用0作为字符串结束符。在VC++ 6.0编译器下，为字符类型的数组赋值(初始化)其实是复制字符串的过程。这里并不是单字节复制，而是每次复制4字节的数据。两个内存间的数据传递需要借用寄存器，而每个寄存器一次性可以保存4字节的数据，如果以单字节的方式复制就会浪费掉3字节的空间，而且多次数据传递也会降低执行效率。如果字符串字节数不满足4的倍数，<strong>最后一次数据复制过程中按照1或者2字节的方式复制。</strong></p><h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><p>来份代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组作为参数</span><br><span class="line">void Show(char szBuff[])&#123;</span><br><span class="line">strcpy(szBuff,&quot;Hello,World&quot;);</span><br><span class="line">printf(&quot;%S&quot;,szBuff);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">char szHello[20] &#x3D; &#123;0&#125;;</span><br><span class="line">Show(szHello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">; Debug保存环境初始化栈略</span><br><span class="line">char szHe11o[20] &#x3D; &#123;0&#125;;</span><br><span class="line">; ebp-14h为数组szHello首地址，数组初始化为0</span><br><span class="line">0040B7C8movbyte ptr [ebp-14h] ,0</span><br><span class="line">0040B7CCxoreax,eax</span><br><span class="line">0040B7CEmovdword ptr [ebp-13h] ，eax</span><br><span class="line">0040B7D1movdword ptr [ebp-0Fh] ，eax</span><br><span class="line">0040B7D4movdword ptr [ebp-0Bh] ，eax</span><br><span class="line">0040B7D7movdword ptr [ebp-7h] ，eax</span><br><span class="line">0040B7DAmovword ptr [ebp-3h] ，ax</span><br><span class="line">0040B7DEmovbyte ptr [ebp-1h] ，al</span><br><span class="line">Show(szHello);</span><br><span class="line">0040B7E1leaecx,[ebp-14h];取数组首地址存入ecx</span><br><span class="line">0040B7E4pushecx</span><br><span class="line">0040B7E5call@ILT+5 (Show) (0040100a) ;调用Show函数</span><br><span class="line">0040B7EAaddesp,4</span><br><span class="line">; 略</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Show函数实现部分</span><br><span class="line">void Show (char szBuff []) &#123;</span><br><span class="line">strcpy (szBuff, &quot;Hello world&quot;) ;</span><br><span class="line">;获取常量首地址，并将此地址压入栈中作为strcpy参数</span><br><span class="line">0040B488pushoffset string &quot;Hello world&quot; (0041f01c)</span><br><span class="line">;取函数参数 szBuff地址存入eax中</span><br><span class="line">0040B48Dmoveax , dword ptr [ebp+8]</span><br><span class="line">;将eax压栈作为strcpy参数</span><br><span class="line">0040B490pusheax</span><br><span class="line">0040B491callstrcpy (00404570)</span><br><span class="line">0040B496addesp,8</span><br><span class="line">printf(szBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组作为参数时，数组的下标值被省略了。这是因为，当数组作为函数形参时，函数参数中保存的是数组的首地址，是一个指针变量。</p><p>在release版下，字符串处理函数会被作为内联函数编译处理，康康：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码对照</span><br><span class="line">int GetLen (char szBuff[] ) &#123;</span><br><span class="line">return strlen(szBuff);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用O2选项后的优化代码</span><br><span class="line">sub_401000 proc near;函数起始处</span><br><span class="line">arg_0 &#x3D; dword ptr 4;参数标号</span><br><span class="line">pushedi</span><br><span class="line">movedi, [esp+4+arg_0];获取参数内容，向edi中赋值字符串首地址</span><br><span class="line">orecx,0FFFFFFFFh;将ecx置为-1，是为了配合repne scasb指令</span><br><span class="line">xoreax,eax</span><br><span class="line">;repne&#x2F;repnz与scas指令结合使用，表示串未结束(ecx!&#x3D;0)</span><br><span class="line">;当eax与串元素不相同(ZF&#x3D;0)时，继续重复执行串搜索指令</span><br><span class="line">;可用来在字符串中查找和eax值相同的数据位置</span><br><span class="line">repne scasb;执行该指令后，ecx中保存了字符串长度的补码</span><br><span class="line">notecx;先对ecx取反</span><br><span class="line">dececx;对取反后的ecx减1,得到字符串长度</span><br><span class="line">popedi</span><br><span class="line">moveax,ecx;设置eax为字符串长度，用于函数返回</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp;函数终止处</span><br></pre></td></tr></table></figure><p>​    这个实现过程为先将eax清零，然后通过指令repne scasb遍历字符串，寻找和eax匹配的字符。由于指令repne scasb中的前缀repne是用来考察ecx的值，因此在ecx不为0且ZF标志为0时才重复操作，在操作过程中对ecx自动减1。</p><p>​    ecx的初始值为0xffffffff，有符号数值为-1，repne前缀每次执行时会自动减1，如果edi指向的内容为字符串结束符(asc 值0),则重复操作结束。注意，重复操作完成时ecx的计数包含了字符串末尾的0。假设字符串长度为Len,我们可得到等式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ecx(终值) &#x3D; ecx(初值) - (Len+1)</span><br><span class="line">将ecx初值 -1 代入得：</span><br><span class="line">ecx(终值) &#x3D; -1 - (Len+1) &#x3D; -(Len+2)</span><br><span class="line">定义neg为求补运算，则有:</span><br><span class="line">neg(ecx(终值)) &#x3D; Len + 2</span><br><span class="line">求补运算等价于取反加1，定义not为取反运算，则有:</span><br><span class="line">neg(ecx(终值))+1 &#x3D; Len + 2</span><br><span class="line">解方程求Len:</span><br><span class="line">Len &#x3D; not(ecx(终值)) - 1</span><br></pre></td></tr></table></figure><p>那strcpy函数原型也比较好分析了，release版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;main函数讲解略</span><br><span class="line">;Show函数实现</span><br><span class="line">;int __cdecl sub_401000 (char *Format) ;函数类型识别</span><br><span class="line">sub_401000 proc near</span><br><span class="line"></span><br><span class="line">Format &#x3D; dword ptr 4;函数参数识别</span><br><span class="line">pushesi</span><br><span class="line">pushedi</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;这段代码似曾相识，就是之前所分析的优化后的求字符串长度函数strlen的内联方式</span><br><span class="line">mov edi,offset aHelloWorld ;&quot;Hello World&quot;</span><br><span class="line">orecx,0FFFFFFFFh</span><br><span class="line">xoreax,eax</span><br><span class="line">repne scasb</span><br><span class="line">moveax,[esp+8+Format];取参数所在地址存入eax中</span><br><span class="line">notecx;对ecx取反，得到字符串长度加1</span><br><span class="line">; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;执行指令repne scasb后，edi指向字符串末尾，减去ecx重新指向字符串首地址</span><br><span class="line">subedi,ecx</span><br><span class="line">pusheax;将保存参数地址eax压栈</span><br><span class="line">movedx,ecx;使用edx保存常董字符串长度</span><br><span class="line">movesi,edi;将esi设置为常量字符串首地址</span><br><span class="line">mov edi,eax;将edi设置为参数地址</span><br><span class="line">shrecx,2;将ecx右移2位等同于将字符串长度除以4</span><br><span class="line">;此指令为拷贝字符串，每次复制4字节长度，根据ecx中的数值决定复制次数。将esi中的指向数据每次以4字节复制到edi所指向的内存中，每次复制后，esi与edi自加4</span><br><span class="line">rep movsd</span><br><span class="line">movecx,edx;重新将字符串长度存入ecx中</span><br><span class="line">;将ecx与3做位与运算，等同于ecx对4求余</span><br><span class="line">and ecx,3</span><br><span class="line">;和rep movsd指令功能奥似，不过是按单字节复制字符串</span><br><span class="line">repmovsb</span><br><span class="line">call_printf</span><br><span class="line">addesp,4</span><br><span class="line">pop edi</span><br><span class="line">popesi</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>​    数组作为函数得返回值与作为函数的参数差不多，都是将数组的首地址以指针的方式进行传递。不同点是当数组作为参数时，其定义所在的作用域必然在函数调用以外，在调用前已经存在，所以，在函数中对数组进行操作是没有问题的，而数组作为函数返回值则存在着一定的风险。</p><p>当数组为局部变量数据时，便产生了稳定性问题。当退出函数时，需要平衡栈，而数组是作为局部变量存在，其内存空间在当前函数的栈内。如果此时函数退出，栈中定义的数据将变得不稳定。由于函数退出后esp会回归到调用前的位置上，而函数内的局部数组在esp之下，随时都有可能由在其他函数的调用过程中产生的<strong>栈操作指令将其数据破坏</strong>。数据的破坏将导致函数返回结果具备不确定性，影响程序的结果，如图所示。</p><p><img src="P2.jpg" alt="栈平衡错误"></p><p>在图中，返回了函数GetNumber中定义的局部数组的首地址nArray,其所在地址处于0x0012FF00~0x0012FF1C之间。当函数调用结束后，栈顶指向了地址0x0012FF1C。此时数组nArray中的数据已经不稳定，任何栈操作都有可能将其破坏。</p><p>在执行“print(“%d”, pAray[7]);”后，由于需要将参数压栈，地址0x0012FF1C~0x0012FF18之间的数据已经被破坏，无法输出正常结果。</p><p>如果既想使用数组作为返回值，又要避免图中的错误，可以使用全局数组、静态数组或是上层调用函数中定义的局部数组。</p><p>well，全局数组就是很常见的那种，懒得放了，看一下静态数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">int nOne;</span><br><span class="line">int nTwo;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">static int g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">int nOne;</span><br><span class="line">int nTwo;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;nOne,&amp;nTwo);</span><br><span class="line">static in g_snArry[5] &#x3D; &#123;nOne,nTwo,0&#125;;</span><br><span class="line">0040B84Dxoredx,edx</span><br><span class="line">0040B84Fmovdl,byte ptr [&#39;main&#39; ::&#39;2&#39; :: $Sl (004237c8)]</span><br><span class="line">0040B855andedx,1</span><br><span class="line">0040B858testedx,edx</span><br><span class="line">0040B85Ajnemain+70h (0040b890);检测初始化标志位</span><br><span class="line">0040B85Cmoval, [&#39;main&#39; :: &#39;2&#39; :: $S1 (004237c8) ]</span><br><span class="line">0040B861oral,1</span><br><span class="line">;将初始化标志位置1</span><br><span class="line">0040B863mov[&#39;main&#39; : : &#39;2&#39;: :$S1 (004237c8)] ,al</span><br><span class="line">0040B868movecx, dword ptr [ebp-4]</span><br><span class="line">0040B86Bmovdword ptr [&#39;main&#39; :: &#39;2&#39;::$S1+4 (004237cc)] , ecx</span><br><span class="line">0040B871movedx, dword ptr [ebp-8]</span><br><span class="line">0040B874movdword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+8 (004237d0)] , edx</span><br><span class="line">0040B87Amovdword ptr [&#39;main&#39; :: &#39;2&#39; ::$S1+0Ch (004237d4)] , 0</span><br><span class="line">0040B884xoreax,eax</span><br><span class="line">0040B886mov[&#39;main&#39; :: &#39;2&#39; : : $S1+10h (004237d8)] ,eax</span><br><span class="line">0040B88Bmov[&#39;main&#39; :: &#39;2&#39; : : $S1+14h (004237dc)] , eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标寻址和指针寻址"><a href="#下标寻址和指针寻址" class="headerlink" title="下标寻址和指针寻址"></a>下标寻址和指针寻址</h2><p>下标访问(寻址): a[n]        <strong>效率高</strong></p><p>指针访问(寻址): *(a+n)</p><p>看一下区别，Debug版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：两种寻址方式演示</span><br><span class="line">void main()&#123;</span><br><span class="line">char *pChar &#x3D; NULL;</span><br><span class="line">char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">pChar &#x3D; szBuff;</span><br><span class="line">printf(&quot;%c&quot;,*pChar);</span><br><span class="line">printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main()&#123;</span><br><span class="line">char *pChar &#x3D; NULL;</span><br><span class="line">004010F8movdword ptr [ebp-4] ,0;初始化指针变量为空指针</span><br><span class="line">char szBuff[] &#x3D; &quot;Hello&quot;;</span><br><span class="line">004010FFmoveax, [string &quot;Hel1o&quot; (00420030)];初始化数组</span><br><span class="line">00401104movdword ptr [ebp-0Ch] , eax</span><br><span class="line">00401107movcx,word ptr [string &quot;He11o&quot;+4 (00420034)]</span><br><span class="line">0040110Emovword ptr [ebp-8] ,Cx</span><br><span class="line"></span><br><span class="line">pChar &#x3D; szBuff;</span><br><span class="line">00401112leaedx, [ebp-0Ch];荻取数组首地址，然后使用edx保存</span><br><span class="line">00401115movdword ptr [ebp-4] , edx</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,*pChar);</span><br><span class="line">00401118moveax, dword ptr [ebp-4] ;取出指针变量中保存的地址数据</span><br><span class="line">0040111Bmovsxecx,byte ptr [eax];字符型指针的间接访问</span><br><span class="line">0040111Epush ecx</span><br><span class="line">0040111Fpushoffset string &quot;%C&quot; (0042002c)</span><br><span class="line">00401124call printf(00401170)</span><br><span class="line">00401129add esp,8</span><br><span class="line"></span><br><span class="line">printf(&quot;%c&quot;,szBuff[0]);</span><br><span class="line">;直接从地址ebp-0Ch处取出1字节的数据</span><br><span class="line">0040112Cmovsxedx,byte ptr [ebp-0Ch]</span><br><span class="line">00401130pushedx;将取出数据作为参数</span><br><span class="line">00401131pushoffset string &quot;%c&quot; (0042002c)</span><br><span class="line">00401136callprintf(00401170)</span><br><span class="line">0040113Baddesp,8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针寻址比下标寻址多一次寻址操作，效率自然低，但是指针寻址可以修改地址中保存的数据，访问其他内存中的数据，而数组下标在没有越界使用的情况下只能访问数组内的数据。</p><p>下标值的三种表现方式</p><ol><li><p>下标值为整型常量的寻址</p><p>编译器可以直接计算出数据所在的地址</p></li><li><p>下标值为整型变量的寻址</p><p>编译器先进行地址偏移计算，然后得出目标数据所在的地址</p></li><li><p>下标值为整型表达式的寻址</p><p>会先计算出表达式的结果，然后将其结果作为下标值</p></li></ol><p>顺带一提，数组越界就是下标越范围，蛮好懂的</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组在内存中的存储方式和一维数组是一样的，但在<strong>寻址方面</strong>，二维数组的寻址过程比一维数组多一步操作，先取得二维数组中某个一维数组的首地址，再利用此地址作为基址寻址到一维数组中某个数据地址处。</p><p>若其中某一下标值为常量，则不会出现二次寻址计算，二维数组寻址转换成汇编后的代码和一维数组差不多，因为下标值为常量，且类型大小可预先计算出，因此变成两常量计算。利用常量折叠可直接计算出偏移地址。</p><p>来个release版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">004B1090 55                   push        ebp  </span><br><span class="line">004B1091 8B EC                mov         ebp,esp  </span><br><span class="line">004B1093 83 EC 2C             sub         esp,2Ch  </span><br><span class="line">004B1096 A1 04 30 4B 00       mov         eax,dword ptr ds:[004B3004h]  </span><br><span class="line">004B109B 33 C5                xor         eax,ebp  </span><br><span class="line">004B109D 89 45 FC             mov         dword ptr [ebp-4],eax  </span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">int j &#x3D; 0;</span><br><span class="line">int nArray[4] &#x3D; &#123; 1,2,3,4 &#125;;</span><br><span class="line">004B10A0 0F 28 05 40 21 4B 00 movaps      xmm0,xmmword ptr ds:[004B2140h]  </span><br><span class="line">int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10A7 8D 45 F4             lea         eax,[ebp-0Ch]  </span><br><span class="line">int nTwoArray[2][2] &#x3D; &#123; &#123;1,2&#125;,&#123;3,4&#125; &#125;;</span><br><span class="line">scanf_s(&quot;%d %d&quot;, &amp;i, &amp;j);</span><br><span class="line">004B10AA 50                   push        eax  </span><br><span class="line">004B10AB 8D 45 F8             lea         eax,[ebp-8]  </span><br><span class="line">004B10AE C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0  </span><br><span class="line">004B10B5 50                   push        eax  </span><br><span class="line">004B10B6 68 08 21 4B 00       push        4B2108h  </span><br><span class="line">004B10BB C7 45 F4 00 00 00 00 mov         dword ptr [ebp-0Ch],0  </span><br><span class="line">004B10C2 0F 11 45 E4          movups      xmmword ptr [ebp-1Ch],xmm0  </span><br><span class="line">004B10C6 0F 11 45 D4          movups      xmmword ptr [ebp-2Ch],xmm0  </span><br><span class="line">004B10CA E8 81 FF FF FF       call        004B1050  </span><br><span class="line">printf(&quot;nArray &#x3D; %d\r\n&quot;, nArray[i]);</span><br><span class="line">004B10CF 8B 45 F8             mov         eax,dword ptr [ebp-8]  </span><br><span class="line">004B10D2 FF 74 85 E4          push        dword ptr [ebp+eax*4-1Ch]  </span><br><span class="line">004B10D6 68 10 21 4B 00       push        4B2110h  </span><br><span class="line">004B10DB E8 40 FF FF FF       call        004B1020  </span><br><span class="line">printf(&quot;nTwoArray &#x3D; %d\r\n&quot;, nTwoArray[i][j]);</span><br><span class="line">004B10E0 8B 4D F8             mov         ecx,dword ptr [ebp-8]  </span><br><span class="line">004B10E3 8B 45 F4             mov         eax,dword ptr [ebp-0Ch]  </span><br><span class="line">004B10E6 8D 04 48             lea         eax,[eax+ecx*2]  </span><br><span class="line">004B10E9 FF 74 85 D4          push        dword ptr [ebp+eax*4-2Ch]  </span><br><span class="line">004B10ED 68 20 21 4B 00       push        4B2120h  </span><br><span class="line">004B10F2 E8 29 FF FF FF       call        004B1020  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个”eax+ecx*2”保存了二维数组的两个下标值：i、j。寻址过程如下：</p><p>1)使用数组首地址加二维数组下标i乘以-维数组大小，得到一维数组首地址。<br>2)通过1)获取一维数组首地址后，加下标j乘以类型大小，得到的数据如下:<br>二维数组type nArry[M][N];使用i、j作为下标寻址<br>nArray + i * sizeof(type [N]) + j * sizeof(type)<br>= nArray+i* N * sizeof(type) +j * sizeof(type)<br>= nArray + sizeof(type)*(i *N +j)</p><p>三维数组类似，不列举了</p><h2 id="存放指针类型数据的数组"><a href="#存放指针类型数据的数组" class="headerlink" title="存放指针类型数据的数组"></a>存放指针类型数据的数组</h2><p><strong>存放指针类型的数据的数组</strong>就是数组中各数据元素都是由相同类型指针组成。</p><table><thead><tr><th align="center">组成部分1</th><th align="center">组成部分2</th><th align="center">组成部分3</th></tr></thead><tbody><tr><td align="center">类型名*</td><td align="center">数组名称</td><td align="center">[元素个数]</td></tr></tbody></table><p>举个栗子，存储三个字符串”Hello”,”World”,”!\r\n”，指针数组是一维的，存储的是字符串的首地址，字符数组是二维的，将每个字符存储进去</p><p>这样寻址的时候，会发生差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">printf(pBuff[1]);</span><br><span class="line">01001958 B8 04 00 00 00       mov         eax,4  </span><br><span class="line">0100195D C1 E0 00             shl         eax,0  </span><br><span class="line">01001960 8B 4C 05 EC          mov         ecx,dword ptr [ebp+eax-14h]  ;一维数组寻址</span><br><span class="line">01001964 51                   push        ecx  </span><br><span class="line">01001965 E8 DC F6 FF FF       call        01001046  </span><br><span class="line">0100196A 83 C4 04             add         esp,4  </span><br><span class="line">printf(cArray[1]);</span><br><span class="line">0100196D B8 0A 00 00 00       mov         eax,0Ah  </span><br><span class="line">01001972 C1 E0 00             shl         eax,0  </span><br><span class="line">01001975 8D 4C 05 C4          lea         ecx,[ebp+eax-3Ch]  </span><br><span class="line">01001979 51                   push        ecx  </span><br><span class="line">0100197A E8 C7 F6 FF FF       call        01001046  </span><br><span class="line">0100197F 83 C4 04             add         esp,4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符数组寻址后得到的是某一维数组的首地址</p><h2 id="指向数组的指针变量"><a href="#指向数组的指针变量" class="headerlink" title="指向数组的指针变量"></a>指向数组的指针变量</h2><p>当指针变量保存的数据为数组的首地址，且将此地址解释为数组时，此指针变量被称为数组指针。</p><p>指向一维数组的数组指针定义格式：</p><table><thead><tr><th align="center">组成部分1</th><th align="center">组成部分2</th><th align="center">组成部分3</th></tr></thead><tbody><tr><td align="center">[类型名]</td><td align="center">[*指针变量名称]</td><td align="center">[一维数组大小]</td></tr></tbody></table><p>对指向二维数组的数组指针执行取内容操作后，得到的还是一个地址值，再次执行取内容操作才能寻址到二维字符数组中的单个字符数据。看上去与二级指针相似，实际上并不一样。二级指针的类型为指针类型，其偏移长度在32位下固定为4字节，而数组指针的类型为数组，其偏移长度随数组而定，两者的偏移计算不同，不可混为一谈。</p><p>main函数的三个参数(main(int argc,char *argv[],char *envp[]))分别为：</p><ol><li>argc:命令行参数个数，整型。</li><li>argv:命令行信息，保存字符串数组首地址的指针变量，是一个指向数组的指针。</li><li>envp:环境变量信息，和argv类型相同。</li></ol><p>来个main函数参数的demo看一看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">void main(int argc, char **argv, char **envp &#125; &#123;</span><br><span class="line">for(inti&#x3D;1;i&lt;argc;i++)&#123;</span><br><span class="line">printf (argv[i]) ;</span><br><span class="line">00401112movedx, dword ptr [ebp-4] ;取下标值i并将其保存到edx中</span><br><span class="line">;对指针变量取内容，得到数组首地址</span><br><span class="line">00401115moveax, dword ptr [ebp+0Ch]</span><br><span class="line">;一维数组寻址，将得到的数组数据保存到ecx中</span><br><span class="line">00401118movecx, dword ptr [eax+edx*4]</span><br><span class="line">0040111Bpushecx</span><br><span class="line">0040111Ccallprintf(00401160)</span><br><span class="line">00401121addesp,4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>argv是一个参数，保存着字符串数组的首地址，因此需要”mov eax,dword ptr[ebp+0Ch]”指令队其取内容，得到数组首地址。</p><p>对三维数组 int nArray[2] [3] [4] 可转换成int (*pnArray) [3] [4] = nArray;</p><p>指针在地址偏移过程中需要计算出偏移量，因此需要所指向的数据类型来配合计算偏移长度。在多维数组中，可以将最高维看做是- -维 数组，其后数据为这个- -维 数组中各元素的数据类型。所以第一个维数可以省去。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>用于保存函数首地址的指针变量被称为函数指针。函数指针是不允许执行加法和减法运算的</p><p>来两份代码看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">函数指针与函数——Debug版</span><br><span class="line">void __cdecl Show()&#123;</span><br><span class="line">printf(&quot;Show\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">void (__cdecl *pShow)(void) &#x3D; Show&#x2F;&#x2F;函数指针赋值</span><br><span class="line">pShow();&#x2F;&#x2F;使用函数指针调用函数</span><br><span class="line">Show();&#x2F;&#x2F;直接调用函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123;</span><br><span class="line">void (__cdecl *pShow) (void) &#x3D; Show;</span><br><span class="line">;函数名称即为函数首地址，这是一个常量地址值</span><br><span class="line">0040B90Bmovdword ptr [ebp-38h] , offset @ILT+15 (Show) (00401014)</span><br><span class="line">0040B915movedx, dword ptr [ebp-38h]</span><br><span class="line">0040B918movdword ptr [ebp-38h] , edx</span><br><span class="line">pShow();</span><br><span class="line">0040B91Bmovesi,esp</span><br><span class="line">0040B91Dcall dword ptr [ebp-38h];间接调用函数</span><br><span class="line">0040B920cmpesi,esp;栈平衡检查，Debug下特有</span><br><span class="line">0040B922call__chkesp (004012d0);栈平衡检查，Debug下特有</span><br><span class="line">Show();</span><br><span class="line">0040B927 call@ILT+15 (Show) (00401014);直接调用函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">带参数和返回值的函数指针——Debug版</span><br><span class="line">&#x2F;&#x2F;C++源码说明:带参数与返回类型的函数指针</span><br><span class="line">int_stdcall Show(int nShow)&#123;</span><br><span class="line">printf(&quot;Show : %d\r\n&quot;,nShow);</span><br><span class="line">return nShow;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">int (__stdcall *pShow)(int) &#x3D; Show;&#x2F;&#x2F;函数指针定义并初始化</span><br><span class="line">int nRet &#x3D; pShow(5);&#x2F;&#x2F;使用函数指针调用函数，并获取返回值</span><br><span class="line">printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++ 源码与对应汇编代码讲解</span><br><span class="line">void main() &#123; </span><br><span class="line">int (__stdcall *pShow) (int) &#x3D; Show;</span><br><span class="line">;初始化过程没有变化，仍然为荻取函数首地址并保存</span><br><span class="line">00408868movdword ptr [ebp-4] ,offset @ILT+20 (Show) (00401019)</span><br><span class="line">0040886Fmoveax, dword ptr [ebp-4]</span><br><span class="line">00408872movdword ptr [ebp-4] ,eax</span><br><span class="line">int nRet &#x3D; pShow(5);</span><br><span class="line">00408875movesi,esp;保存进入函数前的栈顶，用于栈顶检查</span><br><span class="line">00408877push5;压入参数5</span><br><span class="line">00408879calldword ptr [ebp-4];获取函数指针中的地址，间接调用函数</span><br><span class="line">0040887Ccmpesi,esp;栈顶检查</span><br><span class="line">00408883movdword ptr [ebp-8],eax;接收函数返回值数据</span><br><span class="line">printf(&quot;ret &#x3D; %d \r\n&quot;,nRet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><p>在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别:结构体的访问控制默认为public，而类的默认访问控制是private。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>一般来说，类对象的计算公式如下：</p><p><strong>对象长度 = sizeof(数据成员1) + sizeof(数据成员2) + sizeof(数据成员3) + … + sizeof(数据成员n)</strong></p><p>但是会出现以下例外：</p><ol><li><strong>空类</strong>。空类中没有任何数据成员，按照该公式计算得出的对象长度为0字节。类型长度为0，则此类的对象不占据内存空间。而实际情况是，空类的长度为1字节。如果对象完全不占用内存空间，那么空类就无法取得实例对象的地址，this 指针失效，因此不能被实例化。而类的定义是由成员数据和成员函数组成，在没有成员数据的情况下，还可以有成员函数，因此仍然需要实例化，分配了1字节的空间用于类的实例化，这1字节的数据并没有被使用。</li><li><strong>静态数据成员</strong>。当类中的数据成员被修饰为静态时，对象的长度计算又会发生变化。虽然静态数据成员在类中被定义，但它与静态局部变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见，同类对象将共同享有静态数据成员的空间。</li><li><strong>内存对齐</strong>。在VC++6.0中，类和结构体中的数据成员是根据它们在类或结构体中出现的顺序来依次申请内存空间的，由于内存对齐的原因，它们并不- -定会像数组那样连续地排列。由于数据类型不同，因此占用的内存空间大小也会不同，在申请内存时，会遵守一定的规则。</li></ol><p>重点讲一下第三种：</p><p>在为结构体和类中的数据成员分配内存时，结构体中的当前数据成员类型长度为M，指定的对齐值为N，那么实际对齐值为q = min(M, N)，其成员的地址安排在q的倍数上。如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct tagTEST&#123;</span><br><span class="line">short sShort;</span><br><span class="line">int nInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据成员sShort 的地址为<strong>0x0012FF74</strong>，类型为short,<strong>占2字节</strong>内存空间。VC++ 6.0指定的对齐值默认为8，short 的长度为2，于是实际的对齐值取较小者2。所以，short 被分配在地址0x0012FF74处，此地址是2的倍数，可分配。此时，轮到为第二个数据成员分配内存了，如果分配在sShort后，应在地址0x0012FF76处，但第二个数据成员为int类型，<strong>占4字节</strong>内存空间，与指定的对齐值比较后，实际对齐值取int类型的长度4，而地址0x0012FF76不是4的倍数，<strong>需要插入两个字节填充，以满足对齐条件</strong>，因此第二个数据成员被定义在地址<strong>0x0012FF78</strong>处。</p><p>上例讲到了结构体成员对齐值的问题，现在讨论一下对齐值对结构体整体大小的影响。如果按VC++ 6.0默认的8字节对齐，那么结构体的整体大小要能被8整除，如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sruct&#123;</span><br><span class="line">double dDouble;&#x2F;&#x2F;所在地址: 0x0012FF00~0x0012FF08之间，占8字节</span><br><span class="line">int nInt;&#x2F;&#x2F;所在地址: 0x0012FF08~0x0012FF0C之间，占4字节</span><br><span class="line">short sShort;&#x2F;&#x2F;所在地址: 0x0012FF0C-0x0012FF10之间，占2字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中结构体成员的总长度为8+4+2=14，按默认的对齐值设置要求，结构体的整体大小<strong>要能被8整除</strong>，于是编译器在最后一个成员sShort所占内存之后<strong>加入2字节空间填补</strong>到整个结构体中，使总大小为8+4+2+2=16,这样就满足了对齐的要求。</p><p>但是，并非设定了默认对齐值就将结构体的对齐值锁定。如果结构体中的数据成员类型，最大值为M，指定的对齐值为N,那么实际对齐值为min(M, N),如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Struct&#123;</span><br><span class="line">char cChar;&#x2F;&#x2F;应占1字节内存空间，如所在地址为0x0012FF00</span><br><span class="line">int nInt;&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">short sShort;&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上结构应该按照4字节的方式对齐，其布局格式如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cChar所在地址; 0x0012FF00~0x0012FF04之间，占4字节，对齐nInt</span><br><span class="line">nInt所在地址: 0x0012FF04~0x0012FF08之间，占4字节</span><br><span class="line">sShort所在地址: 0x0012FF08~0x0012FF0C之间，占2字节，另外填充2字节</span><br></pre></td></tr></table></figure><p>既然有默认的对齐值，就可以在定义结构体时进行调整，VC++ 6.0中可使用预编译指令#pragma pack(N)来调整对齐大小。修改以上示例，调整对齐值为1，如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line">Struct&#123;</span><br><span class="line">char cChar;&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">int nInt;&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">short sShort;&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    调整对齐值后，根据对齐规则，在分配nInt时无需插入空白数据。对齐值为1, nInt 占4字节大小，很明显，使用pack设定的对齐值更小，因此采用对齐值1的倍数来计算分配内存空间的首地址，nInt 只需紧靠在cChar之后即可。这样cChar只占用1字节内存空间。由于设定的对齐值小于等于结构体中所有数据成员的类型长度，因此结构总长度只要是1的倍数即可。在这个例子中，结构总长度为7。</p><p>​    使用pack修改对齐值也<strong>并非一定会生效</strong>， 与默认对齐值一样，都需要参考结构体中的数据成员类型。<strong>当设定的对齐值大于结构体中的数据成员类型大小时，此对齐值同样是无效的</strong>。</p><p>当结构体中以数组作为成员时，<strong>将根据数组元素的长度计算对齐值，而不是按数组的整体大小去计算</strong>，如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">char cChar;&#x2F;&#x2F;应占1字节内存空间， 如所在地址为0x0012FF00</span><br><span class="line">char cArray[4];&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">short sShort;&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    按照对齐规定，cChar 与cArray的对齐没有缝隙，无需插入空白数据，当cArray与sShort进行对齐时，cChar 与cArray在内存中将会占5字节，此时按照结构中当前的数据类型short进行对齐，插入1字节的数据即可，其结构布局如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cChar所在地址: 0x0012FF00~0x0012FF01之间，占1字节</span><br><span class="line">cArray[4]所在地址: 0x0012FF01-0x0012FF06之间，占5字节</span><br><span class="line">sShort所在地址: 0x0012FF06-0x0012FF08之间，占2字节</span><br></pre></td></tr></table></figure><p>​    当结构体中出现结构体类型的数据成员时，不会将嵌套的结构体类型的整体长度参与到对齐值计算中，而是以嵌套定义的结构体所使用的对齐值进行对齐，如以下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct tagOne&#123;</span><br><span class="line">char cChar;&#x2F;&#x2F;应占1字节内存空间</span><br><span class="line">char cArray[4];&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">short sShort;&#x2F;&#x2F;应占2字节内存空间</span><br><span class="line">&#125;;</span><br><span class="line">struct tagTwo&#123;</span><br><span class="line">int nInt;&#x2F;&#x2F;应占4字节内存空间</span><br><span class="line">tagOne one;&#x2F;&#x2F;应占8字节内存空间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    在以上结构中，虽然tagOne结构占8字节大小，但由于其对齐值为2,因此tagTwo结构体中的最大类型便是int,以4作为对齐值。所以，结构tagTwo的总大小并非以8字节对齐的16字节，而是以4字节对齐的12字节。</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>指针访问结构体或类成员的公式：</p><p>假设type为某个正确定义的结构体或者类，member是type中可以访问的成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type *p</span><br><span class="line">&#x2F;&#x2F;此处略去p的赋值</span><br><span class="line">&#x2F;&#x2F;以下是整型加法</span><br><span class="line">p-&gt;member的地址 &#x3D; 指针p的地址值 + member在type中的偏移量</span><br></pre></td></tr></table></figure><p>举个栗子~如果有以下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">int m_int;&#x2F;&#x2F;在结构体内的偏移量为0 </span><br><span class="line">float m_float;&#x2F;&#x2F;在结构体内的偏移量为4</span><br><span class="line">&#125;;</span><br><span class="line">struct A a;&#x2F;&#x2F;假设这个结构体变量a的地址为0x0012ff00</span><br><span class="line">struct A *pA &#x3D; &amp;a;&#x2F;&#x2F;定义结构体指针，并赋初值</span><br><span class="line">printf(&quot;%p&quot;,&amp;pA-&gt;m_float);&#x2F;&#x2F;结果</span><br></pre></td></tr></table></figure><p>那么pA-&gt;m_float的地址=0x0012ff00 + 4 = 0x0012ff04</p><p>ok~，来看一份Debug版的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：类定义以及数据成员的访问</span><br><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">void SetNumber(int nNumber)&#123;&#x2F;&#x2F;公有函数成员</span><br><span class="line">m_nInt &#x3D; nNumber;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_nInt;&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">CTest Test;</span><br><span class="line">Test.SetNumber(5);&#x2F;&#x2F;调用成员函数</span><br><span class="line">printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CTest Test;</span><br><span class="line">Test.SetNumber(5);&#x2F;&#x2F;类对象定义</span><br><span class="line">0040B768 push5;压入参数5</span><br><span class="line">0040B76Aleaecx, [ebp-4];取出对象Test的首地址存入ecx中</span><br><span class="line">;调用成员函数</span><br><span class="line"></span><br><span class="line">0040B76Dcall@ILT+10 (CTest::SetNumber) (0040100f)</span><br><span class="line">printf (&quot;CTest : %d\r\n&quot;, Test.m_nInt);</span><br><span class="line">;取出对象首地址处4字节的数据m_nInt存入eax中</span><br><span class="line">0040B772moveax, dword ptr [ebp-4]</span><br><span class="line">0040B775pusheax;将eax中保存的数据成员m_ nInt向成员函数传参</span><br><span class="line">0040B776pushoffset string &quot;CTest : d\r\n&quot; (0042001c)</span><br><span class="line">0040B77Bcallprintf(00401060)</span><br><span class="line">0040B780addesp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SetNumber函数讲解</span><br><span class="line">void SetNumber(int nNumber)&#123;&#x2F;&#x2F; SetNumber成员函数实现</span><br><span class="line">0040B7B0pushebp</span><br><span class="line">0040B7B1movebp,esp</span><br><span class="line">0040B7B3subesp,44h</span><br><span class="line">0040B7B6pushebx</span><br><span class="line">0040B7B7pushesi</span><br><span class="line">0040B7B8pushedi</span><br><span class="line">0040B7B9pushecx;注意，ecx中保存了对象Test的首地址</span><br><span class="line">0040B7BAleaedi,[ebp-44h]</span><br><span class="line">0040B7BDmovecx,11h</span><br><span class="line">0040B7C2moveax,0CCCCCCCCh</span><br><span class="line">0040B7C7rep stos dword ptr [edi]</span><br><span class="line">0040B7C9pop ecx;还原ecx</span><br><span class="line">;将ecx中的数据存入ebp-4地址处，该地址处保存着调用对象的首地址，即this指针</span><br><span class="line">0040B7CAmovdword ptr [ebp-4],ecx</span><br><span class="line">m_nInt &#x3D; nNumber;</span><br><span class="line">;取出对象的首地址并存入eax</span><br><span class="line">0040B7CDmoveax, dword ptr [ebp-4]</span><br><span class="line">;取出参数中的数据并保存到ecx中</span><br><span class="line">0040B7D0movecx, dword ptr [ebp+8]</span><br><span class="line">;这里是给成员m_ nInt賦值。由于eax是对象的首地址，成员m_ nInt的偏移量为0,如果写成这样可能更容易理解: mov dword ptr [eax+0] ,ecx</span><br><span class="line">0040B7D3movdword ptr [eax] , ecx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用默认的调用约定时，在调用成员函数的过程中，编译器做了一个“小动作”:利用寄存器ecx保存了对象的首地址，并以寄存器传参的方式传递到成员函数中，这便是this指针的由来。这样的默认调用约定称为thiscall。</p><p>在VC++的环境下，识别this指针的关键点是在函数的调用过程中使用了ecx作为第一个参数，并且在ecx中保存的数据为对象的首地址，但并非所有的this指针的传递都是如此。thiscall的栈平衡方式与__stdcall相同，都是由被调用方负责平衡。但是，两者在传参的过程中却不一样，声明为thiscall的函数，第一个参数使用寄存器ecx传递，而非通过栈顶传递。而且thiscall并不属于关键字，它是C++中成员函数特有的调用方式，在C语言中是没有这种调用方式的。因此函数无法显式声明为thiscall调用方式，而类的成员函数默认是thiscall调用方式。所以，在分析过程中，如果看到某函数使用ecx传参，且ecx中保留了对象的this指针，以及在函数实现代码内，存在this指针参与的寄存器相对间接访问方式，如[reg+8]，即可怀疑此函数为成员函数。</p><p>当使用其他调用方式(如stdcall) 时，this 指针将不再使用ecx传递，而是改用栈传递，举个栗子~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：数组和局部变量的定义以及初始化</span><br><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">void __stcall SetNumber(int nNumber)&#123;&#x2F;&#x2F;公有函数成员</span><br><span class="line">m_nInt &#x3D; nNumber;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_nInt;&#x2F;&#x2F;公有数据成员</span><br><span class="line">&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">CTest Test;</span><br><span class="line">Test.SetNumber(5);&#x2F;&#x2F;调用__stdcall成员函数</span><br><span class="line">printf(&quot;CTest : %d\r\n&quot;,Test.m_Int);&#x2F;&#x2F;获取数据成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数调用过程</span><br><span class="line">Test.SetNumber(5) ;</span><br><span class="line">0040B808push5</span><br><span class="line">0040B80Aleaeax,[ebp-8];荻取对象首地址并存入eax中</span><br><span class="line">0040B80Dpusheax;将eax作为参数压栈</span><br><span class="line">0040B80Ecall@ILT+15 (CTest::SetNumber) (00401014)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数SetNumber的实现过程</span><br><span class="line">void __stdcall SetNumber (int nNumber) &#123;</span><br><span class="line">;Debug 初始化过程略</span><br><span class="line">m_nInt &#x3D;  nNumber;</span><br><span class="line">0040B7C8moveax, dword ptr [ebp+8] ;取出this指针并存入eax中</span><br><span class="line">0040B7CBmovecx, dword ptr [ebp+0Ch];取出参数nNumber并存入ecx中</span><br><span class="line">0040B7CEmovdword ptr [eax] , ecx;使用eax取出成员并赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种 __ cdecl 调用方式和 __gstdcall 调用方式只是在参数平衡时有所区别，this指针不容易识别。</p><p>使用thiscall调用放式的成员函数的要点分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leaecx,[mem];取对象首地址并存入ecx中，要注意观察内存</span><br><span class="line">callFUN_ADDRESS;调用成员函数</span><br><span class="line">;在函数调用内，ecx尚未重新赋值之前</span><br><span class="line">movXXX,ecx;发现函数内使用ecx中的数据，说明函数调用前对ecx的赋值</span><br><span class="line">;实际上是在传递参数</span><br><span class="line">;其后ecx中的内容会传递给其他寄存器</span><br><span class="line">mov[reg+i],XXX ;发现了寄存器相对间接寻址方式，如果能排除数组访问，那就能说明reg中保存的是结构体或者类对象的首地址</span><br></pre></td></tr></table></figure><p>符合以上特点，基本可判定这是调用类的成员函数。通过分析函数代码中访问ecx的方式，并结合内存窗口，以ecx中的值为地址去观察其数据，可以进一-步分析并还原出对象中的各数据成员。</p><p>__ stdcall与 __cdecl调用方式的成员函数分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leareg,[mem];取出对象首地址并存入寄存器变量中</span><br><span class="line">pushreg;将保存对象首地址的寄存器作为参数压栈</span><br><span class="line">callFUN_ADDRESS;调用成员函数</span><br><span class="line">;在函数调用内，将第一个函数参数作为指针变量，以寄存器相对间接寻址方式访问</span><br></pre></td></tr></table></figure><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>当类中定义了静态数据成员时，由于静态数据成员和静态变量原理相同(是一个含有作用域的特殊全局变量)，因此该静态数据成员的初值会被<strong>写入编译链接后的执行文件</strong>中。当程序被加载时，操作系统将执行文件中的数据读到对应的内存单元里，静态数据成员便已经存在，而这时类并没有实例对象。所以静态数据成员和对象之间的生命周期不同，并且静态数据成员也不属于某一对象，与对象之间是一对多的关系。静态数据成员仅仅和类相关，和对象无关，多个对象可以共同拥有同一个静态数据成员。</p><p>两个对象各自的成员数据在内存中的地址不同，而<strong>静态数据成员的地址却相同</strong>。如图</p><p><img src="P3.jpg" alt="普通数据成员和静态数据成员"></p><p><strong>在计算类和对象的长度时，静态数据成员不被计算在内。</strong></p><p>普通数据成员的地址是一个栈空间地址，而<strong>静态数据成员的是一个常量地址，可通过立即数间接寻址的方式访问</strong>。访问时无需this指针。</p><h2 id="对象作为函数参数"><a href="#对象作为函数参数" class="headerlink" title="对象作为函数参数"></a>对象作为函数参数</h2><p>对象作为函数的参数时，其传参过程与数组不同:数组变量的名称代表数组的首地址，而对象的变量名称却不能代表对象的首地址。传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份(复制),将复制的数据作为形参传递到调用函数中使用。</p><p>来个栗子~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：参数为对象的函数调用</span><br><span class="line">class CFunTest&#123;</span><br><span class="line">public:</span><br><span class="line">int m_nOne;</span><br><span class="line">int m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">printf(&quot;%d %d\r\n&quot;,FunTest.m_nOne,FunTest.m_nTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;注意，这里没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">00401098movdword ptr [ebp-8],1;数据成员m_nOne所在地址为ebp-8</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040109Fmovdword ptr [ebp-4],2;数据成员m_nTwo所在地址ebp-4</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">004010A6moveax, dword ptr [ebp-4]</span><br><span class="line">004010A9pusheax;传入数据成员m_nTwo</span><br><span class="line">004010AAmovecx, dword ptr [ebp-8] </span><br><span class="line">004010ADpushecx;传入数据成员m_ nOne</span><br><span class="line">004010AEcall@ILT+10 (ShowFunTest) 0040100f)</span><br><span class="line">004010B3addesp,8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShowFunTest (CFunTest FunTest) &#123;</span><br><span class="line">printf (&quot;%d %d\r\n&quot; , FunTest.m_nOne, FunTest.m_nTwo);</span><br><span class="line">;取出数据成员m_nTwo作为printf函数的第三个参数</span><br><span class="line">00401038moveax, dword ptr [ebp+ 0Ch]</span><br><span class="line">0040103B pusheax</span><br><span class="line">;取出数据成员m_nOne作为printf函数的第二个参数</span><br><span class="line">0040103Cmovecx, dword ptr [ebp+8]</span><br><span class="line">0040103Fpushecx</span><br><span class="line">00401040pushoffset string &quot;%d %d\r\n&quot; (0042001c)</span><br><span class="line">00401045callprintf(00401120)</span><br><span class="line">0040104Aaddesp,0Ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的体积不大，只有两个数据成员，编译器在调用函数传参的过程中分别将对象的两个成员荡产两个int类型数据依次压栈，类对象中的数据成员的传参顺序为:最先定义的数据成员最后压栈，最后定义的数据成员最先压栈。</p><p>来看看数组当参数的情况~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码说明;此代码为修改版，添加了数组成员char m_szName [32]</span><br><span class="line">class CFunTest &#123;</span><br><span class="line">public:</span><br><span class="line">int m_nOne;</span><br><span class="line">int m_nTwo;</span><br><span class="line">char m_szName[32];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">&#x2F;&#x2F;显示对象中各数据成员的信息</span><br><span class="line">printf (&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">strcpy(FunTest.m_szName, &quot;Name&quot;);&#x2F;&#x2F;赋值数据成员数组</span><br><span class="line">ShowFunTest(FunTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">void ShowFunTest(CFunTest FunTest)&#123;</span><br><span class="line">;初始化部分略</span><br><span class="line">printf(&quot;%d %d %s\r\n&quot;, FunTest.m_nOne, FunTest.m_nTwo, FunTest.m_szName);</span><br><span class="line">00401038leaeax,[ebp+10h];取成员m_szName的地址</span><br><span class="line">0040103Bpusheax;将成员m_ szName的地址作为参数压栈</span><br><span class="line">0040103Cmovecx,dword ptr [ebp+0Ch];取成员m_nTwo中的数据</span><br><span class="line">0040103Fpushecx</span><br><span class="line">00401040movedx, dword ptr [ebp+8] ;取成员m_nOne中的数据</span><br><span class="line">00401043pushedx</span><br><span class="line">00401044pushoffset string &quot;%d%d%s\r\n&quot; (0042002c)</span><br><span class="line">00401049callprintf (00401120)</span><br><span class="line">0040104Eaddesp,10h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++源码对照，main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CFunTest FunTest;</span><br><span class="line">;没有任何调用默认构造函数的汇编代码</span><br><span class="line">FunTest.m_nOne &#x3D; 1;</span><br><span class="line">0040B7E8movdword ptr [ebp-28h],1 ;数据成员m_nOne所在地址为ebp-28h</span><br><span class="line">FunTest.m_nTwo &#x3D; 2;</span><br><span class="line">0040B7EFmovdword ptr [ebp-24h],2 ;数据成员m_nTwo所在地址为ebp-24h</span><br><span class="line">strcpy (FunTest.m_szName, &quot;Name&quot;);</span><br><span class="line">0040B7F1pushoffset string &quot;Name&quot; (0041302c)</span><br><span class="line">0040B7F6leaeax,[ebp-20h];数组成员m_szName所在地址为ebp-20h</span><br><span class="line">0040B7FEpusheax</span><br><span class="line">0040B7FFcallstrcpy(00404650)</span><br><span class="line">ShowFunTest (FunTest);</span><br><span class="line">0040B804addesp,0FFFFFFEOh;调整栈顶，抬高32字节</span><br><span class="line">0040B807movecx,0Ah;设置循环次数为10</span><br><span class="line">0040B80Cleaesi,[ebp-28h];获取对象的首地址并保存到esi中</span><br><span class="line">0040B80Fmovedi,esp;设置edi为当前栈顶</span><br><span class="line">;执行10次4字节内存复制，将esi所指向的数据复制到edi中，类似memcpy的内联方式</span><br><span class="line">0040B811rep movs dword ptr [edi],dword ptr [esi]</span><br><span class="line">0040B813call@ILT+10 (ShowFunTest) (0040100f)</span><br><span class="line">0040B818addesp,28h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码清单9-6中，在传递类对象的过程中使用了“add esp, 0FFFFFFE0h”来调整栈顶指针esp，0FFFFFEOh 是补码，转换后为-20h,等同于esp-20h。前面讲过，参数变量在传递时，需要向低地址调整栈顶指针esp,此处申请的32字节栈空间，<strong>加上strcpy未平衡的8字节参数空间，都用于存放参数对象FunTest的数据。将对象FunTest中的数据依次复制到申请的栈空间中。</strong></p><p>上面两份代码定义的类都没有定义构造函数和析构函数。由于对象作为参数在传递过程中会制作一份对象的复制数据，当向对象分配内存时，如果有构造函数，编译器会再调用一次构造函数，并做一些初始化工作。当代码执行到作用域结束时，局部对象将被销毁，而对象中可能会涉及资源释放的问题，同样，编译器也会再调用一次局部对象的析构函数，从而完成资源数据的释放。</p><p>当对象作为函数的参数时，由于重新复制了对象，等同于又定义了一个对象，在某些情况下会调用特殊的构造函数——<strong>拷贝构造函数</strong>。当函数退出时，复制的对象作为函数内的局部变量，将被销毁。当析构函数存在时，则会调用析构函数，这时候会出现问题，来个栗子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：涉及资源申请与释放的类的对象</span><br><span class="line">class CMString&#123;</span><br><span class="line">public:</span><br><span class="line">CMString()&#123;</span><br><span class="line">m_pString &#x3D; new char[10];&#x2F;&#x2F;申请堆空间，只要不释放，进程退出前将一直存在</span><br><span class="line">if(m_pString &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">strcpy(m_pString,&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">~CMString()&#123;</span><br><span class="line">if(m_pString !&#x3D; NULL)&#123;&#x2F;&#x2F;检查资源</span><br><span class="line">delete m_pString;&#x2F;&#x2F;释放空间</span><br><span class="line">m_pString &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">char *GetString()&#123;</span><br><span class="line">return m_pString;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">char *m_pString;&#x2F;&#x2F;数据成员定义，保存堆的首地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数CMString类对象的函数</span><br><span class="line">void ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">printf (MyStringCpy.GetString());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;main函数实现</span><br><span class="line">void main()&#123;</span><br><span class="line">CMyString MyString;&#x2F;&#x2F;类对象定义</span><br><span class="line">ShowMyString (MyString);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">&#x2F;&#x2F;C++源码对照，main函数分析</span><br><span class="line">void main()&#123;</span><br><span class="line">CMyString MyString;</span><br><span class="line">;获取对象的首地址，放入ecx中作为this指针</span><br><span class="line">0040121Dleaecx, [ebp- 10h]</span><br><span class="line">;调用构造函数</span><br><span class="line">00401220call@ILT+5 (CMyString::CMyString) (0040100a)</span><br><span class="line">;记录同一作用域内该类的对象个数</span><br><span class="line">00401225movdword ptr [ebp-4],0</span><br><span class="line">ShowMyString (Mystring);</span><br><span class="line">;MyString对象长度为4，一个寄存器单元刚好能存放</span><br><span class="line">;于是eax获取对象首地址处4字节的数据，即数据成员m_pString</span><br><span class="line">0040122Cmoveax,dword ptr [ebp-10h]</span><br><span class="line">0040122Fpusheax</span><br><span class="line">00401230call@ILT+15 (ShowMyString) (00401014)</span><br><span class="line">00401235addesp,4</span><br><span class="line">&#125;&#x2F;&#x2F; main函数结束处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">00401238movdword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;获取对象首地址，传入ecx作为this指针</span><br><span class="line">0040123Fleaecx, [ebp-10h]</span><br><span class="line">;调用析构函数</span><br><span class="line">00401242call@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111E    ret</span><br><span class="line">&#x2F;&#x2F;构造函数与析构函数讲解略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ShowMyString函数的实现过程分析</span><br><span class="line">vold ShowMyString (CMyString MyStringCpy) &#123;</span><br><span class="line">004010B0pushebp</span><br><span class="line">004010B1movebp,esp</span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;异常链处理过程&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">004010B3push0FFh</span><br><span class="line">004010B5pushoffset __ehhandler$?ShowMyString@@YAXVCMyString@@@Z (00410d39)</span><br><span class="line">004010BAmoveax,fs:[00000000]</span><br><span class="line">004010C0pusheax</span><br><span class="line">004010C1movdword ptr fs:[0],esp</span><br><span class="line">004010C8subesp,40h</span><br><span class="line">004010CBpushebx</span><br><span class="line">004010CCpushesi</span><br><span class="line">004010CDpushedi</span><br><span class="line">004010CEleaedi,[ebp-4Ch]</span><br><span class="line">004010D1movecx,10h</span><br><span class="line">004010D6moveax,0CCCCCCCCh</span><br><span class="line">004010DBrep stosdword ptr [edi]</span><br><span class="line">004010DDmovdword ptr [ebp-4],0 ;作用域内的对象个数</span><br><span class="line">printf(MyStringCpy.GetString());</span><br><span class="line">;取参数1的数据成员m_pString的地址(即对象酋地址)并保存到ecx中作为this指针</span><br><span class="line">;注意，此m_pString地址非main函数中的对象MyString的首地址</span><br><span class="line">004010E4leaecx,[ebp+8];取参数1的地址</span><br><span class="line">;调用成员函数GetString, 该方法的讲解略</span><br><span class="line">004010E7call@ILT+0 (CMyString::GetString) (00401005)</span><br><span class="line">004010ECpusheax;将返回eax中保存的字符串的首地址作为参数压栈</span><br><span class="line">004010EDcallprintf (00401310)</span><br><span class="line">004010F2addesp,4</span><br><span class="line">&#125;&#x2F;&#x2F;ShowMyString函数的结尾处</span><br><span class="line">;由于对象被释放，修改对象个数</span><br><span class="line">004010F5movdword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">;取参数1的地址，作为this指针调用析构函数</span><br><span class="line">004010FCleaecx,[ebp+8]</span><br><span class="line">004010FFcall@ILT+20 (CMyString::~CMyString) (00401019)</span><br><span class="line">0040111Eret</span><br></pre></td></tr></table></figure><p>在代码中，当对象作为参数被传递时，参数MyStringCpy复制了对象MyString中的数据成员m_pString，产生了两个CMyString类的对象。由于没有编写拷贝构造函数，因此在传参的时候就没有被调用，这个时候编译器以浅拷贝处理，它们的数据成员m_pString都指向了同一个堆地址，如图所示。</p><p><img src="P4.jpg" alt="复制对象与原对象对比"></p><p>根据图所示，两个对象中的数据成员m_pString指向了相同地址，当函数ShowMyString调用结束后，便会释放对象MyStringCpy，以对象MyStringCpy的首地址作为this指针调用析构函数。在析构函数中，调用delete函数来释放掉对象MyStringCpy的数据成员m_ pString 所保存的堆空间的首地址。但对象MyStringCpy是MyString的复制品，真正的MyString还存在，而数据成员m_pString所保存的堆空间的首地址却被释放，如果出现以下代码便会产生错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMyString MyString;</span><br><span class="line">&#x2F;&#x2F;当该函数调用结束后，对象MyString中的数据成员m_pString所保存的堆空间已经被释放掉，再次使用此对象中的数据成员m_pString便无法得到堆空间的数据</span><br><span class="line">ShowMyString (MyString);</span><br><span class="line">ShowMyString (MyString);;显示地址中为错误数据</span><br></pre></td></tr></table></figure><p>两个方案解决这个问题</p><ol><li><strong>深拷贝数据</strong>:在复制对象时，编译器会调用一次该类的拷贝构造函数，给编码者一次机会。深拷贝利用这次机会将原对象的数据成员所保存的资源信息也制作一份副本。这样，当销毁复制对象时，销毁的资源是复制对象在拷贝构造函数中制作的副本，而非原对象中保存的资源信息。</li><li><strong>设置引用计数</strong>:在进入拷贝构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放掉申请的资源，否则引用计数减1。</li></ol><h2 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h2><p>对象作为返回值与对象作为参数的处理方式非常类似。对象作为参数时，进入函数前预先将对象使用的栈空间保留出来，并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。</p><p>来个栗子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码说明：在函数内定义对象并将其作为返回值</span><br><span class="line">class CReturn&#123;</span><br><span class="line">public:</span><br><span class="line">int m_nNumber;</span><br><span class="line">int m_nArry[10];</span><br><span class="line">&#125;;</span><br><span class="line">CReturn GetCReturn()&#123;</span><br><span class="line">CReturn RetObj;</span><br><span class="line">RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">return RetObj;&#x2F;&#x2F;返回局部对象</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char* argv[])&#123;</span><br><span class="line">CReturn objA;</span><br><span class="line">objA &#x3D; GetCReturn();</span><br><span class="line">printf(&quot;%d %d %d&quot;,objA.m_nNumber,objA.m_nArry[0],objA.m_nArry[9]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数和析构函数略</span><br><span class="line">&#x2F;&#x2F;main函数代码分析</span><br><span class="line"></span><br><span class="line">void main(int argc, char* argv[]) &#123;</span><br><span class="line">00401290pushebp</span><br><span class="line">00401291movebp,esp</span><br><span class="line">00401293subesp,0C4h;预留返回对象的栈空间</span><br><span class="line">00401299pushebx</span><br><span class="line">0040129Apushesi</span><br><span class="line">0040129Bpushedi</span><br><span class="line">0040129Cleaedi,[ebp-0C4h]</span><br><span class="line">004012A2movecx,31h</span><br><span class="line">004012A7moveax,0CCCCCCCCh</span><br><span class="line">004012ACrep stosdword ptr[edi]</span><br><span class="line">CReturn objA;</span><br><span class="line">objA&#x3D; GetCReturn();</span><br><span class="line">004012AEleaeax,[ebp- 84h];获取返回对象的栈空间首地址</span><br><span class="line">;将返回对象的首地址压入栈中，用于保存返回对象的数据</span><br><span class="line">004012B4pusheax</span><br><span class="line">;调用函数GetCReturn, 见下文对GetCReturn的实现过程的分析</span><br><span class="line">004012B5call@ILT+45 (GetCReturn) (00401032)</span><br><span class="line">004012BAaddesp,4</span><br><span class="line">;函数调用结束后，eax中保存着地址ebp-84h， 即返回对象的首地址</span><br><span class="line">004012BDmovesi,eax ;将返回对象的首地址存入esi中</span><br><span class="line">004012BFmovecx,0Bh ;设置循环次数</span><br><span class="line">004012C4leaedi,[ebp-58h] ;获取临时对象的首地址</span><br><span class="line">;每次从返回对象中复制4字节数据到临时对象的地址中，共复制11次</span><br><span class="line">004012C7rep movsdword ptr [edi],dword ptr [esi]</span><br><span class="line">004012C9movecx,0Bh ;重新设置复制次数</span><br><span class="line">004012CEleaesi,[ebp-58h] ;获取临时对象的首地址</span><br><span class="line">004012D1leaedi,[ebp-2Ch] ;获取对象objA的首地址</span><br><span class="line">;将数据复制到对象objA中</span><br><span class="line">004012D4rep movsdword ptr [edi],dword ptr [esi]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;GetCReturn 的实现过程分析</span><br><span class="line">CReturn GetCReturn() &#123;</span><br><span class="line">0040CE90pushebp</span><br><span class="line">0040CE91movebp,esp</span><br><span class="line">0040CE93subesp,70h;调整栈空间，预留临时返回对象与局部对象的内存空间</span><br><span class="line">0040CE96pushebx</span><br><span class="line">0040CE97pushesi</span><br><span class="line">0040CE98pushedi</span><br><span class="line">0040CE99leaedi,[ebp-70h]</span><br><span class="line">0040CE9Cmovecx,1Ch</span><br><span class="line">0040CEA1moveax,0CCCCCCCCh</span><br><span class="line">0040CEA6rep stos dword ptr [edi]</span><br><span class="line">CReturn RetObj;</span><br><span class="line">RetObj.m_nNumber &#x3D; 0;</span><br><span class="line">;为数据成员nNumber賦值0，地址ebp-2Ch便是对象Retobj的酋地址</span><br><span class="line">0040CEA8movdword ptr [ebp-2Ch],0</span><br><span class="line">for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">RetObj.m_Arry[i] &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">0040CED4jmpGetCReturn+28h(0040ceb8);for循环分析略，直接看退出函数时的处理</span><br><span class="line">return RetObj;</span><br><span class="line">0040CED6movecx,0Bh;设置循环次数为11次</span><br><span class="line">0040CEDBleaesi,[ebp-2Ch];获取局部对象的首地址</span><br><span class="line">0040CEDEmovedi,dword ptr [ebp+8] ;荻取返回对象的首地址</span><br><span class="line">;将局部对象RetObj中的数据复制到返回对象中</span><br><span class="line">0040CEE1rep movsdword ptr [edi],dword ptr [esi]</span><br><span class="line">0040CEE3moveax,dword ptr [ebp+8] ;获取返回对象的首地址并保存到eax中，作为返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码演示了函数返回对象的全过程。在调用GetCReturn前，编译器将在main函数中申请的返回对象的首地址作为参数压栈，在函数GetCReturn调用结束后进行了数据复制，将GetCReturn函数中定义的局部对象RetObj的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象objA，从而达到返回对象的目的。因为在这个示例中不存在函数返回后为对象的引用赋值，所以这里的返回对象是临时存在的，也就是C++中的临时对象，作用域仅限于单条语句。</p><p>这个临时对象的产生原因主要是C++程序员可能采用这类写法，如GetCReturn().m_nNumber,这只是针对返回对象的操作，而此时函数已经退出，其栈帧也被关闭。函数退出后去操作局部对象显然不合适，因此只能由函数的调用方准备空间，建立临时对象，然后将函数中的局部对象复制给临时对象，再把这个临时对象交给调用方去操作。本例中的objA = GetCReturn();是个赋值运算，由于赋值时GetCReturn函数已经退出，其栈空间已经关闭，同理objA不能直接和函数内局部对象做赋值运算，因此需要临时对象记录返回值以后再来参与赋值。</p><p>虽然使用临时对象进行了数据复制，但是同样存在出错的风险。这与对象作为参数时遇到的情况一样，由于使用了临时对象进行数据复制，当临时对象被销毁时，会执行析构函数。如果析构函数中有对资源释放的处理，就有可能造成同一个资源多次释放的错误。</p><p>编译器在处理简单的结构体和类结构的时候，开启O2优化后，难以识别他们与局部变量的区别</p><p>来个栗子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct tagUnknow&#123;</span><br><span class="line">short m_sShort;</span><br><span class="line">int m_nInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">;int ___cdec1 main(int arge, const char **argv， const char **envp)</span><br><span class="line">subesp,8</span><br><span class="line">leaeax,[esp+8+var_8];获取局部变量的地址并存入eax中</span><br><span class="line">mov[esp+8+var_8],3;赋值局部变量1</span><br><span class="line">pusheax;将局部变量的地址作为参数传递</span><br><span class="line">mov[esp+0Ch+var_4],2;腻值局部变量2</span><br><span class="line">callsub_401000;调用函数sub_401000</span><br><span class="line">addesp,0ch</span><br><span class="line">retn</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">sub_401000 proc near</span><br><span class="line">arg_0 &#x3D; dword ptr 4;有一个参数</span><br><span class="line">moveax,[esp+arg_0];获取参数并保存到eax中</span><br><span class="line">;从eax保存的地址中取出2字节数据，结合后面一条指令可推断这是对象成员的寻址，因为参数指针指向的数据类型不一致</span><br><span class="line">movsxecx,word ptx [eax]</span><br><span class="line">movedx,[eax+4];寄存器相对间接寻址方式，这是对象成员的寻址</span><br><span class="line">pushecx;将荻取数据作为参数压栈</span><br><span class="line">pushedx</span><br><span class="line">pushoffset aDD</span><br><span class="line">callprintf</span><br><span class="line">addesp,0Ch</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure><p>在通常情况下，VC++6.0编译的代码默认<strong>以thiscall方式调用成员函数</strong>，因此会使用ecx来保存this 指针，从而进行参数传递，但并非具有ecx传参的函数就一定是成员函数。当使用__fastcall 时，同样可以在反汇编代码中体现出ecx传参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;((struct A*)NULL)-&gt; m_ float 不会崩溃，这时求m_ float 的地址，根据前面提出的结构体寻址公式:</span><br><span class="line">p-&gt;member的地址&#x3D;指针p的地址值+ member在type中的偏移量</span><br><span class="line">代入得:</span><br><span class="line">&amp;((struct A*)NULL)-&gt; m_ float&#x3D;0 +4&#x3D;4，这个表达式实际上是求结构体内成员的偏移量。</span><br><span class="line">可以定义如下宏，用于在不产生对象的情况下取得成员偏移量:</span><br><span class="line">#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)</span><br></pre></td></tr></table></figure><p>这个结束了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》(四)  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术(五)</title>
    <link href="http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%94/"/>
    <id>http://www.kittener.top/2020/06/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF-%E4%BA%94/</id>
    <published>2020-06-19T15:40:25.000Z</published>
    <updated>2020-08-28T04:24:31.163Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》(五)  </p><a id="more"></a>  <h1 id="关于构造函数和析构函数"><a href="#关于构造函数和析构函数" class="headerlink" title="关于构造函数和析构函数"></a>关于构造函数和析构函数</h1><p><strong>构造函数</strong>：常用来完成对象生成时的数据初始化工作。</p><p><strong>析构函数</strong>：常用于在对象销毁时释放对象中所申请的资源</p><p>构造函数与析构函数都是类中特殊的成员函数，构造函数支持函数重载，而析构函数只能是一个无参函数。它们不可定义返回值，调用构造函数后，返回值为对象首地址，也就是this指针。</p><h2 id="构造函数出现的时机"><a href="#构造函数出现的时机" class="headerlink" title="构造函数出现的时机"></a>构造函数出现的时机</h2><ol><li><p><strong>局部对象：</strong></p><p>当对象产生时就可能引发构造函数的调用。来个栗子~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;无参构造函数的调用过程</span><br><span class="line">class CNumber&#123;</span><br><span class="line">public:</span><br><span class="line">CNumber()&#123;</span><br><span class="line">m_nNumber &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int m_nNumber;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">CNumber Number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解</span><br><span class="line">void main()&#123;</span><br><span class="line">CNumber Number;</span><br><span class="line">0040B468leaecx,[ebp-4];取得对象首地址,传入ecx中作为参数</span><br><span class="line">0040B46Bcall@ILT+5 (CNumber::CNumber) (0040100a) ; 调用构造函数</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造函数CNumber分析</span><br><span class="line">CNumber();</span><br><span class="line">;函数入口分析略</span><br><span class="line">0040B4A9popecx;还原ecx,ecx中保存对象的首地址</span><br><span class="line">0040B4AAmovdword ptr [ebp-4],ecx ;[ebp-4] 就是this指针</span><br><span class="line">&#123;</span><br><span class="line">m_nNumber &#x3D; 1;</span><br><span class="line">0040B4ADmoveax,dword ptr [ebp-4];eax中保存了对象的首地址</span><br><span class="line">0040B4B0movdword ptr [eax],1;将数据成员m_nNumber设置为1</span><br><span class="line">&#125;</span><br><span class="line">0040B4B6moveax,dword ptr [ebp-4] ;将this指针存入eax中，作为返回值</span><br><span class="line">0040B4B9popedi</span><br><span class="line">0040B4BApopesi</span><br><span class="line">0040B4BBpopebx</span><br><span class="line">0040B4BCmovesp,ebp</span><br><span class="line">0040B4BEpopebp</span><br><span class="line">0040B4BFret</span><br></pre></td></tr></table></figure><p>当在进人对象的作用域时，编译器会产生调用构造函数的代码。由于构造函数属于成员函数，因此在调用的过程中同样需要传递this指针。构造函数调用结束后，会将this指针作为返回值。总结一下局部对象构造函数的<strong>必要条件</strong>：</p><ul><li>该成员函数是这个对象在作用域内调用的第一个成员函数，根据this指针即可以区分</li><li>返回this指针</li></ul></li><li><p><strong>堆对象</strong>：</p><p>堆对象的识别重点在于识别堆空间的申请与使用。在C++的语法中，堆空间的申请需要使用malloc函数、new运算符或者其他同类功能的函数。因此，识别堆对象有了重要的依据。来个栗子！</p><p>(从这里开始我有的代码部分要直接截图了，👴就是懒狗！)</p><p><img src="P1.jpg" alt="构造函数返回值的使用——Debug版"></p><p><img src="P2.jpg" alt="构造函数返回值的使用——Debug版"></p><p>在使用了new申请了堆空间之后，需要调用构造函数，用来完成数据成员的初始化。相应的，如果没有申请成功，则会避开构造函数的调用。对此，编译器会产生一个<strong>双分支结构来根据不同的结果采取相应的行为</strong>。这是检查的重点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;圆括号是调用有参构造函数，最后只申请了一个int类型的堆变量并赋初值10</span><br><span class="line">int *pInt &#x3D; new int (10);</span><br><span class="line">&#x2F;&#x2F;方括号才是申请了10个int元素的堆数组</span><br><span class="line">int *pInt &#x3D; new int [10];</span><br></pre></td></tr></table></figure></li><li><p><strong>参数对象</strong>：</p><p>参数对象属于局部对象中的–种特殊情况。当对象作为函数参数时，调用一个特殊的构造函数——拷贝构造函数。该构造函数只有一个参数，类型为对象的引用。</p><p>当对象为参数的时候触发此类对象的拷贝构造函数。在函数调用时传递参数会进行复制，形参是实参的副本。两个对象的复制过程会在拷贝构造函数中完成。如果没有定义拷贝构造函数，编译器会对原对象与拷贝对象中的各数据成员直接进行数据复制，称为默认拷贝构造函数，这种拷贝方式属于浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CNumber &#123;</span><br><span class="line">public:</span><br><span class="line">CNumber() &#123;</span><br><span class="line">m_nNumber &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line">void main() &#123;</span><br><span class="line">CNumber Number;</span><br><span class="line">CNumber number(Number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种函数在有析构函数的情况下会出错，那么就需要深拷贝来救场了。<strong>源对象中的数据成员间接访问到的其他资源并制作副本的拷贝构造函数称为深拷贝</strong>。</p><p>来个栗子！</p><p><img src="P3.jpg" alt=""></p><p><img src="P4.jpg" alt=""></p><p><img src="P.jpg" alt=""></p><p><img src="P5.jpg" alt=""></p><p><img src="P6.jpg" alt=""></p></li><li><p><strong>返回对象</strong></p><p>与参数对象的区别是：当对象作为参数时，在进入函数前使用拷贝构造函数，而返回对象则在函数返回时使用拷贝构造函数。</p><p>来个栗子~</p><p><img src="P7.jpg" alt=""></p><p><img src="P8.jpg" alt=""></p><p>这种返回对象的函数和返回对象指针类型的函数在汇编中的区别就是：<strong>返回值和参数为对象指针类型的函数，不会使用以参数为目标的拷贝构造函数，而是直接使用指针保存对象首地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数的返回类型与参数类型都是对象的指针类型</span><br><span class="line">CMyString* GetMyString (CMyString* pMyString) &#123;</span><br><span class="line">CMyString MyString;&#x2F;&#x2F;定义局部对象</span><br><span class="line">MyString.SetString (&quot;World&quot;);</span><br><span class="line">pMyString &#x3D; &amp;MyString;</span><br><span class="line">00401589leaeax,[ebp-10h];直接保存对象首地址</span><br><span class="line">0040158Cmovdword ptr [ebp+8],eax</span><br><span class="line">return &amp;MyString;</span><br><span class="line">0040158Fleaecx,[ebp-10h]</span><br><span class="line">00401592movdword ptr [ebp-14h],ecx </span><br><span class="line">00401595movdword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">0040159Cleaecx,[ebp-10h];将局部对象作为返回值</span><br><span class="line">0040159Fcall@ILT+35 (CMyString::-CMyString) (00401028)</span><br><span class="line">004015A4moveax,dword ptr [ebp-14h]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局对象与静态对象</strong></p><p>这两类对象的构造时机相同，它们的构造函数的调用被隐藏在深处，但是识别过程很容易。因为程序中所有的全局对象将会在同一地点调用构造函数来初始化数据。</p><p>构造函数需要传递对象的首地址作为this指针,而且构造函数可以带各类参数，因此编译器将为每个全局对象生成一段传递this指针和参数的代码，然后使用无参的代理函数去调用构造函数。</p><p>如何跟踪？</p><ul><li><p>直接定位初始化函数</p></li><li><p>利用栈回溯</p><p>如果反汇编代码中出现了全局对象，由于全局对象的地址固定(对于有重定位表的执行文件中的全局对象，也可以在执行文件被加载后至执行前计算得到全局对象的地址)，因此可以在对象的数据成员中设置读写断点，调试运行程序，等待构造函数调用的到来。利用栈回溯窗口，找到程序的执行流程，依次向上查询即可找到构造函数调用的起始处。</p></li></ul></li></ol><h2 id="每个对象都有默认的构造函数吗"><a href="#每个对象都有默认的构造函数吗" class="headerlink" title="每个对象都有默认的构造函数吗"></a>每个对象都有默认的构造函数吗</h2><p>并不是。只有以下两种情况会有：</p><ul><li><p>本类、本类中定义的成员对象或者父类中有虚函数存在</p><p>由于需要初始化虚表，且这个工作理应在构造函数中隐式完成，因此在没有定义构造函数的情况下，编译器会添加默认的构造函数用于隐式完成虚表的初始化工作</p></li><li><p>父类或本类中定义的成员对象带有构造函数</p><p>在对象被定义时，由于对象本身为派生类，因此构造顺序是先构造父类再构造自身。当父类中带有构造函数时，将会调用父类构造函数，而这个调用过程需要在构造函数内完成，因此编译器添加了默认的构造函数来完成这个调用过程。成员对象带有构造函数的情况与此相同。</p></li></ul><h2 id="析构函数出现的时机"><a href="#析构函数出现的时机" class="headerlink" title="析构函数出现的时机"></a>析构函数出现的时机</h2><p>对象何时被销毁取决于对象所在的作用域，当程序流程执行到作用域结束处时，便会将该作用域内的所有对象释放，释放的过程中会调用到对象的析构函数。</p><p>析构函数的触发时机分为以下几种情况</p><ul><li>局部对象:作用域结束前调用析构函数</li><li>堆对象:释放堆空间前调用析构函数</li><li>参数对象:退出函数前，调用参数对象的析构函数</li><li>返回对象:如无对象引用定义，退出函数后，调用返回对象的析构函数，否则与对象引用的作用域一致</li><li>全局对象: main函数退出后调用析构函数</li><li>静态对象:main函数退出后调用析构函数</li></ul><h3 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h3><p>书上给了几个代码👴觉得很有学习必要，截图了</p><h4 id="堆对象析构函数的调用"><a href="#堆对象析构函数的调用" class="headerlink" title="堆对象析构函数的调用"></a>堆对象析构函数的调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(ubt argc,char* argv[])&#123;</span><br><span class="line">CNumber * pNumber &#x3D; NULL;</span><br><span class="line">pNumber &#x3D; new CNumber;</span><br><span class="line">pNumber-&gt;m_nNumber &#x3D; 2;</span><br><span class="line">printf(&quot;%d \r\n&quot;,pNumber-&gt;m_nNumber);</span><br><span class="line">if(pNumber !&#x3D; NULL)&#123;</span><br><span class="line">delete pNumber;</span><br><span class="line">pNumber &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="P8.jpg" alt=""></p><p><img src="P9.jpg" alt=""></p><p><img src="P10.jpg" alt=""></p><p><img src="P11.jpg" alt=""></p><p>多个堆对象的申请与释放</p><p><img src="P12.jpg" alt=""></p><p><img src="P13.jpg" alt=""></p><p><img src="P14.jpg" alt=""></p><h4 id="堆对象的构造代理函数"><a href="#堆对象的构造代理函数" class="headerlink" title="堆对象的构造代理函数"></a>堆对象的构造代理函数</h4><p><img src="P15.jpg" alt=""></p><p><img src="P16.jpg" alt=""></p><h4 id="堆对象释放函数分析"><a href="#堆对象释放函数分析" class="headerlink" title="堆对象释放函数分析"></a>堆对象释放函数分析</h4><p><img src="P17.jpg" alt=""></p><h3 id="参数对象和返回对象"><a href="#参数对象和返回对象" class="headerlink" title="参数对象和返回对象"></a>参数对象和返回对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMyString MyString &#x3D; GetMyString();</span><br></pre></td></tr></table></figure><p>这是把MyString的地址作为隐含的参数传递给GetMyString()，在GetMyString()内部完成拷贝构造的过程。函数执行完毕后，MyString 就已经构造完成了，所以析构函数由MyString的作用域来决定.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyString &#x3D; GetMyString();</span><br></pre></td></tr></table></figure><p>因为这样的代码不是MyString在定义时赋初值，所以不会触发MyString的拷贝构造函数，这时候会产生临时对象作为GetMyString()的隐含参数，这个临时对象会在GetMyString0内部完成拷贝构造函数的过程。函数执行完毕后，如果MyString的类中定义了“=”运算符重载，则调用之;否则就根据对象成员逐个赋值。如果对象内数据量过大，就会调用rep movs这样的串操作指令批量赋值，这样的赋值也属于浅拷贝。临时对象以一条高级语句为生命周期，它在函数调用时产生，在语句执行完毕时销毁。C和C++以分号作为语句的结束符，也就是说，- -旦分号出现，就会触发临时对象的析构函数。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局对象与静态对象相同，其构造函数在函数 _cinit的第二个 _initterm调用中被构造。它们的析构函数的调用时机是在main函数执行完毕之后。既然构造函数出现在初始化过程中，对应的析构函数就会出现在程序结束处。</p><p>在main函数调用结束后，由exit来结束进程，从而终止程序的运行。全局变量的析构函数的调用也在其中(exit函数的doexit实现)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (__onexitbegin) &#123;&#x2F;&#x2F;_onexitbegin 为函数指针数组的首地址</span><br><span class="line">_PVFV * pfend &#x3D; _onexitend;&#x2F;&#x2F;_onexitend为函数指针数组的尾地址</span><br><span class="line">while (--pfend &gt;&#x3D;__onexitbegin)&#x2F;&#x2F;从后向前依次释放全局对象</span><br><span class="line">if (*pfend !&#x3D; NULL)</span><br><span class="line">(**pfend)();&#x2F;&#x2F;调用数组中保存的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__onexitbegin 指向一个指针数组，该数组中保存着各类资源释放时的函数的首地址。全局构造函数的调用是在  _cinit 函数的第二个 _initterm 函数内完成，而在第二个 _initterm函数中，会先执行 _onexitinit 函数的初始化函数指针数组。在执行每个全局对象构造代理函数时都会先执行对象的构造函数，然后使用atexit注册析构代理函数。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>对于全局对象和静态对象，能不能取消代理函数而直接在main函数前调用其构造函数呢?</p><p>不能。由于构造函数可以重载，因此其参数的类型、个数和顺序都无法预知，也就无法预先定义构造函数。函数参数如何匹配呢?如何保证栈顶平衡呢?最简洁的办法就是使用代理函数。</p><p>编译器为每个全局对象分别生成构造代理函数，由代理函数去调用各类形形色色的参数和约定的构造函数。由于代理函数的类型被统一指定为PVFV，因此能通过数组统一地管理和执行。</p><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>对象的多态性需要通过虚表和虚表指针来完成，虚表指针被定义在对象首地址的前4字节处，因此虚函数必须作为成员函数使用。</p><h2 id="虚函数的机制"><a href="#虚函数的机制" class="headerlink" title="虚函数的机制"></a>虚函数的机制</h2><p>在C++中，使用关键字virtual声明函数为虚函数。当类中定义有虚函数时，编译器会将该类中所有虚函数的首地址保存在一-张地址表中，这张表被称为虛函数地址表，简称虚表。同时，编译器还会在类中添加-一个隐藏数据成员，称为虚表指针。该指针中保存着虚表的首地址，用于记录和查找虚函数。</p><p>来份代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CVirtual&#123;</span><br><span class="line">public:</span><br><span class="line">virtual int GetNumber()&#123;</span><br><span class="line">return m_nNumber;</span><br><span class="line">&#125;</span><br><span class="line">virtual void SetNumber(int nNumber)&#123;</span><br><span class="line">m_nNumber &#x3D; nNumber;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_nNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的大小为8，多出的4个字节用于保存虚表指针。在虚表指针所指向的函数指针数组中，保存着虚函数GetNumber和SetNumber的首地址。对于开发者而言，虚表和虚表指针都是隐藏的，在常规的开发过程中感觉不到它们的存在。</p><p>虚表指针和虚表的关系如图</p><p><img src="P18.jpg" alt=""></p><p>虚表指针初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++源码与对应汇编代码讲解;</span><br><span class="line">int main(int argc， char* argv[]) &#123;</span><br><span class="line">CVirtual MyVirtual;</span><br><span class="line">00401048leaecx,[ebp-8];获取对象首地址</span><br><span class="line">;调用构造函数，类CVirtual中并没有定义构造函数，此调用为默认构造函数</span><br><span class="line">0040104Bcall@ILT+15 (CVirtual::CVirtual) (00401014)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;默认构造函数分析</span><br><span class="line">CVirtua1::CVirtual;</span><br><span class="line">;Debug初始化保存环境略</span><br><span class="line">00401089popecx;还原this指针</span><br><span class="line">0040108Amovdword ptr [ebp-4],ecx;;[ebp-4]存储this指针</span><br><span class="line">;取出this指针并保存到eax中，这个地址将会作为指针保存到虚表的首地址中</span><br><span class="line">0040108Dmoveax,dword ptr [ebp-4]</span><br><span class="line">;取虚表的首地址，保存到虚表指针中</span><br><span class="line">00401090movdword ptr [eax],offset CVirtual::&#39;vftable&#39; (0042201c) </span><br><span class="line">00401096moveax, dword ptr [ebp-4];返回对象首地址</span><br><span class="line">00401099popedi</span><br><span class="line">0040109Apopesi</span><br><span class="line">0040109Bpopebx</span><br><span class="line">0040109Cmovesp,ebp</span><br><span class="line">0040109Epopebp</span><br><span class="line">0040109Fret</span><br></pre></td></tr></table></figure><p>编译器为类CVirtual提供了默认的构造函数。该默认构造函数先取得虚表首地址再赋值到虚表指针中。</p><p>对象的虚表指针初始化是通过编译器在构造函数内插入代码来完成的。由于虚表信息在编译后会被链接到对应的执行文件中，因此所获得的虛表地址是一个相对固定的地址。虛表中虛函数的地址的排列顺序依据虛函数在类中的声明顺序而定，先声明的虚函数的地址会被排列在虚表中靠前的位置。</p><p>对于含有构造函数的类而言，其虚表初始化过程和默认构造函数相同，都是以对象首地址的前4字节数据保存虚表的首地址。如图</p><p><img src="P19.jpg" alt=""></p><p><strong>对于单线继承的类结构，在其某个成员函数中，将this的地址赋值为虛表首地址时，可以判定这个成员函数为构造函数。</strong></p><p>析构函数分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++源码与对应汇编代码讲解</span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">CVirtual MyVirtual;</span><br><span class="line">return 0;</span><br><span class="line">;构造函数分析略，直接看析构函数的调用</span><br><span class="line">00401060movdword ptr [ebp-0Ch],0</span><br><span class="line">00401067leaecx, [ebp-8]</span><br><span class="line">0040106Acall@ILT+15 (CVirtual::~CVirtual) (00401014)&#x2F;&#x2F;析构函数调用</span><br><span class="line">0040106Fmoveax, dword ptr [ebp-0Ch]</span><br><span class="line">&#125;</span><br><span class="line">00401014jmpCVirtual::~CVirtual (00401100)</span><br><span class="line">&#x2F;&#x2F;析构函数分析</span><br><span class="line">~CVirtual()&#123;</span><br><span class="line">;函数入口代码略</span><br><span class="line">00401119popecx</span><br><span class="line">0040111Amovdword ptr [ebp-4],ecx;[ebp-4]保存this指针</span><br><span class="line">0040111Dmoveax,dword ptr [ebp-4] ;eax 得到this指针，这是虚表的位置</span><br><span class="line">;将当前类的虚表首地址赋值到虚表指针中</span><br><span class="line">00401120movdword ptr [eax],offset CVirtual::&#39;vftable&#39;(00425024)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数中的填写虚表，是在还原虚表指针，让其指向自身的虚表首地址，防止在析构函数中调用虚函数时取到非自身虚表，从而导致函数调用错误。</p><h2 id="虚函数的识别"><a href="#虚函数的识别" class="headerlink" title="虚函数的识别"></a>虚函数的识别</h2><p>有以下特征</p><ul><li>类中隐式定义了一个数据成员;</li><li>该数据成员在首地址处，占4字节;</li><li>构造函数会将此数据成员初始化为某个数组的首地址;</li><li>这个地址属于数据区，是相对固定的地址;</li><li>在这个数组内，每个元素都是函数指针;</li><li>仔细观察这些函数，它们被调用时，第-个参数必然是this指针(要注意调用约定);</li><li>在这些函数内部，很有可能会对this指针使用相对间接的访问方式。</li></ul><p>虚函数的识别最终转变成识别构造函数或者析构函数。构造函数与虛表指针的初始化有依赖关系。<strong>重点看对象首地址前4字节被赋予的值。</strong>来个栗子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;具有成员函数特征，传递对象首地址作为this指针</span><br><span class="line">leaecx,[ebp-8];荻取对象首地址</span><br><span class="line">callXXXXXXXXh;调用函数</span><br><span class="line">;调用函数的实现代码</span><br><span class="line">popecx;this指针的还原，非Debug编译选项组在可能无此代码</span><br><span class="line">moveax,dword ptr [ecx];取出首地址前4字节数据</span><br><span class="line">;向对象首地址处写入4宇节数据，查看并确认此4字节数据是否为函数地址表的首地址</span><br><span class="line">movdword ptr [eax],XXXXXXXXh</span><br></pre></td></tr></table></figure><h1 id="从内存角度看继承和多重继承"><a href="#从内存角度看继承和多重继承" class="headerlink" title="从内存角度看继承和多重继承"></a>从内存角度看继承和多重继承</h1><h2 id="识别类和类之间的关系"><a href="#识别类和类之间的关系" class="headerlink" title="识别类和类之间的关系"></a>识别类和类之间的关系</h2><p>在父类中声明为私有(private)的成员，虽然子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。</p><p><strong>编译器在当子类中没有构造函数或析构函数，但是其父类却含有的情况下，编译器会为该父类的子类提供默认的构造函数与析构函数。</strong></p><p>子类在初始化的时候，如果父类有构造函数会先执行父类的构造函数，在销毁的时候，为了调用父类的析构函数，编译器为子类提供了默认的析构函数。在子类的析构函数中，先执行自身的析构代码，再执行其父类的析构代码。</p><p>如果子类中含有构造函数，但是父类中没有，那么编译器不会为父类提供默认的构造函数。但是如果父类中如果含有虚函数，则编译器为了初始化虚表，会提供默认的构造函数。</p><p>在类对象初始化的过程中，构造的顺序如下：先构造父类，然后按声明顺序构造成员对象和初始化列表中指定的成员，最后才是自身的构造函数。</p><p>在子类对象的内存布局中，低地址是用来存储父类数据成员的，高地址是存储自身数据成员。</p><p>有了这样的内存结构，不但可以使用指向子类对象的子类指针间接寻址到父类定义的成员，而且可以使用指向子类对象的父类指针间接寻址到父类定义的成员。在使用父类成员函数时，传递的this指针也可以是子类对象首地址。所以子类指针的寻址范围不小于父类指针，这是个包含关系。在使用子类指针访问父类对象时，如果访问的成员数据是父类对象所定义的，那么不会出错;如果访问的是子类派生的成员数据，则会造成访问越界。</p><p>来份代码！</p><p><img src="P20.jpg" alt=""></p><p><img src="P21.jpg" alt=""></p><p>如使用对象或对象的指针调用成员函数，编译器可根据对象所属作用域来使用“名称粉碎法”，以实现正确匹配。在成员函数中调用其他成员函数时，可匹配当前作用域。</p><p><a href="https://blog.csdn.net/lixiangminghate/article/details/79340775" target="_blank" rel="noopener">名称粉碎法</a></p><p>虚函数的多态问题这本书写的一言难尽，一会说在构造函数中调用虚函数不彳亍，一会又说彳亍，给👴整懵逼了，草(一种植物)，可能是👴太菜了，但我感觉写的稀里糊涂，找了几篇blog看看算了</p><p><a href="https://blog.csdn.net/weixin_30682415/article/details/101553704" target="_blank" rel="noopener"></a></p><p><a href="https://blog.csdn.net/tianguiyuyu/article/details/104560102" target="_blank" rel="noopener"></a></p><p><a href="https://blog.csdn.net/K346K346/article/details/49872023" target="_blank" rel="noopener"></a></p><p>无内鬼，来、迷惑操作</p><p><img src="P22.jpg" alt=""></p><p><img src="P23.jpg" alt=""></p><p>到底让不让我调用？书上的意思好像是在父类构造函数中调用虚函数会使虚表指针变成直接调用，无法构成多态，但是我实际写了写好像没多大影响，留个坑。</p><p>来填坑，原来子类初始化的时候调用父类虚函数就叫虚函数失效，害，就这？</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>当子类拥有多个父类时，便构成多重继承关系。</p><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class CSofa &#123;</span><br><span class="line">public:</span><br><span class="line">CSofa() &#123;</span><br><span class="line">m_nColor &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~CSofa()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;virtual ~CSofa()\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">virtual int GetColor() &#123;</span><br><span class="line">return m_nColor;</span><br><span class="line">&#125;</span><br><span class="line">virtual int SitDown() &#123;</span><br><span class="line">return printf(&quot;Sit down and rest your legs\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_nColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CBed &#123;</span><br><span class="line">public:</span><br><span class="line">CBed() &#123;</span><br><span class="line">m_nLength &#x3D; 4;</span><br><span class="line">m_nWidth &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~CBed()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;virtual ~CBed()\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">virtual int GetArea() &#123;</span><br><span class="line">return m_nLength * m_nWidth;</span><br><span class="line">&#125;</span><br><span class="line">virtual int Sleep() &#123;</span><br><span class="line">return printf(&quot;go to sleep\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_nLength;</span><br><span class="line">int m_nWidth;</span><br><span class="line">&#125;;</span><br><span class="line">class CSofaBed : public CSofa, public CBed &#123;</span><br><span class="line">public:</span><br><span class="line">CSofaBed() &#123;</span><br><span class="line">m_nHeight &#x3D; 6;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~CSofaBed()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;virtual ~CSofaBed()\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">virtual int SitDown() &#123;</span><br><span class="line">return printf(&quot;Sit down on the sofabed\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">virtual int Sleep() &#123;</span><br><span class="line">return printf(&quot;go to sleep on the sofabed\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">virtual int GetHeight() &#123;</span><br><span class="line">return m_nHeight;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_nHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">CSofaBed SofaBed;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内存中的分布如图：</p><p><img src="P24.jpg" alt=""></p><p>占用的内存空间大小为0x18字节。除此之外，还有两个地址值，分别为0x00426198和0x0042501C，这两处地址的数据如图：</p><p><img src="P25.jpg" alt=""></p><p>这两个虚表中保存了子类的虚函数和父类的虚函数，父类的虚函数在子类中没有实现。由此可见，编译器将子类CSofaBed的虚函数制作了两份，康康编译器的操作</p><p><img src="P26.jpg" alt=""></p><p>在调用另-一个父类CBed时，并不是直接将对象的首地址作为this指针传递，而是向后调整了父类CSofa的大小，以调整后的地址值作为this指针，最后再调用父类CBed的构造函数。</p><p>转换成父类指针的时候也是如此，如果转换成CBed，会调整首地址并跳过第一个父类所占用的空间，这样就不会错误寻址咯。</p><p>看看析构过程：</p><p><img src="P27.jpg" alt=""></p><p><img src="P28.jpg" alt=""></p><p>在析构的过程中，由于具有多个父类，当在析构的过程中调用各个父类的析构函数时，传递的首地址将有所不同，编译器会根据每个父类在对象中占用的空间位置，对应地传入各个父类部分的首地址作为this指针。</p><p>在Debug版下，由于侧重调试功能，因此使用了两个临时变量来分别保存两个this指针，它们对应的地址分别为两个虚表指针的首地址。在Release版下，虽然会进行优化，但原理不变，子类析构函数调用父类的析构函数时，仍然会传人在对象中父类对应的地址，当做this指针。</p><p>做个对比~</p><ul><li><strong>单继承类</strong><ul><li>在类对象占用的内存空间中，只保存一份虚表指针。</li><li>由于只有一个虚表指针，对应的也只有一个虚表。</li><li>虚表中各项保存了类中各虚函数的首地址。</li><li>构造时先构造父类，再构造自身，并且只调用一次父类构造函数。</li><li>析构时先析构自身，再析构父类，并且只调用一-次父类析构函数。</li></ul></li><li><strong>多重继承类</strong><ul><li>在类对象所占用的内存空间中，根据继承父类的个数保存对应的虚表指针。</li><li>根据所保存的虚表指针的个数，对应产生相应个数的虛表。</li><li>转换父类指针时，需要跳转到对象的首地址。</li><li>构造时需要调用多个父类构造函数。</li><li>构造时先构造继承列表中第一个父类，然后依次调用到最后一个继承的父类构造函数。</li><li>析构时先析构自身，然后以与构造函数相反的顺序调用所有父类的析构函数。</li><li>当对象作为成员时，整个类对象的内存结构和多重继承很相似。当类中无虚函数时，整个类对象内存结构和多重继承完全一样，可酌情还原;当父类或成员对象存在虚函数时，通过观察虚表指针的位置和构造函数、析构函数中填写虚表指针的数目及目标地址，来还原继承或成员关系。</li></ul></li></ul><h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>直接来份代码康康</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class CVirtualBase&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void Show() &#x3D; 0;    </span><br><span class="line">&#125;;</span><br><span class="line">class CVirtualChild : public CVirtualBase&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void Show()&#123;</span><br><span class="line">        printf(&quot;虚基类分析\r\n&quot;);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line">void main(int argc,char* argv[])&#123;</span><br><span class="line">    CVirtualChild VirtualChild;</span><br><span class="line">    VirtualChild.show();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;反汇编代码分析，跟踪到虚基类构造函数中，查看其虚表信息</span><br><span class="line">CVirtualBase::CVirtualBase;&#x2F;&#x2F;虚基类构造函数</span><br><span class="line">00401829pop ecx</span><br><span class="line">0040182Amovdword ptr [ebp-4],ecx</span><br><span class="line">0040182Dmoveax,dword ptr [ebp-4]</span><br><span class="line">;设置虚基类虚表指针，虚表地址在0x00425068处</span><br><span class="line">00401830movdword ptr [eax],offset CVirtualBase::&#39;vftable&#39;(00425068)</span><br><span class="line">00401836moveax,dword ptr [ebp-4]</span><br><span class="line">0040183Fret</span><br><span class="line"></span><br><span class="line">;虚基类CVirtualBase中虚表信息的第一项所指向的函数首地址</span><br><span class="line">void _cdecl _purecall (void) &#123;</span><br><span class="line">00401E90pushebp</span><br><span class="line">00401E91movebp,esp</span><br><span class="line">_amsg_exit(_ RT_PUREVIRT);</span><br><span class="line">00401E93push19h;压入错误编码</span><br><span class="line">00401E95call_amsg_exit (00401fd0);结束程序</span><br><span class="line">00401E9Aaddesp,4</span><br><span class="line">&#125;</span><br><span class="line">00401E9Dpopebp</span><br><span class="line">00401E9Eret</span><br></pre></td></tr></table></figure><p>如代码所示，在虚基类CVirtualBase的虚表信息中，由于纯虚函数没有实现代码，因此没有首地址。编译器为了防止误调用纯虚函数，将虛表中保存的纯虚函数的首地址项替换成函数_ purecall, 用于结束程序，并发出错误编码信息0x19。</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p><img src="P29.jpg" alt=""></p><p>来个栗子！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFurniture</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CFurniture() &#123;</span><br><span class="line">m_nPrice = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~CFurniture()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"virtual ~CFurniture()\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_nPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_nPrice;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSofa</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> CFurniture&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CSofa() &#123;</span><br><span class="line">m_nPrice = <span class="number">1</span>;</span><br><span class="line">m_nColor = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~CSofa()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"virtual ~CSofa()\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_nColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SitDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Sit down and rest your legs\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_nColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBed</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> CFurniture&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CBed() &#123;</span><br><span class="line">m_nPrice = <span class="number">3</span>;</span><br><span class="line">m_nLength = <span class="number">4</span>;</span><br><span class="line">m_nWidth = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~CBed()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"virtual ~CBed()\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_nLength * m_nWidth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"go to sleep\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_nLength;</span><br><span class="line"><span class="keyword">int</span> m_nWidth;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSofaBed</span> :</span> <span class="keyword">public</span> CSofa, <span class="keyword">public</span> CBed &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CSofaBed() &#123;</span><br><span class="line">m_nHeight = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~CSofaBed()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"virtual ~CSofaBed()\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SitDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Sit down on the sofabed\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"go to sleep on the sofabed\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_nHeight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_nHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CSofaBed SofaBed;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类结构如图所示</p><p><img src="P30.jpg" alt=""></p><p><img src="P31.jpg" alt=""></p><p>对于CSofaBed_vt(new)和vt_offset的解释如下</p><p><img src="P32.jpg" alt=""></p><p><img src="P33.jpg" alt=""></p><p>从代码的指针转换过程中可以看出来，vt_offset指向的内存地址中保存的数据为偏移数据，每个vt_offset对应的数据有两项：第一项为vt_offset所属类对应的虚表指针相对于vtoffset的偏移值;第二项保存的是父类虚表指针相对于vt_offset 的偏移值。</p><p><img src="P34.jpg" alt=""></p><p>三个虚表指针内容如下</p><p><img src="P35.jpg" alt=""></p><p>如图所示，这三个虚表指针所指向的虛表包含了子类CSofaBed含有的虚函数。有了这些记录就可以随心所欲地将虚表指针转换成任意的父类指针。在利用父类指针访问虚函数时，只能调用子类与父类共有的虚函数，子类继承自其他父类的虚函数是无法调用的，虚表中也没有相关的记录。</p><p>来看一下构造</p><p><img src="P36.jpg" alt=""></p><p><img src="P37.jpg" alt=""></p><p>子类构造的过程中，在调用时要传入一个参数，这个参数是一个标志信息。构造过程中先构造父类，然后再构造自己。当标记为1时，则构造父类；当标记为0时，则跳过构造函数。</p><p>在析构的时候，并没有使用标记信息，而是将祖父类放在最后调用，先依次执行两个父类CBed和CSofa的析构函数，然后执行祖父类的析构函数。</p><h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p><strong>为什么编译器要在子类析构函数中再次将虚表设置为子类虚表呢?</strong>这个操作非常必要，因为编译器无法预知这个子类以后是否会被其他类继承，如果被继承，原来的子类就成了父类，析构函数执行时会先执行当前对象的析构函数，然后向祖父类的方向按继承线路逐层调用各类析构函数，当前对象的析构函数开始执行时，其虚表也是当前对象的，因此执行到父类的析构函数时，虚表必须改写为父类的虚表。编译器所产生的类实现代码，必须能够适应将来不可预知的对象关系，故在每个对象的析构函数内，要加入填写自己虚表的代码。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>学习之前先看两个blog</p><p><a href="https://www.cnblogs.com/yilang/p/11233935.html" target="_blank" rel="noopener">SEH1</a></p><p><a href="https://www.cnblogs.com/yilang/p/11238201.html" target="_blank" rel="noopener">SEH2</a></p><h2 id="异常处理的相关知识"><a href="#异常处理的相关知识" class="headerlink" title="异常处理的相关知识"></a>异常处理的相关知识</h2><ul><li>try语句块负责监视异常。</li><li>throw用于异常信息的发送，也称之为抛出异常。</li><li>catch用于异常的捕获，并作出相应的处理。</li></ul><p>VC++在处理异常时会在具有异常处理功能的函数的人口处注册一个异常回调函数，当该函数内有异常抛出时，便会执行这个已注册的异常回调函数。所有的异常信息都会被记录在相关表格中，异常回调函数根据这些表格中的信息进行异常的匹配处理工作。</p><p>关于异常的实现…说实话没大看懂，留个坑，等我学明白内核来填</p><h2 id="识别异常处理"><a href="#识别异常处理" class="headerlink" title="识别异常处理"></a>识别异常处理</h2><p>通过对VC++异常处理的分析，可将其处理流程总结为以下9个步骤：</p><ol><li>在函数入口处设置异常回调函数，其回调函数先设置eax为FuncInfo数据的地址，然后跳往 ___CxxFrameHandler。</li><li>异常的抛出由 CxxThrowException函数完成，该函数使用了两个参数，一个是抛出异常的关键字throw的参数的指针，另一个是抛出信息类型的指针(ThrowInfo*)。</li><li>在异常回调函数中，可以得到异常对象的地址和对应ThrowInfo数据的地址以及FunInfo表结构的地址。根据所记录的异常类型，进行try块的匹配工作。</li><li>如果没有找到try块，则析构异常对象，返回ExceptionContinueSearch，继续下一个异常回调函数的处理。</li><li>当找到对应的try块时，通过TryBlockMapEntry表结构中的pCatch指向catch信息表，用 ThrowInfo表结构中的异常类型遍历查找与之匹配的catch块，比较关键字名称（如整型为.h，单精度浮点为.m)，找到有效的catch块。</li><li>执行栈展开操作，并产生catch块中使用的异常对象（有4种不同的产生方法)。</li><li>正确析构所有生命期己结束的对象。</li><li>跳转到catch块，执行catch块代码。</li><li>调用 JumpToContinuation函数，返回所有catch语句块的结束地址。</li></ol><p>有一个具体案例的分析，书上讲的很详细，懒得做笔记了，吸吸</p><p>终于看完啦，完结撒花~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》(五)  &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++反汇编与逆向分析技术</title>
    <link href="http://www.kittener.top/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.kittener.top/2020/06/15/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</id>
    <published>2020-06-15T08:22:46.000Z</published>
    <updated>2020-06-19T15:37:58.437Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《C++反汇编与逆向分析技术》</p><a id="more"></a><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="IDA函数识别"><a href="#IDA函数识别" class="headerlink" title="IDA函数识别"></a>IDA函数识别</h2><p>IDA可以识别出函数MessageBoxA及其各参数的信息，IDA通过SIG文件来识别已知的函数信息<br>常用的SIG文件放置在了IDA安装目录中的SIG文件夹下<br><a href="https://blog.csdn.net/youyou519/article/details/100140265" target="_blank" rel="noopener">SIG文件制作</a></p><h2 id="反汇编引擎的工作原理"><a href="#反汇编引擎的工作原理" class="headerlink" title="反汇编引擎的工作原理"></a>反汇编引擎的工作原理</h2><p><img src="%E5%9B%BE1.jpg" alt="Intel指令结构图">  </p><ol><li><p>Instruction Prefixes:指令前缀<br>指令前缀是可选的，作为指令的补助说明信息存在，主要用于以下4种情况  </p><ul><li>重复指令：如REP、REPE、REPZ  </li><li>跨段指令：如MOV DWORD PTR FS:[XXXX],0</li><li>将操作数从32位转为16位：如MOV AX，WORD PTR DS:[EAX]</li><li>将地址从16位转为32位：如MOV EAX，DWORD PTR DS:[BX+SI]  </li></ul></li><li><p>Opcode:指令操作码<br>Opcode为机器码中的操作符部分，用来说明指令语句执行什么样的操作<br>汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条汇编指令助记符与Opcode是一一对应的关系。每一条汇编指令助记符都会对应一条Opcode码，但由于操作数类型不同，所占长度也不相同，因此对于非单字节指令来说，解析一条汇编指令单凭Opcode是不够的，还需要Mode R/M、SIB、 Displacement 的帮助，才能够完整地解析出汇编信息  </p></li><li><p>Mode R/M：操作数类型<br>ModeRM是辅助Opcode解释汇编指令助记符后的操作数类型。R表示寄存器，M表示内存单元。Mode RM占一个字节的固定长度<br><img src="%E5%9B%BE2.jpg" alt="Mode R/M">  </p></li><li><p>SIB: 辅助Mode R/M，计算地址偏移<br>SIB的寻址方式为基址+变址，如MOV EAX,DWORD PTR DS:[EBX+ECX*2],其中的ECX、乘数2都是由SIB来指定的。SIB的结构如图1-15所示。SIB占1个字节大小，第0、1、2位用于指定作为基址的寄存器;第3、4、5位用于指定作为变址的寄存器:第6、7位用于指定乘数，由于只有两位，因此可以表示4种状态，这4种状态分别表示乘数为1.2、4、8<br><img src="%E5%9B%BE3.jpg" alt="SIB">  </p></li><li><p>Displacement：辅助Mode R/M，计算地址偏移<br>Displacement用于辅助SIB，如MOV EAX,DWORD PTR DS:[EBX+ECX*2+3]这条指<br>令，其中的“+3”是由Displacement来指定的  </p></li><li><p>Immediate：立即数<br>用于解释指令语句中操作数为-一个常量值的情况  </p></li></ol><h1 id="第二章-C-反汇编揭秘"><a href="#第二章-C-反汇编揭秘" class="headerlink" title="第二章 C++反汇编揭秘"></a>第二章 C++反汇编揭秘</h1><h2 id="浮点数的编码方式"><a href="#浮点数的编码方式" class="headerlink" title="浮点数的编码方式"></a>浮点数的编码方式</h2><p>float类型在内存中占4字节(32 位)。最高位用于表示符号;在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如图  </p><p><img src="%E5%9B%BE4.jpg" alt="float类型二进制存储">  </p><p>在进行二进制转换前，需要对单精度浮点数进行科学记数法转换。例如，将float类型的12.25f转换为IEEE编码，需将12.25f转换成对应的二进制数1100.01,整数部分为1100,小数部分为01 ;小数点向左移动，每移动1次指数加1，移动到除符号位的最高位为1处，停止移动，这里移动3次。对12.25f进行科学记数法转换后二进制部分为1.10001，指数部分为3。在IEEE编码中，由于在二进制情况下，最高位始终为1，为一个恒定值，故将其忽略不计。这里是一个正数，所以符号位添0  </p><p>所以，转换为:  </p><ul><li>符号位: 0  </li><li>指数位：十进制3+127，转换为二进制是10000010  </li><li>尾数位：10001000000000000000000  </li></ul><p>这里指数位+127是因为指数可能出现负数，127的二进制表示为01111111，规定当指数域小于01111111时为一个负数，反之为正数，因此01111111为0  </p><p>12.25f转换后的IEEE编码按二进制拼接为010000010100010000000000000000。转换<br>成十六进制数为0x41440000,内存中以小尾方式进行排列，故为00 00 44 41  </p><p>浮点数-0.125f转换IEEE编码后，将会是一一个符号位为1,指数部分为负的小数。-0. 125f经转换后二进制部分为0.001,用科学记数法表示为1.0，指数为-3  </p><p>所以转换结果为:  </p><ul><li>符号位: 1  </li><li>指数位：十进制(-3)+127，转换为二进制是01111100  </li><li>尾数位：00000000000000000000000  </li></ul><p>上面的两个浮点数小数部分转换为二进制时都是有穷的，如果小数部分转换为二进制时得到一个无穷值，则会根据尾数部分的长度舍弃多余的部分。单精度浮点数1.3f,小数部分转换为二进制就会产生无穷值，依次转换为: 0.3、0.6、 1.2、 0.4、 0.8、1.6、1.2、0.4、0.8…转换后得到的二进制数为1.01001100110011001100110,到第23位终止，尾数部分无法保存更大的值  </p><p>转换结果为：  </p><ul><li>符号位: 0  </li><li>指数位：十进制(0)+127，转换为二进制是01111111  </li><li>尾数位：01001100110011001100110  </li></ul><h2 id="基本的浮点数指令"><a href="#基本的浮点数指令" class="headerlink" title="基本的浮点数指令"></a>基本的浮点数指令</h2><p>浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1)。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0) 中的数据将装入ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表2-1所示，其中，IN表示操作数人栈，OUT 表示操作数出栈  </p><p><img src="%E5%9B%BE6.jpg" alt="常用浮点数指令表">  </p><pre><code>类型转换函数_ftol的实现  ;保存环境，预留语句变量空间0040E688  push  ebp0040E689  mov   ebp,esp0040E68B  add   esp,0f4h  ;浮点异常检查、CPU与FPU的同步工作0040E68E  wait0040E68E  fnstcw  word ptr [ebp-2]0040E692  wait0040E693  mov   ax,word ptr [ebp-2]0040E697  or    ah, 0Ch0040E69A  mov   word ptr [ebp-4] ,ax0040E69E  fldcw  word ptr [ebp-4]  ;从ST(0)中取出8字节数据转换成整型并存入ebp-0Ch中;将ST(0)从栈中弹出0040E6A1  fistp  qword ptr [ebp-0Ch]0040E6A4  fldcw  word ptr [ebp-2];使用eax保存整型数据的低4字节，用于返回0040E6A7  mov   dword ptr [ebp-0ch];使用edx保存整型数据的高4字节，用于返回0040E6AA  mov   edx,dword ptr [ebp-8];释放栈0040E6AD  leave0040E6AE  ret</code></pre><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>ASCII使用GB2312-80，又叫汉字国标码，保存了6763个常用汉字编码，用两个字节来表示一个汉字。在GB2312-80中用区和位来定位，第一个字节保存每个区，共94个区;第二个字节保存每个区中的位，共94位。详细信息可查看GB2312-80编码的说明  </p><p>Unicode使用UCS-2编码格式，最多可存储65536个字符。汉字博大精深，其中有简体字、繁体字，以及网络中流行的火星文，它们的总和远远超过了UCS-2的存储范围，所以UCS-2编码格式中只保存了常用字。为了将所有的汉字都容纳进来，Unicode也采用了与ASCII类似的方式一用 两个Unicode编码解释一个汉字，称之为UCS-4编码格式。UCS-2编码表的使用和ASCII码表的使用是一样的。每个数字编号在表中对应-一个汉字，从0x4E00到0x9520为汉字编码区。例如，在UCS-2中，“烫”字的编码为0x70EB  </p><p>C++使用结束符\O’作为字符串结束标志。ASCII编码使用一个字节“0’,Unicode编码使用两个字节\0’。需要注意的是，<strong>不能使用处理ASCII编码的函数对Unicode编码进行处理</strong>，因为如果Unicode编码中出现了只占用1字节的字符，就会发生解释错误  </p><h2 id="地址、指针和引用"><a href="#地址、指针和引用" class="headerlink" title="地址、指针和引用"></a>地址、指针和引用</h2><h3 id="指针和地址的区别"><a href="#指针和地址的区别" class="headerlink" title="指针和地址的区别"></a>指针和地址的区别</h3><p>在32位操作系统下，地址是一个由32位二进制数字组成的值。为了便于查看，转换成十六进制数字进行显示，用于标识内存编号。指针是用于保存这个编号的-种变量类型，它包含在内存中，所以可以取出指针类型变量在内存中的位置一地址。 由于指针保存的数据都是地址，所以<strong>无论什么类型</strong>的指针都占据<strong>4字节</strong>的内存空间，如图  </p><p><img src="%E5%9B%BE7.jpg" alt="指针和地址">  </p><p>指针可以根据指针类型对地址对应的数据进行解释。而一个地址值无法单独解释数据,对于图中0x0012FF68这个地址值，仅仅凭借它自己无法说明该地址处对应数据的信息。如果是在一个int 类型的指针中保存这个地址，就可以将0x0012FF68这个地址值看做是int类型数据的起始地址，向后数4字节到0x0014FF6C处。将0x0012FF68 ~0x0014FF6C中的数据按整型存储方式解释  </p><p><img src="%E5%9B%BE8.jpg" alt="指针和地址之间的不同点"><br><img src="%E5%9B%BE9.jpg" alt="指针和地址之间的不同点"><br><img src="P10.jpg" alt="指针和地址之间的共同点">  </p><h3 id="各类指针的工作方式"><a href="#各类指针的工作方式" class="headerlink" title="各类指针的工作方式"></a>各类指针的工作方式</h3><p>不同指针的源码：</p><pre><code>// C++源码对比，定义int类型变量，初始化为0x12345678int nVar = 0x12345678;;为地址赋值4字节数据12345678h0040EB1D  mov   dword ptr [ebp-10h],12345678h// C++源码对比，定义int类型指针变量，初始化为变量nVar地址int *pnVar = &amp;nVar;0040EB24  lea   ecx,[ebp-10h]0040EB27  mov   dword ptr [ebp-14h],ecx  // C++ 源码对比，定义char类型指针变量， 初始化为变量nvar地址char *pcVar = (char*) &amp;nVar;0040EB2A  lea   edx,[ebp-10h]0040EB2D  mov   dword ptr [ebp-1ch],eax  // C++源码对比，定义short类型的指针变量，初始化为变量nVar地址short *psnVar = { short*) &amp;nVar ;0040EB30  lea   eax,[ebp-10h]  0040EB33  mov   dword ptr [ebp-1Ch],eax  //C++源码对比，取出指针pnVar指向的地址内容并显示printf(&quot;%08x \r\n&quot;，*pnVar) ;;取出pnVar中保存的地址值并放入ecx中0040EB36  mov   ecx,dword ptr [ebp-14h];从ecx保存的地址中，以4字节方式读取数据，存入edx中0040EB39  mov   edx,dword ptr [ecx]pcVar 以1字节的方式读取数据存入ecx中psnVar 以2字节的方式读取存入eax中</code></pre><p>指针类型只支持加法和减法，指针进行运算后，指针内保存的地址值的增加或减少取决于<strong>指针类型</strong>，如int类会使地址值的变换是4  </p><p>type *P;//这里用type泛指某类型的指针s<br>p+n的目标地址=首地址+ sizeof( 指针类型type) * n  </p><p>两指针相减可以得到数组长度  </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++将指针操作进行了封装，产生了引用类型<br>引用通过编译器寻址，而指针需要手动寻址  </p><pre><code>void Add (int &amp;nVar) {;在Debug版中添加汇编代码略nVar++;     // C++源码对比，对引用类型nVar执行++操作;取出参数nVar中的内容放入eax中00401078  mov   eax,dword ptr [ebp+8]  ;对eax执行取内容操作0040107B  mov   ecx,dword ptr [eax]0040107D  add   ecx,100401080  mov   edx,dword ptr [ebp+8]00401083  mov   dword ptr [edx],ecx}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h3><p>#define是一个真常量，而const是由<strong>编译器判断</strong>的假常量，实际上，const定义的变量，终究还是一个变量，只是在编译器内进行了检查，发现有修改则报错  </p><p>所以可以修改const常量，通过指针获取const常量的地址，强制将指针的const修饰去掉，就可以修改对应的数据内容  </p><pre><code>// C++源码对比，将变量nConst修饰为constconst int nConst = 5;;将地址ebp-4赋值给4字节数据5004010B8  mov   dword ptr [ebp-4],5// C++源码对比，定义int类型的指针，保存nConst地址int *pConst = (int*) &amp;nConst ; ;获取ebp-4地址并存入eax中004010BF  lea   eax,[ebp-4];将eax中的数据赋值到地址ebp-8处004010C2  mov   dword ptr [ebp-8],eax// C++源码对比，修改指针pConst并指向地址中的数据*pConst = 6;;荻取地址ebp-8中的数据并存入ecx004010C5  mov   ecx,dword ptr [ebp-8];将地址ebp-8中保存的数据修改为6004010C8  mov   dword ptr [ecx],6// C++源码对比，将修饰为const的变量nConst腻值给nVarint nVar = nConst ;;将5赋值到地址ebp-0Ch处00401OCE  mov   dword ptr [ebp-0ch],5</code></pre><p>最后的直接赋值5是编译器做出了优化</p><p><img src="P11.jpg" alt="#define与const的区别"></p><h1 id="第三章-认识启动函数，找到用户入口"><a href="#第三章-认识启动函数，找到用户入口" class="headerlink" title="第三章 认识启动函数，找到用户入口"></a>第三章 认识启动函数，找到用户入口</h1><h2 id="程序真正入口"><a href="#程序真正入口" class="headerlink" title="程序真正入口"></a>程序真正入口</h2><p>main或WinMain函数应该是“语法规定的用户入口”，而不是“应用程序入口”。在应用程序被操作系统加载时，操作系统会分析执行文件内的数据，分配相关资源，读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实<strong>并不是main或WinMain</strong>，通常是<strong>mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup</strong>，具体视编译选项而定。其中<strong>mainCRTStartup和wmainCRTStartup</strong>是控制台环境下多字节编码和Unicode编码的启动函数，而<strong>WinMainCRTStartup和wWinMainCRTStartup</strong>则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定入口  </p><h2 id="VC-6-0的启动函数"><a href="#VC-6-0的启动函数" class="headerlink" title="VC++6.0的启动函数"></a>VC++6.0的启动函数</h2><p>VC++6.0在控制台和多字节编码环境下的启动函数为<strong>mainCRTStartup</strong>，由系统库<strong>KERNEL32.dll</strong>负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处  </p><pre><code>void mainCRTStartup (#endif /* WPRFLAG */#endif /* _WINMAIN_ */    void){    //荻取版本信息    _osver = GetVersion();    _winminor = (_osver &gt;&gt; 8) &amp; 0x00FF;    _winmajor = _ osver &amp; 0x00FF;    _winver = (_ winmajor &lt;&lt; 8) + _winminor;    _osver = (_osver &gt;&gt; 16) &amp; 0x00FFFF;    // 堆空间初始化过程，在此函数中，指定了程序中堆空间的起始地址    // _MT是多线程标记#ifdef _MT    if ( ! _heap_ init(1) )#else /* _MT */    if ( !_ heap_ init(0) )#endif /* _MT */    fast_error_ exit(_RT_HEAPINIT);    //初始化多线程环境#ifdef _MT    if( !_ mtinit() )        fast_error_exit(_RT_THREAD);#endif /* _MT */    _try {        // 宽字符处理代码略        // 多字节版荻取命令行        _acmdln = (char *) GetCommandLineA();    // 多字节版获环境变量信息    _aenvptr = {char *)__crtGetEnvironmentStringsA();    // 多字节版获取命令行信息    _setargv();    // 多字节版荻取环境变量信息    _setenvp();#endif /* WPRFLAG */    // 初始化全局数据和浮点寄存器    _cinit();    // 窗口程序处理代码略    // 宽字符处理代码略    // 获取环境变量信息    _initenv = _environ;    // 调用main函数，传递命令行参数信息    mainret = main(_argc, _argv, _environ);#endif /* WPRFLAG */#endif /* _WINMAIN_ */    // 检查main函数返回值执行析构函数或atexit注册的函数指针，并结束程序    exit (mainret);}// 退出结束代码略</code></pre><ul><li><strong>GetVersion函数</strong>:获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息</li><li><strong>_ heap_ init函数</strong>:用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_heap_init传递的参数决定。_sbh_heap_init函数用于初始化堆结构信息  </li><li><strong>GetCommandLineA函数</strong>:获取命令行参数信息的首地址  </li><li><strong>_crtGetEnvironmentStringsA函数</strong>:获取环境变量信息的首地址  </li><li><strong>_setargv函数</strong>:此函数根据GetCommandLineA获取命令行参数信息的首地址并进行参数分析，将分离出的参数的个数保存在全局变量_arge中，将分析出的每个命令行参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量_argv中。这样就得到了命令行参数的个数，以及命令行参数信息  </li><li><strong>_ setenvp 函数</strong>:此函数根据__crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中  </li></ul><p>得到main函数所需的三个参数信息之后，当调用main函数时，便可以将_ _argc、 _argv、 env这三个全局变量作为参数，以栈传参方式传递到main函数中  </p><ul><li><strong>_cinit函数</strong>:用于全局数据和浮点寄存器的初始化。全局对象和I/O流等的初始化都是通过这个函数实现的。利用函数 <em>itterm 进行数据链初始化，这个函数由两个参数组成，类型为“_PVFV*”,这是一个函数指针数组，其中保留了每个初始化函数的地址。初始化函数的类型为_PVFV, 其定义原型如下:<br>typedef void (</em> cdec1 * _PVFV) (void);<br>也就是说，这个初始化函数是无参数也无返回值的，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的，具体如下所示：  </li></ul><pre><code>// 用于初始化寄存器if (_FPinit != NULL)  (*_ FPinit) (); //初始化浮点寄存器// 用于初始化C语法中的数据_initterm( _xi_a, _xi_z );// 用于初始化C++语法中的数据_initterm( _XC_a, _XC_z );</code></pre><p><strong>FPinit</strong> 是一个全局函数指针，类型也是_PVFV, 如果编译器扫描代码时发现有浮点计算，则此指针保存了初始化浮点寄存器的代码地址，否则为0值。如果浮点寄存器未被初始化而进行浮点计算，程序会产生异常或错误，这类错误应属于VC++ 6.0自身设计的Bug,在VC++6.0以后的版本中已将其修复。一般而言，第一个_initterm 初始化的都是C支持库中所需的数据。参数_xi_a 为函数指针数组的起始地址，_xi_z为结束地址。 _initterm 的实现：  </p><pre><code>static void__ cdec1 initterm (    _PVFV * pfbegin,    _PVFV * pfend){    // 遍历数组的各元素    while ( pfbegin &lt; pfend )    {        // 若函数指针不为空，则执行该函数        if ( *pfbegin != NULL )            (**pfbegin) () ;        ++pfbegin;    }}</code></pre><p>在默认情况下，入口函数为main,这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置人口函数，依次选择菜单Procject→Settings →Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称。编译后调试程序，结果如图所示  </p><p><img src="P12.jpg" alt="重设入口函数">  </p><p>由于没有调用mainCRTStartup函数，所以<strong>堆空间没有被初始化</strong>，当使用堆空间时，程序会报错崩溃  </p><h2 id="识别main函数"><a href="#识别main函数" class="headerlink" title="识别main函数"></a>识别main函数</h2><p>main函数有如下特征是:它有3个参数，分别为命令行参数个数、命令行参数信息和环境变量信息，而且它是启动函数中唯一的具有3个参数的函数。同理，WinMain 也是启动函数中唯一的具有4个参数的函数  </p><pre><code>;省略部分代码; O1lyDBG识别出的函数名称为GetCommandLineA00401210  |. FF15 38514200   call dword ptr ds: [&lt; &amp;KERNEL32.GetCommand&gt;;得到命令行参数00401216  |. A3 444F4200    mov dword ptr ds: [424F44] , eax;根据main函数特性，此处为函数_crtGetEnvironmentStringsA() 调用0040121B  |. E8 E0240000    call ProgramE.0040370000401220  |. A3 BC354200    mov dword ptr ds: [4235BC] , eax;根据main函数特性，此处为函数_setargv()调用00401225  |. E8 C61F0000    call ProgramE.004031F0;根据main函数特性，此处为函数cinit()调用0040122F  |. E8 8C1A0000    call ProgramE.00402CC000401234  |. 8B0D 00364200  mov ecx, dword ptr ds: [423600]0040123A  |. 890D 04364200  mov dword ptr ds: [423604] , ecx00401240  |. 8B15 00364200  mov edx, dword ptr ds: [423600] ;压栈传参，环境变量信息00401246  |. 52             push edx00401247  |. Al F8354200    mov eax, dword ptr ds: [4235F8];压栈传参，命令行参数信息0040124C  |. 50             push eax0040124D  |. 8BOD F4354200  mov ecx, dword ptr ds; [4235F4];压栈传参，命令行参数个数00401253  |. 51             push ecx;此处为main函数的调用处，跟进到函数中便是main函数的实现代码流程00401254  |. E8 ACFDFFFF    call ProgramE.00401005</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《C++反汇编与逆向分析技术》&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.kittener.top/2020/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-19T13:49:04.000Z</published>
    <updated>2020-06-09T15:19:21.538Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完</p><a id="more"></a><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ol><li>方便性  </li><li>有效性<br>有效性的第一层含义是提高系统资源的利用率。另一层含义是，提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。  </li><li>可扩充性<br>OS从早期的无结构发展称模块化结构，进而发展成层次化结构，近年来广泛采用了微内核结构，具有良好的可扩充性。  </li><li>开放性<br>指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。  </li></ol><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ol><li>OS作为用户与计算机硬件系统之间的接口<br>用户通过命令方式、系统调用方式和图标——窗口方式来实现与操作系统的通信  </li><li>OS作为计算机系统资源的管理者<br>OS中的资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）  </li><li>OS实现了对计算机资源的抽象<br>OS是铺设在计算机硬件上的多层软件的集合，不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。  </li></ol><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol><li>处理过程<br>简单来说就是将作业装在磁带上，一个一个单个处理，如图：<br><img src="%E5%9B%BE1.jpg" alt="单道批处理系统">  </li><li>缺点<br>资源得不到充分利用，如图：<br><img src="%E5%9B%BE2.jpg" alt="运行情况">  </li></ol><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ol><li>处理过程<br>用户所提交的作业先放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。  </li><li>优缺点<br>（1）资源利用率高<br>（2）系统吞吐量大<br>（3）平均周转时间长<br>（4）无交互能力  </li></ol><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ol><li>运行方式  </li></ol><ul><li>作业直接进入内存  </li><li>采用轮转运行方式（加入时间片）  </li></ul><ol start="2"><li>特征  </li></ol><ul><li>多路性：系统允许将多台终端同时链接到一台主机上  </li><li>独立性：系统提供了这样的用户各自独立环境  </li><li>及时性：用户的请求很短时间内能得到相应  </li><li>交互性：用户可通过终端进行人机对话  </li></ul><h2 id="操作系统的种类"><a href="#操作系统的种类" class="headerlink" title="操作系统的种类"></a>操作系统的种类</h2><ul><li>单用户单任务操作系统  </li><li>单用户多任务操作系统  </li><li>多用户多任务操作系统  </li></ul><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol><li>并行与并发  </li></ol><ul><li>并行性是指两个或多个事件在同一时刻发生  </li><li>并发性是指两个或多个事件在统一时间间隔内发生  </li></ul><ol start="2"><li>引入进程  </li></ol><ul><li>进程是指：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。  </li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ol><li>互斥共享方式<br>一个进程访问完资源后，资源才能被另一个进程访问。资源叫做<strong>临界资源</strong>    </li><li>同时访问方式  </li></ol><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在os中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为<strong>虚拟</strong>。  </p><ol><li>时分复用技术（时间）  </li><li>空分复用技术（空间）  </li></ol><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ol><li>进程控制：为作业创建进程、撤销（终止）已结束的进程，以及控制进程在运行过程中的状态转换。  </li><li>进程同步：  </li></ol><ul><li>进程互斥方式：指诸进程在对临界资源进行访问时，应采用互斥方式  </li><li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。  </li></ul><ol start="3"><li>进程通信：通常采用直接通信方式，由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接受命令从其消息队列中取出消息  </li><li>调度  </li></ol><ul><li>作业调度：从后备队列中按一定算法取出若干队列。为其分配运行所需资源。</li><li>进程调度：从就绪队列中按照一定的算法选出一个进程，执行。</li></ul><h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ol><li>内存分配  </li></ol><ul><li>静态分配方式：每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间。</li><li>动态分配方式：允许申请新的空间。  </li></ul><ol start="2"><li>内存保护：每个程序互不打扰，操作系统的程序和数据不允许访问。</li><li>地址映射  </li><li>内存扩充  </li></ol><ul><li>请求调入功能：将程序所需部分从存储器中调入内存</li><li>置换功能：将内存和磁盘的数据进行置换  </li></ul><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol><li>共享存储器系统  </li></ol><ul><li>基于共享数据结构的通信方式。</li></ul><h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol><li>高级调度<br>调度对象是作业，其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为其创建进程、分配资源，放入就绪队列，主要应用于多道批处理系统  </li><li>低级调度<br>又称为进程调度或短程调度，其调度对象是进程(或内核级线程)。其主要功能是根据某种算法决定就绪队列中的哪个进程应获得处理机。</li><li>中级调度<br>提高内存利用率和系统吞吐量，把暂时不能运行的进程调至外存，把能运行的调至内存。  </li></ol><h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol><li>处理机调度算法的共同目标<br>(1)<strong>资源利用率</strong> CPU的利用率 = CPU的有效工作时间/(CPU的有效工作时间+CPU的空闲等待时间)<br>(2)<strong>公平性</strong> 每个进程都应该获得合理的CPU时间<br>(3)<strong>平衡性</strong> 尽可能保持系统资源使用的平衡性<br>(4)<strong>策略强制执行</strong> 对所制订的策略，保证其准确执行  </li><li>批处理系统的目标<br>(1)<strong>平均周转时间短</strong><br>(2)<strong>系统吞吐量高</strong><br>(3)<strong>处理机利用率高</strong>  </li><li>分时系统的目标<br>(1)<strong>响应时间快</strong><br>(2)<strong>均衡性</strong>  </li><li>实时系统的目标<br>(1)<strong>截止时间的保证</strong><br>(2)<strong>可预测性</strong>  </li></ol><h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><ol><li>作业与作业步<br>(1)作业。不仅包含通常的程序和数据，还包括一份作业说明书，再批处理系统中，作业为基本单位从外存调入内存<br>(2)作业步。每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。每个步骤叫做一个作业步。  </li><li>作业的三种状态和三个阶段  </li></ol><ul><li>收容阶段，操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。(后备状态)</li><li>运行阶段(运行阶段)  </li><li>完成阶段(完成阶段)  </li></ul><ol start="3"><li>先来先服务和短作业优先调度算法  </li></ol><ul><li>先来先服务调度算法(FCFS)  </li><li>短作业优先调度算法(SJF):作业越短优先级越高  </li><li>优先级调度算法(PSA):外部赋予作业优先级  </li><li>高响应比优先调度算法(HRRN):优先权 = (等待时间+要求服务时间)/要求服务时间  </li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol><li>非抢占方式<br>一旦处理机分配给某进程后，就一直让它运行下去，不会因为时钟中断而被抢占。<br>可能引起进程调度的因素：  </li></ol><ul><li>程序执行完毕，或发生某种事件使程序无法执行  </li><li>I/O请求  </li><li>原语操作如Block<br>不适用于分时系统和大多数实时系统  </li></ul><ol start="2"><li>抢占方式<br>允许调度程序根据某一原则暂停执行中的程序，分配处理机给新的进程<br>原则：  </li></ol><ul><li>优先权原则：高优先级先运行  </li><li>短进程优先原则</li><li>时间片原则：时间片用完就暂停执行  <h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3>就绪队列上的每个进程每次仅运行一个时间片。  </li></ul><ol><li><strong>原理</strong><br>系统将所有的就绪进程按FCFS策略排成一个就绪队列。  </li><li><strong>进程切换时机</strong>  </li></ol><ul><li>执行完成</li><li>时间片用完，计时器中断处理程序被激活  </li></ul><ol start="3"><li><strong>时间片大小的确定</strong><br>略大于典型交互时间  <h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3></li><li><strong>类型</strong>  </li></ol><ul><li>非抢占式优先级调度算法：一旦处理机分配给了优先级最高的进程，则一直执行下去直至完成。</li><li>抢占式优先级调度算法：出现了更高优先级的进程，中断当前执行进程，转而去执行更高优先级的进程。  </li></ul><ol start="2"><li>优先级的类型  </li></ol><ul><li>静态优先级：进程运行过程中优先级保持不变  </li><li>动态优先级：随着时间增加而改变  <h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3>将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的算法。<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3></li></ul><ol><li>调度机制  </li></ol><ul><li>设置多个就绪队列，每个队列不同的优先级不同的时间片大小，在优先级愈高的队列中，其时间片就越小。  </li><li>每个队列采用FCFS算法。</li><li>按队列优先级调度。 <h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3></li></ul><ol><li>保证调度算法<br>这里的保证并不是优先运行，而是性能保证。</li></ol><ul><li>跟踪计算每个进程自创建以来已经执行的处理时间</li><li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n  </li><li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比  </li><li>比较各进程获得处理机时间的比率</li><li>选择比率最小的进程将处理机分配给它，知道超过最接近它的进程比率</li></ul><ol start="2"><li>公平分享调度方法<br>对用户公平  </li></ol><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol><li>提供必要的信息<br>(1)就绪时间<br>(2)开始截止时间和完成截止时间<br>(3)处理时间<br>(4)资源要求<br>(5)优先级  </li><li>系统处理能力强  </li><li>采用抢占式调度机制  </li><li>具有快速切换机制<br>(1)对中断的快速响应能力<br>(2)快速的任务分派能力  <h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li><li>非抢占式调度算法</li></ol><ul><li>非抢占式轮转调度算法  </li><li>非抢占式优先调度算法  </li></ul><ol start="2"><li>抢占式调度算法  </li></ol><ul><li>基于时钟中断的抢占式优先级调度算法</li><li>立即抢占的优先级调度算法  </li></ul><h3 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h3><p>任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。  </p><h3 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h3><p>松弛度 = 必须完成的时间 - 其本身的运行时间 - 当前时间<br>松弛度低的先运行  </p><h3 id="优先级倒置-priority-inversion-problem"><a href="#优先级倒置-priority-inversion-problem" class="headerlink" title="优先级倒置(priority inversion problem)"></a>优先级倒置(priority inversion problem)</h3><p>低优先级和高优先级的共享一临界资源，就会导致如果低优先级的<strong>先执行</strong>，高优先级在得到处理机后，因为临界资源被<strong>占用</strong>而被<strong>堵塞</strong>，导致低优先级的先执行  </p><ul><li>解决方法：<br>1 低优先级在进入临界区后不允许被抢占<br>2 低优先级继承高优先级的优先级，率先执行完  </li></ul><h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ol><li>可重用资源和消耗性资源  </li></ol><ul><li>可重用资源：一种可供用户重复使用多次的资源，有如下性质：<br>(1)每一个可重用资源中的单元只能分配给一个进程使用，不能共享<br>(2)进程在使用可重用性资源时，必须先请求再使用<br>(3)数目固定，进程在运行期间既不能创建也不能删除  </li><li>可消耗资源：在进程运行期间，由进程动态创建和消耗  </li></ul><ol start="2"><li>可抢占性资源和不可抢占资源  </li></ol><h3 id="计算机中的死锁"><a href="#计算机中的死锁" class="headerlink" title="计算机中的死锁"></a>计算机中的死锁</h3><ul><li>竞争不可抢占性资源引起死锁</li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁  </li></ul><h3 id="死锁的定义、必要条件和处理方法"><a href="#死锁的定义、必要条件和处理方法" class="headerlink" title="死锁的定义、必要条件和处理方法"></a>死锁的定义、必要条件和处理方法</h3><ol><li>定义：如果一组进程中的每一个进程都在等待仅有该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</li><li>产生死锁的必要条件<br>(1)互斥条件。进程对所分配道德资源进行排他性使用<br>(2)请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有<br>(3)不可抢占条件<br>(4)循环等待条件  </li><li>处理死锁的方法<br>(1)预防死锁：通过设置某些限制条件，去破坏一个进程<br>(2)避免死锁：用某种方法防止系统进入不安全状态，从而可以避免发生死锁<br>(3)检测死锁：通过检测机构及时检测出死锁发生，采取适当措施<br>(4)解除死锁：撤销进程，回收资源  </li></ol><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><ol><li>第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需地全部资源。这样就避免了资源”请求”条件。</li><li>第二种协议：允许一个进程只获得运行储器所需资源后，便开始运行。进程运行过程中在逐步释放已分给自己的、且已用毕地全部资源，然后再请求新的所需资源  <h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3>当一个已经保持了某些不可被抢占资源地进程，提出新的资源请求而得不到满足时，它必须释放已经保持地所有资源，待以后需要时再重新申请  <h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3>对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增地顺序请求资源。一个进程在开始时可以请求Ri的资源，以后当且仅当F(Rj)&gt;F(Ri)的时候才可以请求Rj的资源  </li></ol><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul><li>安全状态<br>所谓的安全状态是指系统能按某种进程推进顺序(P1,P2,···,Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成  <h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><a href="https://blog.csdn.net/qq_36260974/article/details/84404369" target="_blank" rel="noopener">银行家算法</a>  </li></ul><h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储器结构"><a href="#多层结构的存储器结构" class="headerlink" title="多层结构的存储器结构"></a>多层结构的存储器结构</h3><p>可执行存储器：寄存器和主存储器<br>主存储器：内存或主存，用于保存进程运行时的程序和数据<br>寄存器：具有与处理机相同的速度  </p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序，需经过如下步骤：</p><ul><li>编译，有编译程序对用户源程序进行编译，形成若干个目标模块  </li><li>链接，由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块  </li><li>装入，由装入程序将装入模块装入内存  <h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3>有三种装入方式：  </li></ul><ol><li>绝对装入方式  </li><li>可重定位装入方式  </li><li>动态运行时的装入方式<br>装入程序把装入模块装入后，并不立即把装入模块中的逻辑地址转换为物理地址，而是等到运行时才进行  </li></ol><h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ol><li>静态链接方式<br>在程序运行之前，先将各目标模块及他们所需的库函数链接成一个完整的装配模块，以后不在拆开。<br>(1)对相对地址进行修改。在编译程序所产生的所有目标模块中，使用的都是相对地址。<br>(2)变换外部调用符号  </li><li>装入时动态链接方式<br>指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。<br>有以下优点：<br>(1)便于修改和更新<br>(2)便于实现对目标模块的共享  </li><li>运行时动态链接<br>对某些模块的链接推迟到程序执行时才进行  <h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2>为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻  <h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3>把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常时放在内存的低址部分。而在用户区中，仅装有一道用户程序  <h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3>将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业  </li><li>划分分区的方法<br>(1)分区大小相等<br>(2)分区大小不等  </li><li>内存分配<br>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态  </li></ol><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol><li>动态分区分配中的数据结构  </li></ol><ul><li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等数据项  </li><li>空闲分区链：每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针  </li></ul><ol start="2"><li>分区分配操作  </li></ol><ul><li>分配内存</li><li>回收内存  </li></ul><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><ol><li>首次适应算法(FF)<br>FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按作业大小，从该分区划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中<br>该算法倾向于优先利用内存中的低址部分的空闲分区，从而保留高址部分的大空闲区  </li><li>循环首次适应算法(NF)<br>为了避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找  </li><li>最佳适应算法(BF)<br>将所有空闲分区按其容量以从小到大的顺序形成一空闲分区链  </li><li>最坏适应算法(WF)<br>将所有空闲分区按其容量以从大到小顺序形成一空闲分区链，每次挑选最大的从中分割一部分给作业使用  </li></ol><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><ol><li>快速适应算法(QF)<br>分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针<br>搜索时分为两步：(1)根据进程长度，从索引表中寻找能容纳它的最小空闲区链表;(2)从链表中取下第一块进行分配即可<br>缺点是在分区归还主存时算法复杂，一个分区只给一个进程容易浪费  </li><li>伙伴系统(buddy system)<br>无论已分配分区或空闲分区，其大小均为2的k次幂。分配时找2的i次方，合并时一样  </li><li>哈希算法<br>利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张一空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针  </li></ol><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>动态重定位<br>程序在执行时，真正访问的内存地址时相对地址与重定位寄存器中的低址相加而形成的，动态重定位分区与动态分区算法除了增加了”紧凑”功能外基本上相同  </li></ol><h2 id="对换-Swapping"><a href="#对换-Swapping" class="headerlink" title="对换(Swapping)"></a>对换(Swapping)</h2><h3 id="多道程序环境下的对换技术"><a href="#多道程序环境下的对换技术" class="headerlink" title="多道程序环境下的对换技术"></a>多道程序环境下的对换技术</h3><ol><li>对换技术：<br>在系统中设置一个对换进程，由它将内存中暂时不能运行的进程调出到磁盘的对换区;同样也由该进程将磁盘上已具备运行条件的进程调入内存  </li><li>对换的类型：  </li></ol><ul><li>整体对换:以整个进程为单位对换  </li><li>页面(分段)对换:以一个”页面”或”分段”为单位进行对换  <h3 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h3></li></ul><ol><li>对换空间管理的主要目标<br>(1)对文件区管理的主要目标<br>提高文件存储空间的利用率，然后提高对分及的访问速度，因此，对文件区空间的管理采取离散分配方式<br>(2)对对换空间管理的主要目标<br>提高进程换入和换出速度，然后提高文件存储空间的利用率，因此对对换空间的管理采取连续分配方式  </li><li>对换区空闲盘块管理中的数据结构<br>可以用空闲分区表或空闲分区链，每个表目中包含两项:对换区的首地址及其大小，分别用盘块号和盘块数表示  </li><li>对换空间的分配与回收<br>与动态分区一样  <h3 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h3></li><li>进程的换出<br>(1)选择被换出的进程<br>(2)进程换出过程  </li><li>进程的换入<br>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出”就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程  </li></ol><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><ol><li><p>页面与物理块<br>(1)页面<br>分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号，内存的物理低址空间分为若干块，同样也为它们加以编号。为进程分配内存时，以块为单位，将进程中的若干个页分别装入到若干个可以不相邻接的物理块中。<br>(2)页面大小  </p></li><li><p>地址结构<br>分页地址包含两部分内容：前一部分为页号P，后一部分为位(偏)移量W，即页内地址  </p></li><li><p>页表<br>分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表  </p></li></ol><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号  </p><ol><li>基本的地址变换机构<br>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间，若未出现错误，则将页表始址与页号和页表项长度的成绩相加，则得到该表项在页表中的位置  </li><li>具有快表的地址变换机构<br>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为”联想寄存器”，或称为”快表”<br>在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中  </li></ol><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经给地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间(EAT)  </p><h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>32位系统中页表可能会很大，所以有两个方法解决问题:<br>(1)对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题<br>(2)只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入  </p><ol><li>两级页表<br>将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中<br>为离散分配的页表再建立一张页表，称为<strong>外层页表</strong>，在每个页表项中记录了页表页面的物理块号  </li><li>多级页表  </li></ol><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>为每一个物理块设置一个页表项，并将它们按物理块的序号排序，其中的内容则是页号和其所隶属进程的标识符<br>在利用反置页表进行地址变换时，是根据进程标识符和页号，取检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器  </p><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul><li>方便编程  </li><li>信息共享  </li><li>信息保护  </li><li>动态增长  </li><li>动态链接  <h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3></li></ul><ol><li>分段<br>在分段存储管理方式中，作业的地址空间被划分为若干段，每个段定义了一组逻辑信息，即每个段既包含了一部分地址空间，又标识了逻辑关系，其逻辑地址由段号和段内地址所组成  </li><li>段表<br>在分段式存储管理系统中，为每个分段分配一个连续的分区，进程中的各个段，可以离散地装入内存中不同的分区中，然后建立一个段映射表，<em>段表</em>  </li><li>地址变换机构<br>段表寄存器和联想寄存器  </li><li>分页和分段的区别  </li></ol><ul><li>页是信息的物理单位  </li><li>页的大小固定且由系统决定  </li><li>分页的用户程序地址空间是一维的  </li></ul><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol><li>基本原理<br>先将程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名，系统中需要同时配置段表和页表，段表的内容与分段系统略有不同，是页表始址和页表长度  </li><li>地址变换过程<br>首先利用段号S，将它与段长TL进行比较。若S &lt; TL, 表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址  </li></ol><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>因为实际运行作业的时候可能会出现:  </p><ol><li>有的作业很大  </li><li>有大量作业要求运行<br>出现上述情况的原因都是内存容量不够大，所以从逻辑上扩充内存容量  <h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><h3 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h3></li><li>常规存储器管理方式的特征  </li></ol><ul><li>一次性，是指作业必须一次性地全部装入内存后方能开始运行  </li><li>驻留性，是指作业被装入内存后，整个作业都一直驻留再内存中，其中任何部分都不会被换出，直至作业运行结束  </li></ul><ol start="2"><li>局部性原理<br>程序在执行时将呈现出局部性规律，即在一较短地时间内，程序的执行仅局限于某个部分，相应地，它访问的存储空间也局限于某个区域  <h3 id="虚拟存储器地定义和特征"><a href="#虚拟存储器地定义和特征" class="headerlink" title="虚拟存储器地定义和特征"></a>虚拟存储器地定义和特征</h3></li><li>定义<br>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充地一种存储器系统  </li><li>虚拟存储器的特征  </li></ol><ul><li>多次性：指一个作业中的程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行  </li><li>对换性：指一个作业中地数据和程序，无须在作业运行时一直常驻内存，而是允许在作业的运行过程中进行换进、换出  </li><li>虚拟性：指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量  <h3 id="虚拟存储器地实现方法"><a href="#虚拟存储器地实现方法" class="headerlink" title="虚拟存储器地实现方法"></a>虚拟存储器地实现方法</h3></li></ul><ol><li>分页请求系统<br>是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统<br>(1)硬件支持：请求分页的页表机制、缺页中断机制、地址变换机构<br>(2)实现分页请求的软件：包括有用于实现请求调页的软件和实现页面置换的软件  </li><li>请求分段系统<br>是在分段系统的基础上，增加了请求调段及分段置换后所形成的段式虚拟存储系统  <h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3></li><li>请求页表机制<br>每个页表应该包含页号、物理块号、状态位、访问字段A、修改位M、外存地址  </li></ol><ul><li>状态位P:用于指示该页是否已经调入内存  </li><li>访问字段A:用于记录本页在一段时间内被访问的次数  </li><li>修改位M:标识该页在调入内存后是否被修改过  </li><li>外存地址:用于指出该页在外存上的地址  </li></ul><ol start="2"><li>缺页中断机构<br>每当要访问的页面不存在时，便产生一缺页中断，请求OS将所缺之页调入内存，有两个特点:<br>(1)在指令执行期间产生和处理中断信号<br>(2)一条指令在执行期间可能产生多次缺页中断  </li><li>地址变换机构<br><img src="%E5%9B%BE5-2.png" alt="地址变换过程">  </li></ol><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ol><li>最小的物理块数的确定<br>指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行  </li><li>内存分配策略  </li></ol><ul><li>固定分配局部置换:为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，如何再调入一页，然后再调入一夜，以保证分配给该进程的内存空间不变  </li><li>可变分配全局置换:指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当地增加或减少。如果在进程运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块中选出一块换出  </li><li>可变分配局部置换:只允许在该进程的内存页面选择一页换出，若频繁缺页，则增加进程页面  </li></ul><ol start="3"><li>物理块分配算法  </li></ol><ul><li>平均分配</li><li>按比例分配  </li><li>优先权分配  <h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3></li></ul><ol><li>何时调入页面  </li></ol><ul><li>预调页策略</li><li>请求调页策略  </li></ul><ol start="2"><li>从何处调入页面<br>外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区<br>对换区一般采用连续分配方式，文件区一般采用离散分配方式<br>(1)系统拥有足够的对换区空间:<br>这时可以全部从对换区调入所需页面<br>(2)系统缺少足够的对换区空间:<br>不会被修改的文件，直接从文件区调入，会被修改的，须先调到对换区<br>(3)UNIX方式:<br>未运行过的页面，都从文件区调入，对于曾经运行过但又被换出的页面，从对换区调入  </li><li>调入过程<br>先找物理块位置，如果内存未满，调入；已满，置换。被置换的若被修改过，重写进磁盘  </li><li>缺页率<br>访问失败次数/总访问次数  <h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><a href="https://www.cnblogs.com/Leophen/p/11397699.html" target="_blank" rel="noopener">置换算法</a><h3 id="访问内存的有效时间-1"><a href="#访问内存的有效时间-1" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3>(1)被访问页在内存中，且其对应的页表项在快表中<br>EAT = 查找快表的时间+访问实际物理地址的时间<br>(2)被访问页在内存中，且其对应的页表项不在快表中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间<br>(3)被访问页不在内存中<br>EAT = 查找快表的时间+查找页表的时间+修改快表的时间+访问实际物理地址的时间+处理断页中断的时间+更新快表的时间+访问实际物理地址的时间  <h2 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h2><h3 id="多道程序度和”抖动”"><a href="#多道程序度和”抖动”" class="headerlink" title="多道程序度和”抖动”"></a>多道程序度和”抖动”</h3></li><li>多道程序度和处理机的利用率<br>处理机的实际利用率随着进程数的增加而提高，但达到一定数目时开始下降  </li><li>抖动<br>在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求  <h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3>工作集是指，在某段时间间隔里，进程实际所要访问页面的集合  <h3 id="“抖动”的预防办法"><a href="#“抖动”的预防办法" class="headerlink" title="“抖动”的预防办法"></a>“抖动”的预防办法</h3></li><li>采用局部置换策略  </li><li>把工作集算法融入到处理机调度中  </li><li>利用”L=S”准则调节缺页率<br>L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面的时间  </li></ol><ul><li>L &gt;&gt; S，说明很少缺页，磁盘未充分利用  </li><li>L &lt;&lt; S,说明频繁缺页</li><li>L = S，完美  </li></ul><ol start="4"><li>选择暂停的进程  <h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><img src="%E5%9B%BE5-3.png" alt="段表结构">  </li></ol><ul><li>缺段中断机构<br>一条指令不可能被分割在两个分段中<br><img src="%E5%9B%BE5-4.png" alt="中断处理"></li><li>地址变换机构<br><img src="%E5%9B%BE5-5.png" alt="地址变换">  <h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3></li></ul><ol><li>共享段表<br>配置一张共享段表，所有各共享段表中占有一表项。在表项上面记录了共享段的段号、段长、内存始址、状态(存在)位、外存始址以及共享计数等信息  </li></ol><ul><li>共享进程数:显示当前共享该分段的进程数  </li><li>存取控制字段:赋予不同进程不同权限  </li><li>段号:不同的进程有不同的段号  </li></ul><ol start="2"><li>共享段的分配与回收<br>(1)共享段的分配<br>对第一个请求使用该共享段的进程，系统为该共享段分配一物理区，再把共享段调入该区。同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中添加一表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1，之后的count+1，再添加表项<br>(2)共享段的回收<br>撤销进程段表中共享段所对应的表项,count-1  </li><li>分段保护  </li></ol><ul><li>越界检查  </li><li>存取控制检测  </li><li>环保护机构  <h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h3></li></ul><ol><li>中断和陷入  </li></ol><ul><li>中断是指CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，叫做外中断  </li><li>陷入是CPU内部事件引发的中断，如运算溢出，程序出错，称为内中断  </li></ul><ol start="2"><li>中断向量表和中断优先级  </li></ol><ul><li>中断向量表是为每种设备配以中断的不同类，处理的时候直接查表找处理程序</li><li>中断优先级，为每个中断规定不同的优先级  </li></ul><ol start="3"><li>多中断源的处理方式</li></ol><ul><li>屏蔽中断<br>当处理机在处理一个中断时，将屏蔽其他所有中断  </li><li>嵌套中断<br>(1)当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求<br>(2)高优先级的中断请求可以抢占正在运行的低优先级中断的处理机  <h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3></li><li>测定是否有未响应的中断信号  </li><li>保护被中断进程的CPU环境  </li><li>转入相应的设备处理程序  </li><li>中断处理  </li><li>恢复CPU的现场并退出中断：<br>是否会返回到被中断的进程取决于哪个阶段：</li><li>是否采用屏蔽中断方式，若采用则返回  </li><li>采用的是中断嵌套方式，若没有更高优先级的中断，仍被返回被中断进程  <h3 id="对I-O设备的控制方式"><a href="#对I-O设备的控制方式" class="headerlink" title="对I/O设备的控制方式"></a>对I/O设备的控制方式</h3></li></ul><ol><li>采用轮询的可编程I/O方式<br>设置busy标志，输入未完成时为1，完成时为0  </li><li>使用中断的可编程I/O方式<br>CPU和I/O设备可以并行操作  </li><li>直接存储器访问方式  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下《计算机操作系统》这本书，可能以后也会用到，所以一直会更新下去，直到读完&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.kittener.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://www.kittener.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向学习</title>
    <link href="http://www.kittener.top/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.kittener.top/2020/04/17/Android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-17T09:52:25.000Z</published>
    <updated>2020-04-17T15:07:20.189Z</updated>
    
    <content type="html"><![CDATA[<p>这是TG:HACK2020的一道比赛题目<br>题目给的hint很误导人…反正我没看出来  </p><a id="more"></a><blockquote><blockquote><blockquote><p>Hint<br>Random title?  </p></blockquote></blockquote></blockquote><p>这是题目描述：Someone found this very old game lying around. Apparently there is an extremely funny joke in there somewhere.</p><p>之前没怎么做过安卓题目，所以这次真是学到了很多<br>题目的名字叫Bad intentions<br>上Google搜索之后发现是一堆歌曲，好吧这肯定跟题目没啥关系<br>当搜索apk intentions的时候就出现了有用的信息：<br><img src="1.jpg" alt="google搜索结果">  </p><p>所谓的apk intentions就是指这个程序能不能被外部访问，或者进行数据交换  </p><blockquote><blockquote><blockquote><p>Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动 作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的 交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。  </p></blockquote></blockquote></blockquote><p>然后就是如何查看这个apk包中有没有调用intent这个类了<br><code>aapt dump xmltree gaiainvaders.apk AndroidManifest.xml</code></p><blockquote><blockquote><blockquote><p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。  </p></blockquote></blockquote></blockquote><p>关于AndroidManifest.xml这个文件的介绍<a href="https://www.jianshu.com/p/3b5b89d4e154" target="_blank" rel="noopener">点这</a></p><p>就会输出如下信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E: activity (line&#x3D;19)  </span><br><span class="line">    A:android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.GaiaInvadersActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;20)</span><br><span class="line">          E: action (line&#x3D;21)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;23)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br><span class="line">    E: activity (line&#x3D;26)</span><br><span class="line">        A: android:name(0x01010003)&#x3D;&quot;no.tghack.gaiainvaders.JokeActivity&quot; (Raw: &quot;no.tghack.gaiainvaders.JokeActivity&quot;)</span><br><span class="line">        E: intent-filter (line&#x3D;27)</span><br><span class="line">          E: action (line&#x3D;28)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;)</span><br><span class="line">          E: category (line&#x3D;30)</span><br><span class="line">            A: android:name(0x01010003)&#x3D;&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;)</span><br></pre></td></tr></table></figure><p>可以看出了是调用了intent类的，而且发现一个JokeActivity的类。联想到题目描述觉得应该是这个文件了，用jeb打开看一下(我当时做这道题的时候没想到这，被其他地方误导了)  </p><p><img src="2.jpg" alt=""></p><p>这是JokeActivity方法，我当时被这个给迷惑了…  </p><p><img src="3.jpg" alt=""></p><p>到这可以看出来是个AES加密，写出脚本就可以跑出来了(大概，我没试)<br>还有一种更简单的方法<br>学习一下<br>上述提到了intent这个包，它是对于Android程序安全性相关性很大的包，有了它之后我们就可以对这个APK进行调试<br><code>adb install gaiainvaders.apk</code>  </p><blockquote><blockquote><blockquote><p>adb全称Android Debug Bridge，是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。说直白一点就是通过adb可以实现<strong>用命令行控制设备。</strong></p></blockquote></blockquote></blockquote><p>使用adb有两种方法  </p><ol><li>需要安装安卓手机模拟器，这里我选择了网易的mumu模拟器，安装之后在<strong>platform-tools</strong>下运行adb程序<br><code>adb connect 127.0.0.1:7555</code><br>每个模拟器默认的端口不一样，具体的<a href="https://www.cnblogs.com/HakunaMatata-/p/10609307.html" target="_blank" rel="noopener">看这</a><br>等它显示success之后就表示连接上了，之后执行安装命令就好了  </li><li>用安卓手机之间连接，手机进入开发者模式，cmd中输入<br><code>adb devices</code><br>之后就安装就可以了  </li></ol><p>然后我们只需要运行JokeActivity这个类就能得到flag了，这里用<br><code>adb shell am start -n &quot;no.tghack.gaiainvaders/.JokeActivity&quot;</code>  </p><blockquote><blockquote><blockquote><p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具am.</p></blockquote></blockquote></blockquote><p>启动的方法为</p><p><code>adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}</code>  </p><p>然后就得到了flag<br><img src="4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是TG:HACK2020的一道比赛题目&lt;br&gt;题目给的hint很误导人…反正我没看出来  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.kittener.top/categories/Android/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于python2的encode(&#39;hex&#39;)在python3上的解决</title>
    <link href="http://www.kittener.top/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://www.kittener.top/2020/04/07/python2%E4%B8%8E3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-07T14:34:38.000Z</published>
    <updated>2020-04-17T16:07:22.783Z</updated>
    
    <content type="html"><![CDATA[<p>今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  </p><a id="more"></a>  <p>python2对于字符串转换成hex编码的时候使用的是str本身具有的方法，即str.encode(‘hex’)<br>但是这个方法在python3中取消了，解决方案如下：<br>首先  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 &#x3D; bytes(str,encoding &#x3D; &#39;utf-8&#39;)  </span><br><span class="line">str1.hex()</span><br></pre></td></tr></table></figure><p>即可  </p><p>顺便扩充一下知识：  </p><h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><h3 id="1-使用bytes函数创建bytes"><a href="#1-使用bytes函数创建bytes" class="headerlink" title="1.使用bytes函数创建bytes"></a>1.使用bytes函数创建bytes</h3><ul><li>bytes() 创建一个空的bytes  </li><li>bytes(int) 创建一个int位的全位0的bytes  </li><li>bytes(iterabl_of_ints) 可迭代数字组成的bytes(比如range)</li><li>bytes(string,encoding[,errors]) 等价于string.encode()</li><li>bytes(bytes of buffer) 创建一个bytes的copy  </li></ul><h3 id="2-直接定义"><a href="#2-直接定义" class="headerlink" title="2.直接定义"></a>2.直接定义</h3><p>比如：</p><p>​ b = b’abc’</p><p>​ b = b’\x61’</p><h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><ul><li>string.encode()</li><li>int.tobytes()</li><li>bytes.from</li><li>bytes函数定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes()</span><br><span class="line">b&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(3)</span><br><span class="line">b&#39;\x00\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(range(3))</span><br><span class="line">b&#39;\x00\x01\x02&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;中国&#39;, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line">&gt;&gt;&gt; bytes(b)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br></pre></td></tr></table></figure><p>直接创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; b&#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; 97</span><br><span class="line">&gt;&gt;&gt; n.to_bytes(1,byteorder&#x3D;&#39;big&#39;)</span><br><span class="line">b&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;中国&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.encode(encoding &#x3D; &#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe5\x9b\xbd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;61&#39;)</span><br><span class="line">b&#39;a&#39;</span><br></pre></td></tr></table></figure><h2 id="bytes的显示方式"><a href="#bytes的显示方式" class="headerlink" title="bytes的显示方式"></a>bytes的显示方式</h2><blockquote><blockquote><blockquote><p>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</p></blockquote></blockquote></blockquote><p>只有ASCII中的字符串是可以直接在bytes类型中显示出来的，所有大于127的数值用转义字符表达。</p><p>比如，内存中的字节对象用十六进制表示为61，在python中显示的方式不是b’\x61’ 而是b’a’；而b’\xe4’显示方式就是b’\xe4’；注意：仅仅是显示方式而已</p><p>另外，并不是所有的小于127的都可以被友好的显示出来，有些对象本身不可显示，就显示其十六进制表示。比如</p><p>b’\x00’</p><p>bytes的一般方法<br>bytes类似于string；在方法上，除了自己特有的方法外，跟str也类似。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.find(b&#39;\x63&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b&#39;abc&#39;.replace(b&#39;\61&#39;,b&#39;A&#39;)</span><br><span class="line">b&#39;abc&#39;</span><br></pre></td></tr></table></figure><h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><p>bytearray是可变的bytes数据类型，可以通过bytearray创建和定义</p><h3 id="一：bytearray-定义"><a href="#一：bytearray-定义" class="headerlink" title="一：bytearray()定义"></a>一：bytearray()定义</h3><ul><li><p>bytearray() 创建一个空的bytearray</p></li><li><p>bytearray(int) 创建一个int位的全位0的bytearray</p></li><li><p>bytearray(iterabl_of_ints) 可迭代数字组成的bytearray(比如range)</p></li><li><p>bytearray(string,encoding[,errors]) 将一个字符串编码为bytearray</p></li><li><p>bytearray(bytes of buffer) 创建一个bytearray</p><h3 id="二-bytearray的方法定义"><a href="#二-bytearray的方法定义" class="headerlink" title="二: bytearray的方法定义"></a>二: bytearray的方法定义</h3></li><li><p>bytearray.fromhex()  </p><h3 id="bytearray的一般方法"><a href="#bytearray的一般方法" class="headerlink" title="bytearray的一般方法"></a>bytearray的一般方法</h3></li></ul><p>bytearray具备bytes的操作方法，像字符串一样操作；</p><p>另外bytearray还具备像list一样的操作方法，比如pop，append等</p><h3 id="bytes-和-bytearray的方法"><a href="#bytes-和-bytearray的方法" class="headerlink" title="bytes 和 bytearray的方法"></a>bytes 和 bytearray的方法</h3><p>十六进制和字节类型的相互转换  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bytes.fromhex()</span><br><span class="line">bytearray.fromhex()</span><br><span class="line">bytes.hex()</span><br><span class="line">bytesarray.hex()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; bytes(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; ba &#x3D; bytearray(&#39;hell&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">b&#39;hell&#39;</span><br><span class="line">&gt;&gt;&gt; ba</span><br><span class="line">bytearray(b&#39;hell&#39;)</span><br><span class="line">&gt;&gt;&gt; b.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br><span class="line">&gt;&gt;&gt; ba.hex()</span><br><span class="line">&#39;68656c6c&#39;</span><br></pre></td></tr></table></figure><p>但是decode的好像没有特别好的办法除了使用binascii模块…  </p><h2 id="binascii模块的使用"><a href="#binascii模块的使用" class="headerlink" title="binascii模块的使用"></a>binascii模块的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>binascii模块包含很多用来方法来转换二进制和各种ASCII编码的二进制表示法。通常不直接使用这些功能，而是使用封装模块，如uu, base64或binhex。binascii模块包含用C语言编写更快的低级功能，通常为高级模块所使用。  </p><ul><li>相关模块  </li></ul><ol><li>base64 模块</li><li>binhex 模块</li><li>uu 模块</li><li>quopri 模块  </li></ol><h3 id="UU编码"><a href="#UU编码" class="headerlink" title="UU编码"></a>UU编码</h3><p>相关函数binascii.a2b_uu(string)和binascii.b2a_uu(data)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p><h3 id="Binhex编码"><a href="#Binhex编码" class="headerlink" title="Binhex编码"></a>Binhex编码</h3><p>相关函数有：binascii.rledecode_hqx(data) ，binascii.rlecode_hqx(data)，binascii.b2a_hqx(data) ，binascii.crc_hqx(data, crc)，更多资料点<a href="http://docs.python.org/2/library/uu.html" target="_blank" rel="noopener">这</a>  </p><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>binascii.a2b_base64(string)：转换的base64数据块为二进制，并返回二进制数据。一次可以传递多行。和base64. b64decode对应。 binascii.b2a_base64(data)：转换二进制数据为一行base64编码的ASCII字符。返回字符串包含换行符。根据base64的标准data的长度最大为57。和base64. b64encode对应。，更多资料点<a href="http://docs.python.org/2/library/base64.html" target="_blank" rel="noopener">这</a>  </p><h3 id="QP编码"><a href="#QP编码" class="headerlink" title="QP编码"></a>QP编码</h3><p>Quoted-printable，或QP encoding，没有规范的中文译名，可译为“可打印字符引用编码”、“使用可打印字符的编码”。Quoted-printable是使用可打印的 ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。  </p><p>QP使用”=”开头的转义字符. 一般限制行宽为76，因为有些软件限制了行宽.  </p><p>binascii.a2b_qp(string[, header])：转换引述打印数据块为二进制，并返回二进制数据。多行可以在同一时间被传递。如果可选参数头存在和真实，下划线将被解码为空格。  </p><p>实际上，QP码是是把’\x00’转换成’=00’，也就是替换’\x’为’=’。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D;&#39;\x00&#x3D;&#39;</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;&#x3D;\x00hello&#39;</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; encoded &#x3D; binascii.b2a_qp(s)</span><br><span class="line">&gt;&gt;&gt; encoded</span><br><span class="line">&#39;&#x3D;3D&#x3D;00hello&#39;</span><br><span class="line">&gt;&gt;&gt; decoded &#x3D; binascii.a2b_qp(encoded)</span><br><span class="line">&gt;&gt;&gt; print decoded</span><br><span class="line">&#x3D;hello</span><br><span class="line">&gt;&gt;&gt; print repr(decoded)</span><br><span class="line">&#39;&#x3D;\x00hello&#39;</span><br></pre></td></tr></table></figure><h3 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h3><p>binascii.crc32(data[, crc])：计算的data 的32位校验和CRC- 32时，crc为初始CRC 。crc32与ZIP文件的校验和一致。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print binascii.crc32(&quot;hello world&quot;)</span><br><span class="line">222957957</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot;hello&quot;)</span><br><span class="line">&gt;&gt;&gt; crc &#x3D; binascii.crc32(&quot; world&quot;, crc) &amp; 0xffffffff</span><br><span class="line">&gt;&gt;&gt; print &#39;crc32 &#x3D; 0x%08x&#39; % crc</span><br><span class="line">crc32 &#x3D; 0x0d4a1185</span><br><span class="line">&gt;&gt;&gt; crc</span><br><span class="line">222957957</span><br></pre></td></tr></table></figure><h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><p>binascii.b2a_hex(data)和binascii.hexlify(data)：返回二进制数据的十六进制表示。每个字节被转换成相应的 2位十六进制表示形式。因此，得到的字符串是是原数据长度的两倍。 binascii.a2b_hex(hexstr) 和 binascii.unhexlify(hexstr)：从十六进制字符串hexstr返回二进制数据。是b2a_hex的逆向操作。 hexstr必须包含偶数个十六进制数字（可以是大写或小写），否则报TypeError。  </p><pre><code>&gt;&gt;&gt; s = &apos;hello&apos;&gt;&gt;&gt; b = b2a_hex(s)&gt;&gt;&gt; print b68656c6c6f&gt;&gt;&gt; a2b_hex(b)&apos;hello&apos;&gt;&gt;&gt; b = hexlify(s)&gt;&gt;&gt; print b68656c6c6f&gt;&gt;&gt; unhexlify(b)&apos;hello&apos;</code></pre><p>参考博客：<a href="https://www.jianshu.com/p/701960098b7a" target="_blank" rel="noopener">https://www.jianshu.com/p/701960098b7a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在实验RSA加解密的文件的时候，由于该文件是基于python2写的，所以在python3上没有很好的运行，记录一下这个知识点  &lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.kittener.top/categories/python/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>静态编译</title>
    <link href="http://www.kittener.top/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/"/>
    <id>http://www.kittener.top/2020/03/24/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</id>
    <published>2020-03-24T12:20:32.242Z</published>
    <updated>2020-03-31T04:27:10.288Z</updated>
    
    <content type="html"><![CDATA[<p>今天由一道入群题入手之后了解到了静态编译这个知识：  </p><ul><li><a id="more"></a>  </li></ul><h3 id="1-静态编译："><a href="#1-静态编译：" class="headerlink" title="1.静态编译："></a>1.静态编译：</h3><p>编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，<br>使可执行文件在运行时不需要依赖于动态链接库.</p><h3 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2.动态编译:"></a>2.动态编译:</h3><p>动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一<br>方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p><p>然后静态库的连接与使用看<a href="https://www.cnblogs.com/xiaotianxiedaima/p/9824643.html" target="_blank" rel="noopener">这</a></p><p>IDA使用sig文件的说明看<a href="https://www.jianshu.com/p/7a1441e4f355" target="_blank" rel="noopener">这</a><br>但是我的libc.a是在/usr/lib/x86_64-linux-gnu下的并不是这篇博客的libx32下的<br>然后这道题好像因为glibc版本的关系，还是有一些库函数没被解出来，所以我被迫爆破出了flag…  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天由一道入群题入手之后了解到了静态编译这个知识：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://www.kittener.top/categories/re/"/>
    
    
      <category term="技术" scheme="http://www.kittener.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
